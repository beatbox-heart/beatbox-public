/* 
 * Purpose of this script: Example bbs script for 1-D FHN AP propagation 
 * simulation.
 *
 * Inputs: 
 *   fhn.par with common parameters; 
 *   fhn0.rec (obtained by running fhn0.bbs).
 *
 * Outputs: 
 *   onscreen graphics if used;
 *   a record file called fhn1.rec representing a point record during n-th front, n=5.
 *
 * This bbs script demonstrates the use of the following syntax and devices:
 *
 * 1. angle brackets <...> to include contents of another file;
 * 2. backticks `...` to capture output of a child process 
 *    (here just counting the number of lines in the given file);
 * 3. "poincare" and "k_poincare": devices to detect arrivals of wavefronts at selected points, 
 *    which is then used both to control execution and to calculate the 
 *    propagation speed;
 * 4. "k_plot": a run-time graphics device to plot spatial profiles of the 
 *    dynamic fields at selected moments of time;
 * 5. "pause": a device for suspending execution and keeping the last 
 *    picture on the screen until the user presses enter in the terminal 
 *    window. 
 *
 * Before running this script, make sure that a correct fhn0.rec has been 
 * created by running fhn0.bbs.
 *
 * To run this bbs script with graphics, use the following command:
 *
 * Beatbox_SEQ fhn1.bbs
 *
 * and to run without graphics, use the following command:
 *
 * Beatbox_SEQ fhn1.bbs -nograph
 *
 */

// Include the file fhn.par with common parameters.
<fhn.par>

// the size of 1D strand
def int nx 100; 

// The size of the model is xmax*ymax*zmax*vmax, where vmax=3 is the number 
// of the reserved dynamical variables: 
// 2 dynamical variables for the FHN model + 1 dynamical variable reserved 
// for the intercellular current (the Laplacian). 
state xmax=nx+2 ymax=1 zmax=1 vmax=[i]+1;

// Get the pacelength = number of lines in file fhn0.rec.
// This is in timesteps of this fhn1.bbs script, which are 10x longer than the steps in fhn0.bbs. 
// This is needed to make the period of waves here the same
// as the period of oscillations generated by fhn0.bbs. 
def real pacelength `cat fhn0.rec | wc -l`;

// To get an arbitrary period P, uncomment this instead:
// def real P 100; /* or whatever */; def real pacelength P/ht;

// Define the device control variables. 
def real begin; // will be nonzero at the first step of simultion, 
def real often; // ... at the steps when the output is done, at regular intervals,
def real paceout; // ... when it is time to output the pulse record
def real end;   // ... when it is time to stop


// Define the output points on the 1D fibre where the state variables 
// will be recorded.
def real xout1 nx*0.5;
def real xout2 nx*0.75;
// And these will be the recorded values of the state variables
def real V1;
def real U2; def real V2;
// Times of arrival at points xout1 and xout2
def real T1; def real T2;
// The number pulses to pass
def int Np 5;

// The resting state values
def real Ust;def real Vst;

// Use k_func to assign values to the device control variables
k_func name=timing nowhere=1 pgm={
  begin = eq(t,0);          /* 1 when t is equal to zero, 0 otherwise */
  often = eq(mod(t,10),0);  /* 1 if t is divisible by 10, 0 otherwise */
  end   = ge(t,100000);	    /* 1 if t is greater or equal than 200000, 0 otherwise */
};

//************************************************
// Calculations


// The boundary conditions on the left boundary.
// The form of oscillations is from file fhn0.rec produced by fhn0.bbs
// and the period of oscillations is pacelength steps, so will be the same
// if the output step in fhn0.bbs is the same as time step here
k_func name=bc x0=1 x1=1 file=fhn0.rec pgm={phasep=(2*pi*t)/pacelength;u0=p0;};

// The diffusion substep: second derivative of [u] times D goes to [i]
diff v0=[u] v1=[i] hx=hx D=D;

// The reaction substep: [i] gives the extra term in the right-hand side for u. 
// The rest=10000 parameter allows calculation of resting state. 
euler name=ode1 v0=[u] v1=[v] ht=ht ode=fhncub rest=10000
par={eps=eps bet=bet gam=gam Iu=@2};

// Measure the output signals
sample name=U2 x0=xout2 v0=[u] result=U2; 
sample name=V2 x0=xout2 v0=[v] result=V2;

// The very first of these measurements will be the resting state
k_func name=rest when=begin nowhere=1 pgm={Ust=U2;Vst=V2};

//************************************************
// The graphics output window will be with 600x600 resolution with 10-pixel rims,
// located 10 pixels from the right and 10 pixels from the top of the screen. 
screen WINX=-10 WINY=10 XMAX=620 YMAX=340;
// The coordinates of the output zone
def int row0 30; def int row1 329;
def int col0 10; def int col1 609;

// If the X11 graphics is switched off, then 
// these clock devices would still print time labels to the stdout,
// so the "if" clause at the front disables that. 
if Graph clock   when=often color=WHITE row0=1 col0=1; // this shows the integer step counter 
if Graph k_clock when=often color=WHITE row0=1 col0=21 code=t*ht format="T=%4.1f ms"; // this shows real model time
// the row, col coords of these are in characters, not pixels

// The run-time plots of the solution
k_plot name=uplot when=often 
  col0=col0 col1=col1 row0=row0 row1=row1 // defines the part of the graph window for this output
  color=WHITE*16+WHITE			  // colour of the "window" border	
  lines=1 				  // connect the dots
  clean=1                                 // clean window before drawing this graph
  ordmin=umin ordmax=umax		  // limits for the ordinate of the plot
  N=nx					  // the abscissa will be integer running from 1 to nx
  pgm={ord=u(abs,0,0,[u]);col=LIGHTRED};  // ordinate is value of u variable at the point, plot in light red
k_plot name=vplot when=often 
  col0=col0 col1=col1 row0=row0 row1=row1 // in the same window
  color=WHITE*16+WHITE			  // 
  lines=1 				  // 
  clean=0                                 // but do not clean it beforehand
  ordmin=vmin ordmax=maxv		  // limits for the ordinate
  N=nx					  // 
  pgm={ord=u(abs,0,0,[v]);col=LIGHTBLUE}; // which is now v variable, and plotted in light blue
update when=often;  // this signals that the graphics output buffer is flushed to the screen

//************************************************
// Measurements and file outputs

// Declare variables for registering fronts and measuring speed
def real front1;   // will be nonzero only when front at point 1 is registered
def real tfront1;  // interpolated value t at the front 1 event. 
def int nfront1 0;  // counter of the fronts at point 1
def real front2;   // will be nonzero only when front at point 2 is registered
def real tfront2;  // interpolated value t at the front 2 event. 
def int nfront2 0;  // counter of the fronts at point 2

// These devices will register arrival of the fronts at points xout1 and xout2.
// These two different devices have different interface but on this occation
// do the same job. 
poincare x0=xout1 cross=umid sign=1 result=front1 timestep=tfront1;
k_poincare nowhere=1 sign=1 pgm={front2=U2-umid;tfront2=t};

// Count the fronts separately, calc arrival times and select Nth front in each sequence
k_func nowhere=1 when=front1 pgm={nfront1=nfront1+1; T1=if(eq(nfront1,Np),ht*tfront1,T1)};
k_func nowhere=1 when=front2 pgm={nfront2=nfront2+1; T2=if(eq(nfront2,Np),ht*tfront2,T2);
  paceout=eq(nfront2,Np); /* if it is the last pulse we output it */    
  end=end+gt(nfront2,Np); /* and if more then it is time to stop; '+' works as "or" */
};

// Calculate and report the propagation speed to standard output
k_print nowhere=1 when=end file=stdout headformat="c=" headcode=0 list={(xout2-xout1)*hx/(T2-T1)};

// Output the record of dynamical variables u and v at the "samplepoint" 
// while "paceout" is nonzero into the file fhn1.rec.
k_print nowhere=1 when=paceout file=[0].rec append=0 valuesep="\t" list={U2;V2};

// Dump all state variables from all nodes into the binary file fhn1.dmp for future use.
dump append=0 when=end v0=0 v1=2 file=[0].dmp;

// Keep the picture on the screen until the user presses Enter
if Graph pause seconds=1 when=end;

/* Stopping criterion. This is mandatory.*/ 
stop when=end;
end;
