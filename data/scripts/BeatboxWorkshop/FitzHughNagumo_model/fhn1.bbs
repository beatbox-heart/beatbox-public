/* 
 * Purpose of this script: Example bbs script for 1-D FHN AP propagation simulation.
 *
 * Inputs: fhn0.rec (obtained by running fhn0.bbs)
 *
 * Outputs: onscreen graphics if used with graphics, and a record file called fhn1.rec
 *          representing a point record during n-th front, n=5
 *
 * This bbs script demonstrates the use of the following syntax and devices:
 * 1. angle brackets <...> to include content of another file;
 * 2. backticks `...` to capture output of a child process 
 *    (here just counting the number of lines in the given file);
 * 3. "k_poincare": device to detect arrivals of wavefronts at selected points, 
 *     which is then used both to control execution and to calculate the propagation speed;
 * 4. "k_plot": a run-time graphics device to plot spatial profiles of the dynamic fields at 
 *     selected moments of time;
 * 5. "pause": a device for suspending execution and keeping the last picture on the screen 
 *     until the user presses enter in the terminal window. 
 *
 * Before running this script, make sure that a correct fhn0.rec has been created by running fhn0.bbs.
 * To run this bbs script with graphics, use the following command:
 * Beatbox_SEQ fhn1.bbs
 *  and to run without graphics, use the following command:
 * Beatbox_SEQ fhn1.bbs -nograph
 */

// Include the file fhn.par with the input and output parameters.
<fhn.par>

// the size of 1D strand
def int nx 100; 

// The size of the model is xmax*ymax*zmax*vmax, where vmax=3 is the number 
// of the reserved dynamical variables: 
// 2 dynamical variables (layers) for the FHN model + 1 dynamical variable (layer i=2, see in the file fhn.par) reserved 
// for the intercellular current (the Laplacian). 
state xmax=nx+2 ymax=1 zmax=1 vmax=[i]+1; // that means vmax=2+1=3

// Get the pacelength = number of lines in file fhn0.rec.
// This is needed to make the period of waves here the same
// as the period of oscillations generated by fhn0.bbs. 
def real pacelength `cat fhn0.rec | wc -l`;

// To get an arbitrary period P, uncomment this instead:
// def real P 100; /* or whatever */; 
// def real pacelength P/ht;

// Define the device time control variables. 
def real begin; // will be nonzero at the first step of simultion, 
def real often; // ... at the steps when the output is done, at regular intervals,
def real paceout; // ... when it is time to output the pulse record
def real end;   // ... when it is time to stop


// Define the "output" points on the 1D fibre where the state variables 
// will be recorded.
def real xout1 nx*0.5;
def real xout2 nx*0.75;
// And these will be the recorded values of the state variables at the "output" points:
// declare the point sample variables.
def real U1; 
def real V1;
def real U2; 
def real V2;
// Times of the pulse Np arrival at points xout1 and xout2
def real T1; 
def real T2;
// The number of pulses to pass
def int Np 5;

// The resting state values
def real Ust;
def real Vst;

// Use k_func to assign values to the "time control" variables
k_func name=timing nowhere=1 pgm={
  begin = eq(t,0);          /* 1 when t is equal to zero, 0 otherwise */
  often = eq(mod(t,10),0);  /* 1 if t is divisible by 10, 0 otherwise */
  end   = ge(t,100000);	    /* 1 if t is greater or equal than 200000, 0 otherwise */
};

//************************************************
// Calculations


// The "oscillating" boundary conditions on the left boundary, 
// that is at the space interval "from x0=1 to x1=1".
// The form of oscillations is from file fhn0.rec produced by fhn0.bbs
// and the period of oscillations is pacelength steps, so will be the same
// if the output step in fhn0.bbs is the same as time step here
k_func name=bc x0=1 x1=1 file=fhn0.rec pgm={phasep=(2*pi*t)/pacelength;u0=p0;};

// The diffusion substep: second derivative of [u] times D goes (is stored) to the layer [i]
diff v0=[u] v1=[i] hx=hx D=D;

// The reaction substep: the reserved variable Iu gives the extra term in the right-hand side for u, 
// Iu is taken from layer 2: Iu=@2, which is the layer [i] where Laplacian is stored. 
// The rest=10000 parameter allows calculation of resting state. 
euler name=ode1 v0=[u] v1=[v] ht=ht ode=fhncub rest=10000
par={eps=eps bet=bet gam=gam Iu=@2};

// Measure the output signals at the "output" points at every time step (when=always by default) 
// and assign the values to U1, V1, U2, and V2 accordingly
sample name=U1 x0=xout1 v0=[u] result=U1; 
sample name=V1 x0=xout1 v0=[v] result=V1;
sample name=U2 x0=xout2 v0=[u] result=U2; 
sample name=V2 x0=xout2 v0=[v] result=V2;

// The very first of these measurements at the output point xout2, at the time step "begin", 
//are assigned the "resting state" variables Ust and Vst
k_func name=rest when=begin nowhere=1 pgm={Ust=U2;Vst=V2};


//************************************************
// The graphics output window will be with 800x440 resolution with 10-pixel rims,
// located 10 pixels from the right and 10 pixels from the top of the screen. 
screen WINX=-10 WINY=10 XMAX=820 YMAX=440;
// The coordinates of the output zone
def int row0 30; def int row1 429;
def int col0 10; def int col1 809;

// If the X11 graphics is switched off, then 
// these clock devices would still print time labels to the stdout,
// so the "if" clause at the front disables that. 
if Graph clock   when=often color=WHITE row0=1 col0=1; // this shows the integer step counter 
if Graph k_clock when=often color=WHITE row0=1 col0=21 code=t*ht format="T=%4.1f ms"; // this shows real model time
// the row, col coords of these are in characters, not pixels

// The run-time plots of the solution
k_plot name=uplot when=often 
  col0=col0 col1=col1 row0=row0 row1=row1 // defines the part of the graph window for this output
  color=WHITE*16+WHITE			  // colour of the "window" border	
  lines=1 				  // connect the dots
  clean=1                                 // clean window before drawing this graph
  ordmin=umin ordmax=umax		  // limits (see defined in fhn.par) for the ordinate of the plot 
  N=nx					  // the abscissa will be integer running from 1 to nx
  pgm={ord=u(abs,0,0,[u]);col=LIGHTRED};  // ordinate is value of u variable at the point, plot in light red
k_plot name=vplot when=often 
  col0=col0 col1=col1 row0=row0 row1=row1 // in the same window
  color=WHITE*16+WHITE			  // 
  lines=1 				  // 
  clean=0                                 // but do not clean it beforehand
  ordmin=vmin ordmax=vmax		  // limits (see defined in fhn.par) for the ordinate of the plot 
  N=nx					  // 
  pgm={ord=u(abs,0,0,[v]);col=LIGHTBLUE}; // which is now v variable, and plotted in light blue
update when=often;  // this signals that the graphics output buffer is flushed to the screen

//************************************************
// Measurements and file outputs

// Declare variables for registering fronts and measuring speed
def real front1;   // will be nonzero only when front at point 1 is registered
def real tfront1;  // interpolated value t at the front 1 event. 
def int nfront1 0;  // counter of the fronts at point 1
def real front2;   // will be nonzero only when front at point 2 is registered
def real tfront2;  // interpolated value t at the front 2 event. 
def int nfront2 0;  // counter of the fronts at point 2

// These devices will register arrival time of the fronts at points xout1 and xout2
// as variables U1 and U2 have been measured there;
// umid is defined in fhn.par ...
k_poincare nowhere=1 sign=1 pgm={front1=U1-umid;tfront1=t};
k_poincare nowhere=1 sign=1 pgm={front2=U2-umid;tfront2=t};

// Count the fronts separately, calc arrival times and select Nth front in each sequence
k_func nowhere=1 when=front1 pgm={nfront1=nfront1+1; T1=if(eq(nfront1,Np),ht*tfront1,T1)};
k_func nowhere=1 when=front2 pgm={nfront2=nfront2+1; T2=if(eq(nfront2,Np),ht*tfront2,T2);
  paceout=eq(nfront2,Np); /* if it is the last pulse we output it */    
  end=end+gt(nfront2,Np); /* and if more then it is time to stop; '+' works as "or" */
};

// Calculate and report the propagation speed to standard output
k_print nowhere=1 when=end file=stdout headformat="speed=" headcode=0 list={(xout2-xout1)*hx/(T2-T1)};
// Calculate and record the propagation speed into the file fhn1.speed 
k_print nowhere=1 when=end file=[0].speed append=0 headformat="speed=" headcode=0 list={(xout2-xout1)*hx/(T2-T1)};

// Print into the file [0].rec, that is file fhn1.rec the record of the dynamical variables u and v at the "samplepoint" xout2,
// at every time step
// while "paceout" is nonzero.
k_print nowhere=1 when=paceout file=[0].rec append=0 valuesep="\t" list={U2;V2};

// Keep the picture on the screen until the user presses Enter
if Graph pause when=end;

/* Stopping criterion. This is mandatory.*/ 
stop when=end;
end;
