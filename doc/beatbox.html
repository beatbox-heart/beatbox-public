<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="description" 
          content="Documentation for the beatbox heart simulation code.">
    <title>Beatbox Documentation</title>
    
    <link rel="stylesheet" type="text/css" href="docstyle.css"/>

    <!--[if IE]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <script type="text/javascript" src="ToC.js"></script>

  </head>
  <body>

<h1>The Beatbox Cardiac Simulation Software: A User's Guide</h1>
<hr/>

<!-- A table of contents is generated here using JavaScript above -->
<div id="toc">
<h2>Table of Contents</h2>
</div>

<hr/>

<!-- 
     This is where the content that is used to generate the ToC should 
     be placed. 
-->
<div id="contents">


<h1 class="numbered">Introduction</h1>

<p>
Beatbox is a program that could be compiled for sequential or parallel
(MPI) use. Currently it has a small collection of cell models,
including FitzHugh-Nagumo, Luo-Rudy I, Courtemanche et al. human
atrial (this list will be expanding) and solves reaction diffusion
equations with these cell models to simulate wave propagation in
idealised and realistic cardiac tissue models.  Currently the solvers
use finite differencing with regular spatial grid and forward Euler in
time with or without operator splitting.  Some semi-implicit solvers
are now in test exploitation and bidomain solvers are under
development.
</p>

<table class="figure">
  <caption>
    Figure 1: Conceptual view of a ring of devices.
  </caption>
<tr><td>
  <img
    src="imgs/device-ring.png"
    width="294" height="240"
    alt="Conceputal view of a ring of devices."
    style="margin:auto;display:block;"
    id="fig-1"/>
</td></tr>
</table>
<p>
A special feature of Beatbox is its flexibility in setting various
experimental protocols, without the need to recompile the package.  A
simulation is set up by constructing an input script that spatial
model (1D cable, 2D rectangel, 3D box, or 2D/3D geometry) details, and "devices", which perform
computations, input/output, and control functions. The simulation
script is typically called <code>filename.bbs</code>, where the
conventional extension <code>bbs</code> stands for "beatbox script",
and <code>filename</code> can be anything you like. The "devices" are
chained together in a ring, with an integer counter <code>t</code>,
usually corresponding to the time steps in the simulation. The concept
of the ring of devices is illustrated in <a href="#fig-1">Figure 1</a>.
In this example,
</p>

<dl>
<dt><code>k_func</code></dt>
<dd>

  (the first instance) works as a control device that defines when
  other devices will be active: the second <code>k_func</code> at the
  start of the computations, <code>ppmout</code> every so often, and
  <code>stop</code> in the end.

</dd>
<dt><code>k_func</code></dt>
<dd>

  (the second instance) works as a computational device defining the
  initial conditions,
  
</dd>
<dt><code>diff</code></dt>
<dd>

  is a computational device that performs diffusion substep in the
  operator-splitting time step,

</dd>
<dt><code>euler</code></dt>
<dd>

  ... performs reaction substep in the operator-splitting time step,

</dd>
<dt><code>ppmout</code></dt>
<dd>

  is an output device that writes rounded-up simulation results to the
  disk for subsequent visualization,

</dd>
<dt><code>stop</code></dt>
<dd> is a control device that terminates the run.</dd>
</dl>

<p>
Each device has a set of parameters, specific for it, e.g. the list of
parameters for <code>k_func</code> is different from that for
<code>diff</code> (but there are some "universal" and some "typical"
parameters, such as their control variables or the mesh domain on
which the device operates).  A simulation run can use more than one
instance of the given device, each of which may appear anywhere in the
ring; in this example <code>k_func</code> has two instances appearing
one after the other. All instances of the same device will have the same list of
parameters, but the values of parameters are set completely indepently
in different instances.
</p>

<p>
The function of the input script is to define the computational grid
and to describe all the devices for the given run together with their
parameters.
</p>

<p>
A simulation will thus typically involve:
</p>

<ol>
<li>
The input script being read and the simulation initialised:
<ul>
<li>
The simulation grid is created with the specified dimensions, and if
  realistic geometry is used, then the relevant subset of the
  simulation grid and the diffusion tensor field are defined, 
</li>
<li>
Devices are added to the ring of devices with the specified parameters.
</li>
</ul>
</li>
<li>
The simulation is run:
<ul>
<li>
Each device in the ring is called in turn to perform its part of the
simulation task, provided it is commanded to be active at this step by
the control device(s),
</li>
<li>
Repeat until the stop condition is met, or an error occurs.
</li>
</ul>
</li>
<li>
The simulation is terminated.
</li>
</ol>
<p>
In this distribution, there are some example scripts provided, which
illustrate the format of the input scripts and use of the devices.
A more formal description of the bbs script language and of the devices
available follow below. A certain stage of Beatbox development
is reflected in 
<a href="http://research-archive.liv.ac.uk/3173/">
Ross McFarlane, High-Performance Computing for Computational Biology
of the Heart, PhD Dissertation, October 2010,</a>
see Chapters 2 and 3 in particular. 

<h1 class="numbered">Setting-up Beatbox</h1>

<h2 class="numbered">Prerequisites</h2>

<p>
The developers tried to make Beatbox self-contained and reduce the
number of dependencies to an absolute minimum. You will require: 
</p>

<ul>
  <li>Certain <code>autotools</code>, notably <code>autoconf</code>
  and <code>automake</code>, to automatically configure the package
  for your computer. Pre-configured and pre-compiled versions will be
  provided in due course, when demand is established.</li>
  <li>A C compiler, ideally gcc.</li>
  <li>A suitable MPI library, preferably
  <a href="http://www.mcs.anl.gov/research/projects/mpich2/">mpich2</a>
  if you want to run in parallel.</li>
  <li>The standard X11 libraries if you want to have run-time
  visualization (currently only available in sequential mode).</li>
  <li>Some of the examples use utilities from
  <a href="http://netpbm.sourceforge.net/">netpbm</a>
  both for run-time image conversion and for post-processing.</li>
</ul>


<h2 class="numbered">Getting Beatbox</h2>

<p>
The recommended way to obtain BeatBox is to download the most recent
official release from the BeatBox home page,
</p>

<ul><li>
<a href="http://empslocal.ex.ac.uk/people/staff/vnb262/software/BeatBox/">
http://empslocal.ex.ac.uk/people/staff/vnb262/software/BeatBox/
</a>
</li></ul>

<p>
An alternative which may be more appropriate for beta-testers, is to
obtain the most recent version of BeatBox code from its SVN
repository, say by issuing the following commands:
</p>
<pre>
mkdir ~/beatbox
cd ~/beatbox
svn co --username=anonymous --password=beatbox https://beatbox-trac.epcc.ed.ac.uk/svn/trunk/ ./
</pre>
<p>
Note that this will be a read-only copy of the repository, i.e. you
will not be able to check any modifications back in. If you would like
to become a developer please get in touch with the project team.
</p>

<h2 class="numbered">Installation instructions</h2>

<h3 class="numbered">Compiling and installing Beatbox</h3>
<p>
Assuming that all the components mentioned above are available and in
place, the following sequence of commannds
<pre>
autoreconf -fi
export CC=mpicc
./configure CFLAGS="-g -O0" --prefix=$HOME
make
make install
</pre>

<p>
will compile two versions of the program, <code>Beatbox</code>
(parallel) and <code>Beatbox_SEQ</code> (sequential), and install them
in <code>$HOME/bin/</code>.  A shell script
<code>bbx_compile_local.sh</code> is provided in the root distribution
directory, to facilitate the
installation.
</p>

<p>
You may wish to change the install location specified in this file:
current setting <code>--prefix=$HOME</code> means that the binaries
will be installed in <code>$HOME/bin/</code>.  This is reasonable in
the assumption that that directory exists and is in your
<code>$PATH</code>; modify it as appropriate if you prefer to keep
your binaries elsewhere.
</p>

<p>
The options <code>CFLAGS="-g -O0"</code> mean that the code will be
prepared for debugging and not optimized; for "production runs" this
can be omitted and replaced by <code>CFLAGS="-O3"</code>.
</p>

<p>
If the script, <code>configure</code> or <code>Makefile</code> cannot
find the include and library files, the paths may have to be
explicitly incorporated into <code>src/Makefile.am</code> and then go
through the whole procedure starting from the <code>autoreconf
-fi</code> step. 
</p>

<h3 class="numbered">Compiling and installing Beatbox on HECToR</h3>

<p>
HECToR (<a href="http://www.hector.ac.uk">www.hector.ac.uk</a>) is the
national UK supercomputer service. HECToR is a Cray XE6 based
system. In order to install on HECToR, we need to cross compile for
back end nodes and make correct settings, 
so the process is a little bit different
(script <code>bbx_compile_hector.sh</code>): 
</p>
<pre>
# Create the configure and install scripts
autoreconf -fi

# Load the PGI compiler module
module load pgi

# Tell the configure command what compiler we need to use.
export CC=cc

# Need to explicitly tell the Cray system what X libraries to use
export LIBS="-lm -lX11 -lxcb -lxcb-xlib -ldl -lXau"

# Run configure - note that it will install in $HOME/bin
./configure --prefix=$HOME

# Now make the code
make

# Install the code to the directories specified by the prefix above.
make install
</pre>

<p>
Again, change the
<code>prefix</code> flag if you would like it to install
elsewhere.
</p>

<h2 class="numbered">Running Beatbox</h2>

<h3 class="numbered">General Instructions</h3>

<p>
The sequential version of the program may be run by using:
</p>

<pre>
   Beatbox_SEQ [&lt;options&gt;] [--] &lt;input_script&gt; [&lt;arguments&gt; | &lt;options&gt; | -- ]
</pre>
<p>
That is: the executable name (with the full path if necessary),
followed by the input
script and the arguments, if any, with options interpspersed anywhere after
the executable name. Similar to many Unix programs, options are those
words that start with a minus '<code>-</code>', but a double minus
'<code>--</code>' signals an end of all options so a word starting
with <code>-</code> after that is interpreted as input script name or
argument.
</p>

<p>
Correspondingly, assuming that you have mpich2, 
the parallel version on a local computer may be run using
<pre>
   mpirun -np &lt;num_procs&gt; Beatbox [&lt;options&gt;] [--] &lt;input_script&gt; [&lt;arguments&gt; | &lt;options&gt; | -- ]
</pre>

<p>
The parsing of the input script and the simulations are commented by
printing messages to the standard output and duplicating them into a
log file. 
</p>

<p>
The possible options are:
</p>

<ul>
<li><code>-append</code>: append to the log file. The default is to
  overwrite it</li> 
<li><code>-debug &lt;filename&gt; </code>: this produces a debug
  file. If <code>&lt;filename&gt;</code> is <code> stdout </code>
  or <code> stderr</code>, the debugging information is printed to
  standard output or standard error rather than a disk file of that
  name. The default is no debug printouts. 
<li><code>-log &lt;filename&gt; </code>: this set the name for the log
  file. The default is the name of the input script, stripped of the
  extension <code>.bbs</code> if there is one, and appended
  extension <code>.log</code>. </li>
<li><code>-mute</code>: no default output to stdout. The default is
  to copy a (possibly shorter) version of the log file information to
  the standard output.</li>
<li><code>-nograph</code>: do not use run-time VGA graphics. The default
  is to use it if there is at least one device that has something to
  show. This is only effective with the sequential version as the
  run-time graphics are not yet implemented for the parallel
  version.</li>
<li><code>-profile</code>: measure timing for each device in the ring
  and output it in the end. The default is not to measure and not to
  output that information.</li>
<li><code>-verbose</code>: this makes messages in the log file more
  verbose. The default brief output does not include e.g. the default
  values of the device parameters. </li>

<li><code>-decomp [1|2|&lt;NX&gt;x&lt;NY&gt;x&lt;NZ&gt;]</code> (in
  parallel mode only) : the choice of decomposition algorithm, namely
  1 due to RMF, 2 due to SRK and
  <code>&lt;NX&gt;x&lt;NY&gt;x&lt;NZ&gt;]</code> an explicit formula,
  where <code>NX,NY,NZ</code> are numbers of partitionings along the
  x, y and z axes respectively. Note that the explicit formula be
  given as one word consisting of exactly three positive integer
  numbers separated by two letters 'x'. In full-box simulations, the
  total number of subdomains <code>NX*NY*NZ</code> should not exceed
  the number of processes allocated for the job by the <code>-np
  &lt;num_procs&gt;</code> option of the <code>mpirun</code>
  command. If using tissue geometry (see <a
   href="#Tissue_Geometry:_simulating_in_non-rectangular_domains">below</a>) then the
  number of subdomains can be more than the number of processes, as
  long as the number of processes is sufficient to cover all non-empty
  subdomains, i.e. subdomains containing any tissue points. Default is
  1, for automatic partitioning by RMF algorithm.  Currently, neither
  of the automatic partitioning algorithms takes into account whether
  any subdomains are empty, so efficient use of "thin" geometries at
  high-degree parallelization requires the explicit decomposition formula.
  </ul>

<p class="quest"> CAVEAT: 
The options <code>-debug</code>, <code>-log</code> and <code>-decomp</code> 
gobble the next word for the name of the debug or log file; failure to 
appreciate that is a common error leading to weird behaviour. This should
be addressed one day, perhaps by making them like 
<code>-debug=&lt;filename&gt;</code> instead.
</p>

<p> The arguments can be used in the input script, where they appear
  as pre-defined string macros, see
  <a href="#Predefined_k-variables_and_string_macros">below</a>.
  The parsing is usual for
  the unix shells, that is each word makes a separate argument, except
  when quotes are used.

<h3 class="numbered">Beatbox on HECToR</h3>

<p>
This subsection gives a brief description on how to conduct
simulations on <a href="http://www.hector.ac.uk">HECToR</a> or a
similar HPC facility. Before starting any simulations, a
certain familiarity with HECToR architecture, compilers, modules, and
general terms of usage can be gained from
the <a href="http://www.hector.ac.uk/support/documentation/userguide/">HECToR
User Guide</a>. 
</p>

<p>
On HECToR compilation is done through a set of compilation wrappers,
<code>cc</code> will always correspond to the actual compilation
suite being used. The default version is for the Cray
compilers. Other compiler suites may be used (by loading and unloading
the appropriate modules), but will still use the same wrapper. The
compilation is done for the work nodes - thus we are cross compiling.
</p>

<p>
HECToR manages production as well as (parallel and serial) debugging
runs by using the
<a href="http://www.hector.ac.uk/support/documentation/userguide/batch.php">
PBSpro</a> queuing system. A PBS script consists of a set of PBS
commands, and other generic shell commands. A sample PBS script that
can be used to run Beatbox jobs is shown below. The commands are
explained in the comments (text following a <code>##</code> on any
line) - a line that starts with <code>#PBS</code> denotes a PBS
command. The following script was used to run the 3D atrium simulation
and is called <code>Beatboxrun64.sh</code>. Its contents are:
</p>

<pre>
#!/bin/bash --login

## A PBS command starts with #PBS.
## Start by specifying a name for the job.

#PBS -N Beatbox64

## Specify number of cores requested.

#PBS -l mppwidth=64

## Hector is composed of "nodes", each of which consist of 
## two 16 cores processors - thus one has 32 cores available in a node.
## The number of cores per node controls memory available to the job.
## Use of all cores in a node (assuming mppwidth is more than 32) 
## optimises the use AU charged to your account. 

#PBS -l mppnppn=32

## This is the amount of time requested for the simulation.

#PBS -l walltime=3:00:00

## A project code has to be provided, otherwise the job is usually
## not accepted by a queue.

#PBS -A e203

## Assume this PBS script lies in the same directory as the executable
## file. Note to be seen by the back end nodes this must lie in one of
## the work directories. Change directories to where the job was launched.
## You must make sure that you copied the Beatbox executable, the 
## humanAtrium.bbs and humanAtrium.bbg scripts to this directory for this
## to work.
cd $PBS_O_WORKDIR

## Run the job
## n is the total number of processes
## N is the number of processes per node
## Launch the parallel job using aprun. The stdout is called 
## Beatbox64.o_job_number, and stderr is called Beatbox64.e_job_number
aprun -n 64 -N 32 ./Beatbox humanAtrium_start_crn.bbs
</pre>

<p>
Before submitting any job using such a submission script, it may be
worthwhile to run a check on the script using the HECToR provided
<code>checkScript</code>:
</p>

<pre>
   checkScript Beatbox64.sh
</pre>

<p>
This will indicate if there are any errors in the script so you can
fix these before you submit it to the PBS system. The production job
is then submitted to a parallel queue using:
</p>
<pre>
  qsub Beatbox64.sh
</pre>

<p>
Further options are also available, and can be seen in the user
guide. Similarly to production, parallel debugging jobs must also be
submitted to the queue with the following command added:
</p>

<pre>
#PBS -v DISPLAY
</pre>

<p>
and the appropriate debugger binary name preceding
the <code>aprun</code>. For example, the <code>TotalView</code>
parallel debugger can be invoked by:
</p>

<pre>
  totalview aprun -a -b -a xt -n 64 -N 32 /work/.../myprog.x 
</pre>

<p>
The detailed submission script for debugging jobs can be found on the
<a href="http://www.hector.ac.uk/support/documentation/guides/bestpractice/debug.php">
relevant HECToR pages</a>.
</p>

<p>
The status of submitted jobs can be checked using the command:
</p>
<pre>
  qstat -u your_hector_user_name
</pre>

<p>
and the job is deleted using:
</p>

<pre>
  qdel job_number
</pre>

<h1 class="numbered">Beatbox Scripting Guide</h1>

<p>
A Beatbox simulation is defined by the user in the form of an input
script ("Beatbox script" or "bbs script"). A script is a plain text
file that specifies the computational grid, the devices that are to be
used to do the calculations and input/output, and their parameters.
Any script should be able to run on any of Beatbox’s supported
hardware platforms; if a sequential-only device is used in a script
submitted to parallel execution, the warning message will be output
but the script will run nonetheless.
</p>

<p>
This section introduces Beatbox scripts by first describing the
scripting language, before discussing common applications. Unlike
interpreted scripting languages such as PHP or Python, Beatbox scripts
are not run during the simulation. The script is read once to build
the simulation, after which the script code does no longer define the
flow of execution, so can be modified or removed with no consequences
for the current run.
</p>

<p>
Similar to other programming languages, Beatbox scripts allow the user
to define variables and macros, include external code and make calls
to the operating system. The Beatbox scripting language also provides
a small library of arithmetic and logical functions. The user may also
improve the legibility of their code, or disable portions of the code
using comments. Each of these features is discussed below.
<p>

<h2> For the impatient </h2>

<p>
If you prefer to learn by example rather than go through formal
definitions, you may wish to try and jump ahead to
<a href="#Putting_it_all_together:_a_simple_example">
a simple working example</a> and then only if and when
necessary go back to check out those formal definitions, or go forward
to further, more sophisticated examples.
</p>

<h2 class="numbered">The Data</h2>

<p>
Any Beatbox run operates with two sorts of data. One is the
computational grid, which is effectively a four-dimensional array of
real numbers (of the precision specified at compile time), which is
the object of operation of the computational devices. The four
dimensions are the three spatial dimensions <code>x,y,z</code> and the
"component" dimension <code>v</code>. Slices in the component
dimension are called "layers".
</p>

<p>
Associated with the computational grid
could be the geometry array (if complex geometry option is on), which
has the same shape as the main grid, and determines which points in it
belong to the computational domain and which are "void", and (if
anisotropy option is on) contains information about fiber directions.
</p>

<p>
The other are the arithmetic variables and string macros. The
arithmetic variables can be integer or real (with the precision
defined at compile time), their names following C convention.  The
input script interpreter contains a built-in interpreter of arithmetic
experession, so parameters of a device can be specified as arithmetic
expressions (possibly depending on arithmetic variables) rather than
specific values. The script is interpreted from top to bottom, so any
arithmetic variable will exist and have a valid value of it was
defined and assigned the value above the point at which it is
used. The exceptions are the pre-defined variables, such
as integer <code>t</code> containing the counter of the device ring
loop, and real <code>pi</code> containing the number pi. 
</p>

<p>
The string macros have the form of a string of characters
between <code>[</code> and <code>]</code>. 
The strings of characers making the names of the macros also have to
obey the C rules. The exception is string macros 
<code>[1]</code>, <code>[2]</code>, <code>[3]</code> ..., which cannot
be defined within the script, and which contain the values of the
command line arguments (see above). There some more pre-defined string
macros, e.g. names of colours used in VGA graphical devices.  The values
of ordinary string macros are assigned at the moment of their
definition. Whenever they are used in the script, their values are
simply substituted in place of <code>[...]</code> and the result is
interpreted as if it was part of the script all along. A string macro
may appear e.g. in the expression defining the value of an arithmetic
variable, which is one way to convert string macro to an arithmetic
expression.
</p>

<p>
In the parallel version, the computational grid (and the geometry
array) are split between the threads: if a particular value belongs to
one subdomain it is not accessible to another subdomain (with the
exception of halo points, see
<a href="#Specifics_of_the_parallel_execution">below</a>).
On the contrary, any arithmetic
variable or string macro is available in all threads; however
depending on its use, they may have different values in different
threads. 
</p>

<p class="quest"> Need to doublecheck the actual syntatic restrictions
  on variable and string macro names and bring the code and this
  manual in correspondence with each other. 
</p>

<h2 class="numbered">The Beatbox Scripting Language</h2>

<p>
After preprocessing (see <a href="#Preprocessing">below</a>), a Beatbox script consists of a series
of <em>commands</em>. A command is a sequence of characters (being
part of one line of script or spanning across several lines), 
beginning with a recognised keyword and ending with a semicolon
'<code>;</code>'. The following code excerpt shows examples of three commands:
</p>

<pre>
def int sideLength 26; state xmax=sideLength, ymax=sideLength, zmax=sideLength, vmax=3;
euler
v1=[iext]
ode=lrd
par={ht=ht IV=@24}
;
</pre>

<p>
This script defines <code>sideLength</code> which is the used initialise the 
state of the system before the <code>euler</code> device is called.
</p>

<p>
The types of command in a Beatbox script are listed below. Each
command describes an action to be taken by Beatbox, with the keyword
at the beginning of the command being the verb.
</p>

<ul>
<li><code>rem</code> - A ‘remark’. Marks code as a comment. This is
  being processed by the interpreter as usual (so e.g. it should no
  contain undefined string macros), but otherwise makes no
  consequences for the simulation.</li>
<li><code>if</code> - Allows a script command to be conditionally
  read. The keyword is to be followed by an arithmetic expression
  followed by a command with its own keyword. If the arithmetic
  expression returns a nonzerp value, the command is interpreted,
  otherwise it is ignored. This does not affect the flow of execution
  as the simulation is run, but operates much like conditional
  compilation.</li>
<li><code>def</code> - Defines a variable or macro.</li>
<li><code>state</code> - Sets the dimensions of the computational grid.</li>
<li><code>screen</code> - Sets parameter for on-screen display for the
  run-time VGA graphics.</li>
<li>A device name - Adds an instance of the named device, with the
  parameters as described in the body of the command, to the ring of
  devices. Some of the recognized device names are discussed
  <a href="#Beatbox_Device_Reference">below</a>;
  the full list is in <code>devlist.h</code> source file.</li>
<li><code>end</code> - Marks the end of the script. Anything after
  such statement is ignored.</li>
</ul>

<h2 class="numbered">Preprocessing</h2>

<p>
As each line of the script is parsed, Beatbox preprocesses the code in
a manner similar to the C Preprocessor [see Kernighan and Ritchie,
1988, chap. 4]. The Beatbox preprocessor handles four tasks:
</p> 

<ol>
<li>skipping comments,</li>
<li>including other Beatbox scripts,</li>
<li>calling system commands and</li>
<li>expanding string macros.</li>
</ol>

<p>
Each of these are discussed below.
</p>

<h3 class="numbered">Comments</h3>

<p>
Comments can be added to Beatbox scripts in five ways:
</p>

<ol>
<li>A C style comment:
<pre>
/*
 Multi-line C style comment
*/
</pre>
</li>
<li>A C++ style comment:
<pre>
// Single-line C++ style comment
</pre>
</li>
<li>A <code>rem</code> statement:
<pre>
rem ’Remark’ command-style comment, 
    which can go over serveral lines but 
    must end with a semicolon;
</pre>
</li>
<li>Anything added after an <code>end</code> command,
<pre>
...
end;
Anything here is now ignored by the Beatbox preprocessor so
it could be used to comment code..
</pre>
</li> 
<li>Anything within the body of any command which is not recognized as a
  valid <code>name=value</code> pair.
<pre>
Comment = As Beatbox does not know what the comment is this could be 
treated as a comment (probably not good practice though);
</pre>
</li>
</ol>

<p>
Text in a comment is ignored by the parser, except undefined macros
will cause fatal errors within a body of a <code>rem</code> or another command. 
</p>

<h3 class="numbered">Including Other Beatbox Scripts</h3>

<p>
Where the relative path to a Beatbox script file is enclosed in in
angle brackets (&lt; &gt;), the content of the referenced file will be
read and inserted at that location. Unlike in the C programming
language, the name of the file in angle brackets is not preceded by an
<code>#include</code> command. This can be used to maintain
consistency across a number of simulations, or to reduce code
redundancy. Beatbox replaces a filename in angle brackets with the
file’s entire contents. For example, given a script
called <code>useful.bbs</code>:
</p>

<table class="figure">
<caption>
Listing G.1: Script stored in a <code>useful.bbs</code> script file.
</caption>
<tr><td>
<pre>
// Here is a lot of useful code...
def real apar=1;
def real bpar=2;
</pre>
</td></tr>
</table>

<p>
and a script that includes <code>useful.bbs</code> as follows:
</p>

<table class="figure">
<caption>
Listing G.2: Another script that
includes <code>useful.bbs</code>.
</caption>
<tr><td>
<pre style="text: left;">
// This is my own script
&lt;useful.bbs&gt;
// Here’s some more of my own code.
def real cpar=3;
</pre>
</td></tr>
</table>


<p>
The result, after preprocessing, is as shown below:
</p>

<table class="figure">
<caption>
Listing G.3: Effective resultant script, after <code>useful.bbs</code>
has been included and comments eliminated. 
</caption>
<tr><td>
<pre>
def real apar=1;
def real bpar=2;
def real cpar=3;
</pre>
</td></tr>
</table>

<p>
The filename in the angular brackets may contain string macros which
are expanded in the usual way before the angular brackets operator is
applied.
</p>

<h3 class="numbered">Calling System Commands</h3>

<p>
Beatbox replaces code in backticks (<code>`...`</code>) with the
result of that code when run as a system command, via
a <code>system()</code> call (<code>stdlib.h</code>). For example:
</p>
<pre>
   `date '+%Y%m%d-%H:%M:%S'`
</pre>
<p>
will be replaced with the result of the UNIX date command:
</p>
<pre>
   20120710-09:30:55
</pre>

<h3 class="numbered">Expanding String Macros</h3>

<p>
String macros allow the user to define reusable strings that can be
pasted throughout a script. String macros are distinct from variables
in that they are expanded once, prior to the script being interpreted
and cannot therefore be assigned values other than when they are
defined. A string macro is defined as follows:
</p>

<pre>
def str &lt;macro name&gt; &lt;value&gt;;
</pre>

<p>
where <code>&lt;macro name&gt;</code> is a string using letters,
numbers, underscores (_) or hyphens (-) and <code>&lt;value&gt;</code>
is any string not including a semicolon.
</p>

<p class="quest"> Need to doublecheck the actual syntatic restrictions
  on variable and string macro names and bring the code and this
  manual in correspondence with each other. 
</p>

<p>
After a macro is defined, its name, wrapped in square brackets ( [ ] ) is
associated with its value. When Beatbox input script parser finds a
macro’s name in square brackets, it replaces them with the value.
</p> 

<p>
In the following excerpt, the variable <code>hat</code> is assigned
the value <code>porkpie</code>. The variable <code>headware</code> is
assigned the value <code>hat</code>.
</p>

<pre>
def str snack porkpie; // Assigned string ’porkpie’.
def str hat [snack];   // Assigned string ’porkpie’.
def str headware hat;  // Assigned string ’hat’, not value of hat macro.
</pre>

<p>
A macro can expand to anything that could be typed in the script. For
example, a string macro can be used in place of
an <code>int</code>, <code>long</code> or <code>real</code>:
</p>

<pre>
def str ninetynine 99;       // Assigned string value ’99’.
def int number [ninetynine]; // Assigned integer value 99.
</pre>

<p>
A number variable cannot, however, be used to define a macro:
</p>

<pre>
def int number 99;         // Assigned integer value 99.
def str ninetynine number; // Assigned string value ’number’.
</pre>

<p>
It is possible to assign several lines of code (excluding semicolons)
to a string macro, so this:
</p>

<pre>
def str instruction ppmout
when=out file="ppm/%04d.ppm" mode="w"
r=[u] r0=umin r1=umax
g=[v] g0=vmin g1=vmax
b=[i] b0=0 b1=255;
[instruction];
</pre>

<p>
is equivalent to:
</p>

<pre>
ppmout 
when=out file="ppm/%04d.ppm" mode="w"
r=[u] r0=umin r1=umax
g=[v] g0=vmin g1=vmax
b=[i] b0=0 b1=255;
</pre>

<h2 class="numbered">Defining Arithmetic Variables with the def Command</h2>

<p>
Arithmetic variables defined in the script are distinct from the C
language variables used in Beatbox’s implementation. For clarity,
variables defined in the script, using <code>def</code> may be
referred to as "k-variables".
</p>

<p>
A k-variable is defined using the <code>def</code> command, like this:
</p>

<pre>
def &lt;type&gt; &lt;name&gt; [=] &lt;value&gt;;
</pre>

<p>
where <code>&lt;type&gt;</code> is one of:
<ul>
<li><code>int</code> (integer number),</li>
<li><code>long</code> (integer number),</li>
<li><code>real</code> (real number),</li>
<li><code>float</code> (real number), </li>
<li><code>double</code>:  (real number), </li>
</ul>

<p>
so k-variables and arithmetic expressions only have two data types,
real and integer, and their actual precision (<code>int</code>
or <code>long int</code>, <code>float</code> or <code>double</code>)
is determined at the compile time by the settings
in <code>k_.h</code>; typically
<code>long</code> and <code>double</code> respectively.
</p>

<p>
A <code>&lt;variable name&gt;</code> can consist of letters,
numbers, underscores (_) or hyphens (-).
</p>

<p>
Variables defined in this way are accessible in the script 
during the input script parsing, as well as at run-time by some
devices, e.g. <code>k_func</code>.
</p>

<p>
The <code>&lt;value&gt;</code> (optional) is an
expression that may be evaluated to the correct type and is assigned
as the initial value of the variable just defined. Expressions are
discussed in greater detail below. If no initial value is given, the
variable is assigned the initial value of 0 or 0.0 as appropriate.
</p>

<p>
Beatbox stores the names of macros wrapped in their square
brackets (<code>[...]</code>), therefore it is possible for a script to define
macros and variables with the same name.
</p>


<h2 class="numbered">Predefined k-variables and string macros</h2>

Some variables and macros exist without being defined in the input
script. All of them are read-only, i.e. cannot be modified in the
input script. These are:

<ul>
<li> <code>[0]</code> - string macro containing the name of the
  beatbox script, without the extension <code>.bbs</code>. </li>
<li> <code>[1], [2], ...</code> - string macros containing the command line
arguments passed to the script. </li>
<li> <code>t</code> - integer, the counter of the device ring loops. </li>
<li> <code>inf</code> - "infinity", a very big real number.</li>
<li> <code>xmax,ymax,zmax,vmax</code> - integer, the computational
grid sizes as defined by the <code>state</code> command, even if
implicitly from the geometry.</li>
<li> <code>Graph</code> - integer, 0 if <code>-nograph</code>
command line option was given or the parallel version of the program
  is run, and 1 otherwise.</li>
<li> <code>graphon</code> - integer, nonzero if VGA graphical output has
actually been initiated (e.g. connection to the X server successful). </li>
<li> <code>XMAX,YMAX </code> - integer, sizes of the VGA graphical screen
when run-time graphics is on, in pixels, as specified
by <code>screen</code> command. </li>
<li> <code>WINX,WINY</code> - integer, the coordinates of the
VGA graphical window on the screen, as specified by <code>screen</code>
command. </li>
<li> <code>
  BLACK,
  BLUE,
  GREEN,
  CYAN,
  RED,
  MAGENTA,
  BROWN,
  LIGHTGRAY,
  DARKGRAY,
  LIGHTBLUE,
  LIGHTGREEN,
  LIGHTCYAN,
  LIGHTRED,
  LIGHTMAGENTA,
  YELLOW,
  WHITE
</code> - integer codes of the standard VGA colours to be used in the
run-time VGA graphics.</li>
<li> <code>pi</code> - the real number pi=3.1415926...</li>
<li> <code>always</code> - the real 1.0.</li>
<li> <code>never</code> - the real 0.0.</li>
</ul>

Apart from these, some devices have their own predefined variables
with the scope restricted to the body of that device. 

<h2 class="numbered">Expressions</h2>

<p>
Any numerical value in a Beatbox script, be it initial value in a
variable definition or the value of a device parameter, may be
specified as a mathematical expression. An expression may be a literal
value, such as 5.0, or the result of some computation, such
as <code>6*5</code> or <code>count/2</code>.
</p>

<p>
Beatbox expressions can use the standard infix arithmetic operators:
addition (+), subtraction (-), multiplication (*), division (/) and
exponentiation (** or ^), as well unary plus and minus. For more
complex operations Beatbox provides a collection of functions, that
includes replicas of standard <code>C</code> functions
<code>acos</code>,
<code>asin</code>,
<code>atan2</code>,
<code>atan</code>,
<code>ceil</code>,
<code>cos</code>,
<code>erf</code>,
<code>exp</code>,
<code>fabs</code>,
<code>floor</code>,
<code>fmod</code>,
<code>hypot</code>,
<code>log10</code>,
<code>log</code>,
<code>pow</code>,
<code>sin</code>,
<code>sqrt</code>,
<code>tan</code>,
<code>tanh</code>,
and also 
</p>
<ul>
<li>
<code>J0(a)</code> - Returns the Bessel function of the first kind
of argument <code>a</code> and index 0. 
</li>

<li>
<code>J1(a)</code> - Returns the Bessel index-1 function
of <code>a</code>.
</li>
<li>
<code>if(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> evaluates to true, <code>else</code>
otherwise.
</li>
<li>
<code>ifne0(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> is not equal to 0, <code>else</code>
otherwise.
</li>
<li>
<code>ifeq0(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> is equal to 0, <code>else</code> otherwise.
</li>
<li>
<code>ifgt0(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> is strictly greater than 0, <code>else</code>
otherwise.
</li>
<li>
<code>ifge0(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> is greater than or equal to 0, <code>else</code>
otherwise.
</li>
<li>
<code>iflt0(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> is strictly less than 0, <code>else</code>
otherwise.
</li>
<li>
<code>ifle0(test, then, else)</code> - Returns <code>then</code>
if <code>test</code> is less than or equal to 0, <code>else</code>
otherwise.
</li>
<li>
<code>ifsign(test, neg, zero, pos)</code> - Returns <code>neg</code>
if <code>test</code> is strictly less than 0, <code>zero</code> if
test is equal to 0, <code>pos</code> if <code>test</code> is strictly
greater than 0.
</li>
<li>
<code>gt(a, b)</code> - Returns 1.0 if <code>a</code> is strictly
greater than <code>b</code>.
</li>
<li>
<code>ge(a, b)</code> - Returns 1.0 if <code>a</code> is greater than
or equal to <code>b</code>.
</li>
<li>
<code>lt(a, b)</code> - Returns 1.0 if <code>a</code> is strictly less
than <code>b</code>.
</li>
<li>
<code>le(a, b)</code> - Returns 1.0 if <code>a</code> is less than or
equal to <code>b</code>.
</li>
<li>
<code>eq(a, b)</code> - Returns 1.0 if <code>a</code>
and <code>b</code> are equal.
</li>
<li>
<code>ne(a, b)</code> - Returns 1.0 if <code>a</code>
and <code>b</code> are not equal.
</li>
<li>
<code>mod(a, b)</code> - A synonym for </code>fmod</code>.
</li>
<li>
<code>max(a, b)</code> - Returns the greater of <code>a</code>
or <code>b</code>.
</li>
<li>
<code>min(a, b)</code> - Returns the lesser of <code>a</code>
or <code>b</code>.
</li>
<li>
<code>crop(test, min, max)</code> - Returns <code>min</code>
if <code>test</code> is strictly less
than <code>min</code>. Returns <code>max</code> if <code>test</code>
is strictly less than <code>max</code>. Returns
<code>test</code> otherwise.
</li>
<li>
<code>u(x,y,z,v)</code> - Returns the value of dynamic variable in the layer
<code>v</code> at point <code>(x,y,z)</code> in the mesh. The values
of the arguments are cropped into the corresponding meaningful
intervals, e.g. [0,<code>vmax-1</code>] for <code>v</code> etc. 
If
non-integer values are given for <code>x</code>, <code>y</code> or
<code>z</code>, the value is linearly interpolated from surrounding
grid points. Non-integer values for <code>v</code> are rounded down. 
</li>
<li>
<code>geom(x,y,z,v)</code> is similar to <code>u()</code>, but provides
access to geometry data rather than computational grid data.
This function is defined only if a complex geometry is
used. Again,
non-integer values for <code>x</code>, <code>y</code> imply linear
interpolation. 
For <code>v=0</code>, the function returns 1.0 for a
tissue point and 0.0 for a void point. For <code>v=1,2,3</code>, the
function returns the values of the fiber direction coefficients; these
are only available if anisotropy option is used. 
</li>
<li>
<code>rnd(a, b)</code> - Returns a random real number greater than or
equal to <code>a</code> and strictly less than <code>b</code>,
uniformly distributed in between (sequential version only).
</li>
<li>
<code>gauss(a, b)</code> - Returns a random real number normally
distributed with mean <code>a</code> and standard
deviation <code>b</code>, Box-Muller 1958 transformation (sequential version only). 
</li>
</ul>

<p>
The last two functions are not thread-safe or would be too
communicationally expensive to implement in the parallel mode, so are
only allowed in the sequential mode.
</p>

<p>
The arithmetic operators distinguish between real and integer numbers,
so <code>5/2</code> produces 2 while <code>5.0/2.0</code> gives
2.5. The usual type casting rules apply, e.g. sum of a real and an
integer is a real, etc. All functions take real arguments and return
real values. Calling a function with a wrong number of arguments is an
error. The built-in "k-compiler" of arithmetic expressions is not
optimizing, and any intellectual work is expected to be done by the
user. E.g. calling function with an integer argument,
say <code>0</code>, will generate the conversion of the
integer <code>0</code> into the real <code>0.0</code> in the compiled
code; where as putting <code>0.0</code> as the argument will not
require that so will generate a slightly shorter and more efficient
"k-executable".
</p> 

<h2 class="numbered">Briefly about Device-Defining Commands</h2>

<p>
The simplified syntax of a device-defining command is 
<pre>
&lt;device&gt; [&lt;name&gt;=&lt;value&gt; [...]] ;
</pre>

<p>
The <code>&lt;name&gt;=&lt;value&gt;</code> pairs define the device
parameters and are separated from each other by spaces
(including <code>'\t'</code>, <code>'\b'</code>, <code>'\r'</code>
and <code>'\n'</code> characters). Each device has its own set of
parameters, whose names will be checked for in the body of the
command. The pairs
<code>&lt;name&gt;=&lt;value&gt;</code> with parameter names not
known to the given device, or something that is not
a <code>&lt;name&gt;=&lt;value&gt;</code> pair, are silently
ignored. If there is more than
one <code>&lt;name&gt;=&lt;value&gt;</code> pair with the same
name, only the first occurrence matters and the rest is/are
ignored. If no <code>&lt;name&gt;=&lt;value&gt;</code> pair
corresponding to a parameter is found, the
default value is assigned, or an error message is output and parsing
terminates if there is no default value for this parameter.
</p>

<p> 
The parameters could be arithmetic, string, or blocks.
</p>

<p> For the arithmetic parameters, which could be any valid arithmetic
C type, the <code>&lt;value&gt;</code> is taken as the string of
characters after the <code>=</code> sign until the first blank
character, is intepreted as an arithmetic expression, it is evaluated
to the appropriate k-type (integer or real), cast to the required C
type, and assigned to the parameter. A parameter in a device may have
  a default value and maximal and minimal allowed values. If a
  calculated value goes beyond the prescribed limits, and error
  message is printed and parsing is terminated. 
</p>

<p>
For the string parameters, the <code>value</code> (subject to
preprocessing) is intepreted as the literal value of the parameter.  A
string containing blank spaces or one of the special characters
<code>\n</code>, 
<code>\b</code>, 
<code>\f</code>, 
<code>\t</code>, 
<code>\r</code>, 
<code>\a</code>
and
<code>\0</code> 
can be used as a value by enclosing it in double
quotes <code>"..."</code>. Any other character within the double
quotes, preceded by the backslash <code>\</code> (including the double
quote and the backslash itself) evaluates to that character.
String parameters may have default values, but obviosuly not minimal
or maximal values. 
</p>

<p>
The block parameters expect the values in the form of text enclosed by
curly brackets, <code>{...}</code>. Such block text may span several
lines of the script and may contain contain its own set of
<code>&lt;name&gt;=&lt;value&gt;</code> pairs (what we shall call a
<code>codeblock</code>) or list of k-expressions
(<code>listblock</code>). There are no defaults for block parameters,
i.e. they are always compulsory.
</p>

<h2 class="numbered">Defining the Computational Grid with the state Command</h2>

<h3 class="numbered">General description</h3>

<p>
The first functional task of a script is to define the mesh. The
mesh is stored as a four-dimensional array, corresponding to a
three-dimensional, regular Cartesian mesh with an array of dynamic
variables at each point. Dynamic variables hold space-dependent
values, local to each point in the mesh. The majority of dynamic
variables are commonly employed to hold variables of the cell
model. The dimensions of the mesh and number of dynamic variables
(i.e. the size of the four-dimensional array) are set using
the <code>state</code> command. 
</p>

<p>
The syntax of the <code>state</code> command is the same as that of a
device-defining command, only it does not add any devices into the
device ring. 
</p>

<p> The required set of parameters depends on whether geometry file is
  used, which is determined by the string
  parameter <code>geometry</code>. If this parameter is assigned to a
  non-empty string, then it is understood to be the name of the
  geometry file. This case is described in more detail below. 
</p>

<p> If parameter <code>geometry</code> is absent or is assigned to an
empty string, no geometry file is read, the computations are done in a
parallelepiped, and its sizes <code>xmax</code>, <code>ymax</code>
(compulsory) and <code>zmax</code> (optional, default=1) will be
checked for. Parameter <code>vmax</code> is still required.
</p>

<p>
The integer coordinates (index) <code>x</code> runs from 0 through to
<code>xmax-1</code> (so the name <code>xmax</code> is a bit of a
misnomer, but stuck for historical reasons). 

If <code>zmax&ge;3</code>, the calculations will be three-dimensional
(3D). Otherwise, if <code>ymax&ge;3</code>, the calculations will be
two-dimensional (2D). Otherwise, if <code>xmax&ge;3</code>, the
calculations will be one-dimensional (1D). Otherwise, it is
zero-dimensional case (0D), that is, no spatial extent (ODE model). At
least three points in a particular direction are needed to make that
direction "extended", because in that case the marginal values of the
coordinates need to be kept free, for technical reasons related to
implementation of boundary conditions. The cases of
<code>xmax=2</code> etc are syntactically allowed but hardly ever used
in practice.
</p>

<p> In any case, parameter <code>vmax</code> is accepted. It is
  optional and defaults to 2 (a tribute to the FitzHugh-Nagumo
  model). It defines the number of dynamic variables per node of the
  computational grid, i.e. the number of computational layers. Note
  that this number may and ofter is larger that the number of
  equations in the model, as extra layers may be required as working
  arrays for computational purposes (details are in the description of the
  devices that use this feature). 
</p>

<p>
The mesh defined in the example below has 300
points along the x-axis and 400 points along the
y-axis. Since <code>zmax</code> is equal to 1, there is one point
along the z-axis, making the medium flat on the xy-plane. The
variable <code>vmax</code> specifies the number of dynamic variables
stored at every point in the mesh.
</p>

<table class="figure">
<caption>
Listing G.4: Defining a two-dimensional mesh with
the <code>state</code> command.
</caption>
<tr><td>
<pre>
state xmax=300 ymax=400 zmax=1 vmax=3;
</pre>
</td></tr>
</table>

<p>
Beatbox assumes that the simulation medium will follow a hierarchy of
axes; x before y before z, i.e. one-dimensional simulations must use
the x-axis and two-dimensional simulations must use the x and y axes.
</p>

<p>
Any Beatbox input script must contain exactly one <code>state</code>
command, and it should precede any device-defining commands. 
</p>

<h3 class="numbered">Tissue Geometry: simulating in non-rectangular domains</h3>

<p>
If you would like to use an anatomically realistic mesh for your
simulation, you can specify it in the <code>geometry</code> parameter of
the <code>state</code> command. For
example, <code>geometry=ffr.bbg</code> will select
the <code>ffr.bbg</code> geometry file. 
</p>

<p>
When using a geometry file, there is no need to specify the dimensions
of the mesh, in which case Beatbox will find them automatically by analysing the geometry
file. The set of points read from geometry files will be padded on all
sides by <code>padding</code> grid points, which is a parameter defaulting to 1. 
You do still
need to define <code>vmax</code>, however, to suit your chosen RHS
module and any other dynamic variables your simulation needs. Beatbox
will also complain if the fibre directions specified in your geometry
file are not unit vectors. If you like, Beatbox will normalise the
fibre directions for you, if you set the <code>normaliseVectors</code>
parameter to 1. If you would like to model anisotropy, set the
<code>ansiotropy</code> parameter to 1.
When the <code>anisotropy=1</code>, the
behaviour and required parameters of some devices may change. In
particular, the <code>diff</code> device, performing the diffusion
substep, will require two diffusion coefficients, <code>Dpar</code>
and <code>Dtrans</code> for the diffusivity along and across the
fibres, instead of the isotropic <code>D</code>.
</p>


<p>
<strong> Further details, for more advanced users:</strong>
Perhaps paradoxically, it is possible to specify both the grid sizes
<code>x0=...</code>, ... <code>z1=...</code> and the BBG file
<code>geometry=...</code>. In this case, the priority is given to the grid
sizes, and the points in the BBG file are expected to comply: any points in
BBG file that do not fit within the expected dimensions are simply discarded. This
makes sense for very big geometries if many runs with the same geometry are
required, since an extra round of reading the whole BBG file is needed to
determine the dimensions, and this can take a long time for a large BBG file.
It is also possible to use nontrivial geometry and/or anisotropy even
without a BBG file. This possibility is realized by specifying
<code>anisotropy=1</code> without a <code>geometry=...</code> parameter. In
this case, the grid sizes are mandatory, and the geometry can be defined by a
<code>k_func</code> device on the whole grid, assigning nonzero values to the <code>geom0</code>
local variable at all points that are intended to represent the tissue, zero
values for the voids, and assigning <code>geom1,geom2,geom3</code> the
corresponding fiber
direction cosines with the x,y and z axes respectively. A delicate detail here
is that these computations must be done <strong>BEFORE</strong> the geometry grid is used, and
it is used say by <code>diff</code> device <strong>at parse time</strong>. So
the k-function filling the geometry grid must be executed at parse time (and
earlier in the script than any device that may use this grid). To make it
possible, <code>k_func</code> device has a parameter <code>advance</code>. By
setting <code>when=never advance=1</code>, you would ensure that this
<code>k_func</code> device is executed at and only at parse time when the
initialization script reads the input file, which is precisely what is needed
for <code>diff</code> device and the like to work properly. Notice that it is
possible to modify the values in the geometry grid, but this will have no
effect on <code>diff</code>, <code>diffstep</code> and <code>elliptic</code>
devices as their templates are formed at parse time only (this  behaviour may
be reconsidered later). 
</p>


<h3 class="numbered">Geometry File Format</h3>

<p>
The Beatbox geometry file will typically have the extension <code>.bbg</code>
and is a plain text file, each line of which describes a point belonging to
the tissue.  Any such line will have four numbers or seven numbers: integers
for x, y and z coordinates of a node and its tissue type, and three reals for
the fibre orientation data. The de-facto limits of the x-, y- and z-components
of all points in the file will be used to define the circumscribed box. The
file does not have to describe every point in the box; the points that are not
mentioned will simply be assumed to belong to the void. A zero tissue type
designates the void, so such lines can be omitted without any loss of
information.  The three reals of the fibre orientation data for any nonzero
tissue type will be the directional cosines of the fibres. If no true fibre
data are available in the source of the geometry, and/or no anisotropy is used
in simulations, then any triple can be put as the fibre orientation data, say
1,0,0.
</p>

<p>
<strong> Further details, for more advanced users:</strong>
Normally, the directional cosines are silently expected to be
normalised so that the sum of their squares equals one. This will be
explicitly checked by stating <code>checkVectors=1</code> in the
<code>state</code> command.  Moreover, the <code>state</code> command may have
<code>normaliseVectors=1</code> specified in it in which case the directional
cosines will be normalised as the BBG file is read. If the vector of
directional cosines are very close to zero then instead of normalising them,
BeatBox will replace these cosines with a precise zero which is understood
that this particular point of the grid does not have a fiber direction and
must be treated as isotropic.
</p>

<h2 class="numbered">About the run-time graphics</h2>

<p>
The run-time graphics in Beatbox is at present implemented only in the
sequential mode.  It comes in two kinds.
<ul>
  <li>
  Some legacy devices make graphical
  outputs into a single window, common to all such devices, emulating the <a
  href="https://en.wikipedia.org/wiki/Video_Graphics_Array">VGA 640x380,
  16-colour interface</a> by means of the X11 protocol. In this manual, this method
  is referred to as "VGA graphics" for brevity. The standard window size may
  be changed by using a <code>screen</code> command which, as the
  <code>state</code> command, makese effect only at parse time and must
  precede any devices using VGA graphics. The parameters of the
  <code>screen</code> command are:
  <table border="1">
    <tr>
      <th> Type </th><th> Name </th><th> Default </th><th> Description </th>
    </tr><tr>
      <td><code>int</code></td>
      <td><code>XMAX</code></td>
      <td><code>639</code></td>
      <td> Width of the VGA window - 1, in pixels.</td>
    </tr><tr>
      <td><code>int</code></td>
      <td><code>YMAX</code></td>
      <td><code>479</code></td>
      <td> Height of the VGA window - 1, in pixels.</td>
    </tr><tr>
      <td><code>int</code></td>
      <td><code>WINX</code></td>
      <td><code>-1</code></td>
      <td> Horizontal location of the VGA screen. If non-negative,
      it is the distance of the left edge of the window from the left edge of
      the screen. The negative values designate the distance of the right edge
      of the window from the right end of the screen.</td>
    </tr><tr>
      <td><code>int</code></td>
      <td><code>WINY</code></td>
      <td><code>-1</code></td>
      <td> Vertical location of the VGA screen. If non-negative,
      it is the distance of the top edge of the window from the top edge of
      the screen. The negative values designate the distance of the bottom edge
      of the window from the bottom end of the screen.</td>
    </tr><tr>
      <td><code>int</code></td>
      <td><code>online</code></td>
      <td><code>0</code></td>
      <td> Normally, when this flag is 0, the VGA emulator will update the
	window only when the device
	<a href="#update"><code>update</code></a>
	described below	is called. 
	If set to 1, this flag causes the VGA emulator will update the
	window after every primitive. This will significantly slow down the
	graphics, but may be useful for debugging
	purposes purposes. </td>      
    </tr>
  </table>
</li>
  <li>
  More recent graphical
  devices make each their own X11 window as needed. These as rely on the
  <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a>
  extension to X11. In this manual, this method
  is referred to as "OpenGL graphics" for brevity.</li>
</ul>
</p>

<h2 class="numbered">More about Device-Definining Commands</h2>

<p>
Following the <code>state</code> declaration and possibly a
<code>screen</code> declaration, a script can add to the
ring of devices by invoking or ‘calling’ Beatbox devices. A device
call takes the form of the device name, followed by parameters as
key-value pairs, separated by spaces. The excerpt below shows
the <code>euler</code> device being called with some parameters.
</p>

<pre>
euler v1=[iext] ht=ht ode=lrd pars={IV=@24} name=Geoff;
</pre>

<p>
Each device call will add an instance of the device to the ring of
devices. It is possible to instantiate the same device,
e.g. <code>euler</code>, multiple times and the parameters of each
instance will remain independent. The different instances can be
distinguished from each other (say, in the debugging or profiling
listings) by the values of their optional <code>name</code> parameter,
"Geoff" in the above example. 
</p>

<h3 class="numbered">Assigning Device Parameters</h3>

<p>
Device parameters are assigned following the device name as key-value
pairs with the syntax <code>&lt;key&gt;=&lt;value&gt;</code>.  Since spaces separate
device parameters, an <code>str</code> parameter value that includes
spaces, should be enclosed in quotes (" ").  Expressions assigned
to <code>int</code>, <code>long</code> and <code>real</code>
parameters will be reduced to literal values when read. An example is
shown in Listing <a href="#G.5">G.5</a>.
</p>
<p>
Some devices may request parameters formatted as a codestring or a
block.
</p> 

<ul>
<li>
A codestring is provided in the same way as a string parameter, with
the exception that the string must be a valid Beatbox script
expression. The expression should compile to the variable type
specified in the device’s documentation. Codestrings allow devices to
evaluate an expression as the simulation is running, rather than
reduce it to a literal value.  
</li>
<li>
A block is a string enclosed in braces ({ }). The contents of a
block will be passed literally to the device, without intervention
from the script interpreter. This allows a block to contain characters
such as ';' or '&quot;' that could not be included in a string parameter. Some
devices, notably <code>k_func</code>, use a block to accept script
statements. For instance, <code>euler</code> uses a block to pass
parameters assignments to its RHS module.
</li>
</ul>

<p>
Example uses of a codestring and a block are shown below. 
</p>

<p>
Listing <a href="#G.5">G.5</a> shows the assignment of a parameter,
<code>bar</code> to an imaginary <code>foo</code> device. Although the value of
<code>hat</code> may change throughout the simulation, the value of
the <code>bar</code> parameter will be set only once, when the device
is called. In this case, <code>bar</code> will be assigned the value
40.
</p>

<table class="figure">
<caption>
Listing G.5: Assigning a device parameter.
</caption>
<tr><td>
<pre id="G.5">
def real hat 10.0;
foo bar = min(hat ,60)*4;
</pre>
</td></tr>
</table>

<p>
Listing <a href="#G.6">G.6</a> illustrate usage of block parameters
in real devices <code>k_func</code> and 
<code>euler</code>.
device. 
</p>

<table class="figure">
<caption>
Listing G.6: Assigning block parameters to the <code>k_func</code>
and <code>euler</code> devices.
</caption>
<tr><td>
<pre id="G.6">
k_func nowhere=1 pgm={
    stim = eq(t,stimTime);
};
def int neqn 24;
def str iext neqn;
euler v0=0 v1=neqn-1 ht=ht ode=crn par={ht=ht, IV=@[iext]};
</pre>
</td></tr>
</table>

<p>
In the <code>k_func</code>, the block parameter <code>pgm</code> is
assigned the string enclosed between the <code>{...}</code> brackets.
This will be compiled and result in a k-executable, which will be
stored among other internal parameters of this instance
of <code>k_func</code> device for future use. Then at each time step
(but only once per thread, as defined by the <code>nowhere=1</code>
parameter), this k-executable will be evaluated using the then
current, run-time values of k-variables <code>t</code>
and <code>stimTime</code>, and the result will be assigned to the
k-variable <code>stim</code>.
</p>

<p>
In <code>euler</code>, parameter <code>ode</code>, which is a string
defining the kinetic model used by the forward Euler timestepper, is
assigned <code>crn</code> which stands for the
Courtemanche-Ramirez-Nattel 1998 human atrial model.  It uses layers
from 0 through to <code>neqn-1</code>=23 so
k-variable <code>neqn</code> must be equal to the number of dynamic
variables in the model (24), at the parsing time, otherwise program
will stop with an error message. Parameter <code>ht</code>, which
designates the time step of the forward Euler scheme, will be assigned
to the current (parse-time) value of the k-variable <code>ht</code>.
Parameter <code>par</code> will be assigned the whole contents within
the <code>{...}</code>  brackets, and passed for further parse-time
processing by the ode-specific parser of the <code>euler</code>
device. On this occasion, the CRN model requires the time
step <code>ht</code> again, since it calculates new values of some of
the variables rather than calculating their time derivatives.  Note
that using a different value of <code>ht</code> parameter
in <code>euler</code> device and in its <code>crn</code> kinetic model
would be syntactically correct, but would probably not do what you
want. This kinetic model also uses parameter <code>IV</code> which
corresponds to inter-cellular current.  Its value is given
as <code>@[iext]</code>. In this example, string
macro <code>[iext]</code> expands to 24, the value of
 <code>IV</code> will be different for every point, and it will be the
value taken from the layer 24 at that point (more about the layer
 substitution below). 
</p>

<p>
So the difference between the parse-time and run-time execution of 
k-code within block parameters is not syntactical, but
device-specific. In other words, the only way to find out how it will
be interpreted is to look into the description of the particular device.
</p>

<h3 class="numbered">Generic Device Parameters</h3>

<p>
A set of generic parameters, listed below, is applicable to all device
types. All of the generic parameters listed below are optional - if no
value is given for them, a default will be provided by
Beatbox. Generic parameters and their defaults are described below.
</p>

<dl>

<dt style="font-weight:bold;"><code>(str) name</code></dt>
<dd>
<p>
Given name for the device. If the script specifies two instances of a
device, giving one of the devices a unique name will disambiguate the devices
in any output messages. Also, some devices refer to another device in
the simulation using its name parameter. The default
for <code>name</code> is the device name. 
</p>
</dd>

<dt style="font-weight:bold;"><code>(real) when</code></dt> 
<dd>
<p> 
The device's condition. The value given for <code>when</code> must be the name
of a real k-variable.  The device will be run only on timesteps (loops of the
device ring) when the value of this variable is nonzero.  Think of this
parameter as a codestring, where the code is restricted to just one real
variable; allowing here a generic k-expression would be more consistent but
also more expensive. In particular, a literal value (i.e. a numerical
constant) cannot be used for this parameter.  For devices that should run on
every timestep, Beatbox provides the predefined read-only variable
<code>always</code>, whose value is 1, and <code>when=always</code> is the
default.
</p>
</dd>
<dt style="font-weight:bold;">Space Parameters</dt>
<dd>
<p>
These specify the points of the mesh on which the device will operate:
</p>

<ul>
<li> <code>(int) nowhere</code>: if nonzero, the device is not
  associated with any part of the computational grid, and its
  execution does not involve any loops through <code>x,y,z</code>
  coordinates on the grid. The other space parameters have effect only
  if <code>nowhere=0</code>, which is the default.
</li>
<li>
<code>(int) x0</code> Lower <code>x</code> bound. 
Allowed values from 0 to <code>xmax-1</code>, 
defaults
to <code>1</code>.
</li>
<li>
<code>(int) x1</code> Upper <code>x</code> bound. 
Allowed values from <code>x0</code> to <code>xmax-1</code>, 
defaults
to <code>xmax-2</code>.
</li>
<li>
<code>(int) y0</code> Lower <code>y</code> bound.
Allowed values from 0 to <code>ymax-1</code>, 
defaults to <code>0</code> for one-dimensional calculations and
to <code>1</code> otherwise. 
</li>
<li>
<code>(int) y1</code> Upper <code>y</code> bound. 
Allowed values from <code>y0</code> to <code>ymax-1</code>, 
defaults
to <code>ymax-1</code> for one-dimensional calculations and to
<code>ymax-2</code> otherwise.
</li>

<li>
<code>(int) z0</code> Lower <code>z</code> bound. 
Allowed values from  to <code>zmax-1</code>, 
defaults to <code>1</code> for three-dimensional calculations and
to <code>0</code> otherwise. 
</li>
<li>
<code>(int) z1</code> Upper <code>z</code> bound.
Allowed values from <code>z0</code> to <code>zmax-1</code>, 
defaults
to <code>zmax-2</code> for three-dimensional calculations and
<code>zmax-1</code> otherwise.
</li>
<li>
<code>(int) v0</code> Lower <code>v</code> (layer number)
bound. 
Allowed values from 0 to <code>vmax-1</code>, 
defaults to <code>0</code>. 
</li>
<li>
<code>(int) v1</code> Upper <code>v</code> (layer number)
bound. 
Allowed values from 0 to <code>vmax-1</code>, 
defaults to <code>v0</code>. 
</li>
</ul>

<p>
In general, a device will operate on points from, e.g. <code>x0 &le; x
&le; x1</code>. In some devices, the <code>v0,v1</code> parameters do
not define a range of <code>v</code> coordinate, but identify separate
layers each having its own function.  For example,
Beatbox’s <code>diff*</code> devices use <code>v0</code> to indicate
the dynamic variable containing transmembrane potential or another
diffusing field, and <code>v1</code> to indicate where the Laplacian
of that field should be stored. For devices that have no effect on the
computational grid, the <code>nowhere</code> parameter should be set to
1 to indicate this. The operation of some devices, in particular
<code>k_func</code> is strongly affected by the <code>nowhere</code>
parameter.
</p>
</dd>

<dt style="font-weight:bold;">Window Parameters</dt>
<dd>
<p> 
These specify the placement and colouring of
the area associated with the device within the VGA graphical screen when
run-time VGA graphics is on. 
</p>
<ul>
<li><code>int row0</code>  Lower row.</li>
<li><code>int row1</code>  Upper row.</li>
<li><code>int col0</code>  Left column.</li>
<li><code>int col1</code>  Right column.</li>
<li><code>int color</code>  Colour.</li>
</ul>
For historical reasons these parameters are defined for all devices, but used
in fact only by VGA graphical devices. The row/column coordinates are
zero-based, in pixels, with the window size 640x480 unless defined otherwise
by the <code>screen</code> command. The <code>color</code> is an 8-bit integer
encoding the "backround" or "border" VGA colour (senior 4 bits) and the "foreround" VGA
colour (junior 4 bits); the exact interpretation of those is device-dependent. 
</dd>
</dl>

<h3 class="numbered">The k_func Device</h3>

<p>
All the standard devices (with the exception of ad-hoc, experimental
ones) are described in detail in
the <a href="#Beatbox_Device_Reference">Beatbox Device Reference</a>
below. However the <code>k_func</code> device is so important for
understanding of the Beatbox control flow that it warrants consideration
immediately. This device takes a codeblock parameter
<code>pgm</code> which is expected to be a "k-program", that is a set
of one or more "k-assignments", separated by semicolons. A
k-assignment is a string of the form:
</p>

<pre>&lt;k-variable&gt;=&lt;k-expression&gt;</pre>

<p>
The expressions are compiled at parse-time, but evaluated and assigned
at run-time using the then current values of k-variables.
</p>
<p>
The functioning of the <code>k_func</code> device somewhat differs
depending on the value of its <code>nowhere</code> parameter.
If <code>nowhere</code> is nonzero, then the "k-program" is executed
exactly once per per time step, and it can only use the usual "global"
k-variables both in the right-hand sides and in the left-hand sides of
the assignments. If, however, <code>nowhere=0</code> and the device
has space, then at every time step the k-program is executed at every
point of the space. In this case, the k-programs may use the device's
"local" real variables:
<ul>
<li>
<code>x,y,z</code> are numerically equal to the corresponding
integer (grid) coordinates of the point at which the k-program is executed;
</li>
<li>
<code>u0, u1, ... u&lt;vmax-1&gt; </code> - variables containing the
corresponding values of the computational grid at the point at which
the k-program is executed.
</li>

<li>
<code>geom0</code> - this is defined only when realistic geometry is used, and
has value of 1 if the the point at which
the k-program is executed belongs to the tissue. 
</li>

<li>
<code>geom1, geom2, geom3</code> - this is defined only when realistic
geometry is used and the anisotropy option is on, contains the values of the
components of the fibre direction vector at the point at which the k-program
is executed.
</li>

<li>
<code>phasep, phaseu, p0, p1, ... p&lt;vmax-1&gt; </code> - variables
used for the phase-distribution method (see the next section). 
</li>
<li>
<code>np, nv</code> - if <code>file</code> parameter is set, these
will be the the number of lines and the number of columns in the table
read from the <code>file</code>. 
</li>
</ul>

<p>
In addition, you can define extra local k-variables within the body of the
<code>pgm={...}</code> codeblock, in the same syntax as the global k-variables
outside.
</p>

<p>
All the local k-variables can be used in the left-hand sides as well as the
right-hand sides. The resulting values of <code>u0, u1, ... </code> as well as
<code>geom0, geom1, ...</code> variables are stored back into the
computational grid and geometry grid respectively. The resulting values of all
other local variables will be lost after the device instance finishes its work
at the given time step. In this mode, <code>k_func</code> can be used to fill
the computational grid with values according to given formulas or other
algorithms.
</p>

<p>
A common and very important application of <code>k_func</code> device
in the <code>nowhere</code> mode is in updating variables used for
devices’ <code>when</code> parameters.  For example, to run another
device at timestep&nbsp;200 only, the <code>k_func</code> device
called below will assign the value 1.0 to <code>stim</code> when the
current timestep, <code>t</code> equals <code>stimTime</code>, and the
value of 0.0 otherwise:
</p>

<pre>
def real stimTime 200;
k_func nowhere=1 pgm={
  stim = eq(t,stimTime);
};
</pre>

<p>
The following device call adds a line to the <code>pgm</code>
parameter to set k-variable <code>print</code> to 1.0 on timesteps 0,
50, 100, ...
and to 0.0 otherwise:
</p>

<pre>
def real stimTime 200;
def real printInterval 50;
k_func nowhere=1 pgm={
  stim = eq(t,stimTime);
  print = ifeq0(mod(t,printInterval));
};
</pre>

<p>


The example
below illustrates use of <code>k_func</code> with a space
(<code>nowhere=0</code> mode). It models stimulation of the excitable
medium by raising the transmebrane voltage (allocated in the layer
whose number is encoded by string macro <code>[V]</code>), in the left
half of the box. The value of the stimulus linearly depends on the
<code>y</code> coordinate and varies linearly between 0 at
<code>y=0</code> and and 1.5 at <code>y=ymax-1</code>: 
</p>

<pre>
def str V 0;
k_func when=stim x0=1 x1=(xmax-1.0)/2 pgm={
  u[V] = u[V] + 1.5*y/(ymax-1);
};
</pre>

<h3 class="numbered">Phase Distribution</h3>

<p>
Device <code>k_func</code> implements a method that is very specific
for cardiac, and generically excitable media simulations. This is a
"phase distribution" method, particularly suitable for creating
initial conditions. The method was described e.g. in
<cite>
V.N. Biktashev et al., Phil. Trans. Roy. Soc. London, ser A 347: 611-630, 1994.
</cite>
The idea of the method is that the user a
scalar field, the phase, defined up to an integer multiple of 2&pi;,
and Beatbox then automatically fills the space of the
<code>k_func</code> device with corresponding values of the dynamic
variables, where what values of dynamic variables correspond to what
values of the phase is defined by a "profile", provided in an input
file. For this purpose, <code>k_func</code> takes parameter
<code>file</code>, which will be the name of a text file, containing
space-separated columns of real numbers. Each column corresponds to
values of one dynamic variable, and the number of rows represents the
whole circle [0,2&pi;) of the phase.
</p>

<table class="figure"> 
 <caption>
    Figure 2: Conceptual arrangement of file for use with phase distribution.
  </caption>
<tr><td>
  <img
    src="imgs/G1.png"
    width="300" height="261"
    alt="Conceputal arrangement of file for use with phase distribution."
    style="margin:auto;display:block;"
    id="fig-2"
  />
</td></tr>
</table>

<p>
For example, the following data file
contains a 2&times;10 table of values:
</p>

<table class="figure">
<caption>Listing G.7: Sample <code>k_func</code> profile file.</caption>
<tr><td>
<pre>
2.378  5.111
5.768  8.860
5.609  7.777
1.493  6.545
5.609  7.777
1.347  7.346
4.256  7.423
4.167  6.245
1.234  7.987
3.245  5.222
</pre>
</td></tr>
</table>

<p>
Conceptually, the values are arranged in a circle, as shown in
<a href="#fig-2">Figure 2</a>.
</p>

<hr/>

<table class="figure">
<caption>Figure 3: <code>k_func</code>
interpolation. The value of <code>phaseu</code> is interpolated
between <code>ip</code> and <code>ip1</code> using <code>p</code>
and <code>q</code>.
</caption>
<tr><td>
  <img
    src="imgs/G2.png"
    width="300" height="75"
      alt="k_func interpolation"
    style="margin:auto;display:block;"
    id="fig-3"/>
</td></tr>
</table>

<p>
If parameter <code>file</code> is given and correponds to a valid
profile, phase distribution is initiated by assigning a value to local
variable <code>phaseu</code> in the <code>k_func</code> program. The
value assigned to <code>phaseu</code>, taken to be in radians,
indicates a point on the circle, and consequently the line of the
input file to be read. Since <code>phaseu</code> is a real number,
linear interpolation is used to calculate values from two neighbouring
rows of array, as illustrated in <a href="#fig-3">Figure 3</a>. The
calculated value is then assigned to the corresponding layer
of <code>u</code>: the values interpolated from the first column of
the profile to
<code>u0</code>, from the second to <code>u1</code> etc until
the last column available on the profile. Note that if the number of
<code>u*</code> is more than the number of layers allocated to this
<code>k_func</code> instance by its <code>vmin,vmax</code> parameters,
then the trailing values will be lost. 
</p>

<p>
An alternative version of the phase distribution method is with
assignment to <code>phasep</code> local variable instead of
<code>phaseu</code>. In this case, instead of calculating the values
of <code>u0, u1, ...</code> local variables, the same algorithm is
used to calculate the values of local variables <code>p0, p1,
...</code>. Those local variables can then be used later in the same
k-program to calculate the <code>u0,u1,...</code> variables. Such
indirect assignment may be required if the columns in the profile go
in a wrong order etc.
</p>

<h3 class="numbered">Enumerated output files</h3>

<p>
Some output devices generate multiple output files, or read multiple
input files, which are
automatically ``enumerated'', in the sence that their names are not
fixed device parameters, but are generated at run time, and the
variable part of the file name is a number. There are two
different methods of such name generation. In one method, the number
is given by a k-expression, which is evaluated when it is time to open
the file. In the other method, the files are enumerated
sequentially. In both methods, instead of a fixed file name, the
script is expected to define a file mask which contains a C format
string, such as <code>file%04d.ext</code>. 
</p>

<p>
Enumeration by a k-expression is typically used when the output file
name is in fact a part of a <code>filter</code> parameter, which is a
character string containing a <code>bash</code>
command or pipeline, which takes the output of the device at its
standard input, such as
<pre>
filter="pnmtopng > image%04.0f.png"
</pre>
In such cases, the <code>filter</code> parameter is accompanied by a
corresponding <code>filtercode</code> parameter which is  a character
string containing the k-expression which is executed to generate the
value to fill the place allocated for the number part of the output
file. For the sake of genericity, the k-expression is interpreted as
real, hence the C format should be accepting real values, i.e. 
<code>%f</code> (as in the above example) or <code>%g</code>. This
method is used e.g. by devices
<a href="#ezpaint"><code>ezpaint</code></a>,
<!-- <code>ezpaint3d</code>, -->
<a href="#imgout"><code>imgout</code></a>,
<!-- <code>k_image</code>, -->
<a href="#k_imgout"><code>k_imgout</code></a>
and
<a href="#k_paintgl"><code>k_paintgl</code></a>.
</p> 

<p> Sequential enumeration, on the other hand, always operates with
integer enumerators, hence the format string should be one accepting
integer values, e.g. <code>%d</code>. In the device descriptions in
this manual, the parameters defining the file masks used with this
method, are designated as type
<a name="sequence"><code>sequence</code></a>. Such
<code>sequence</code> parameters by themselves are character strings, but they
are implicitly accompanied by the
following parameters optional with fixed names:
<ul>  
  <li><code>postproc</code>: a character string coding the command
  that can do something useful with the output file, e.g. gzip it. It
  defaults to an empty string, meaning no postprocessing is to be
  done. If given, the string must contain <code>%s</code> in the place
  where the file name to be processed is to be substituted.</li>
  
  <li><code>autonumber</code> is an integer flag (0/1), defaults to
  1. If 1, then at start time the device checks for existing files
  fitting the given description and skips them. </li>

  <li><code>startfrom</code> is an integer, the number from each
  enumeration starts. Defaults to 0. </li>

  <li><code>ignoreempty</code> is an integer flag (0/1), defaults to
  0. If 1 and if <code>autonumber</code> flag is also on, then any
  zero-length files found during the check are ignored (not considered
  as "existing").</li>
</ul>
This method is used e.g. by devices
<!-- <code>byteout</code>, -->
<a href="#ppmin"><code>ppmin</code></a>,
<a href="#ppmout"><code>ppmout</code></a>,
<a href="#record"><code>record</code></a>,
<code>screen_dump</code>
and
<code>vtkout2</code>
(the last two are not yet documented). 
</p>

<h2 class="numbered">Putting it all together: a simple example</h2>

<p>
</p>

<p> We now consider a simple working example of a Beatbox script, <a
 href="#minimal.bbs">minimal.bbs</a>.  It corresponds to <a
 href="#fig-2">Figure 1</a> above, and solves a standard
initial/boundary-value problem for the FitzHugh-Nagumo model,
as defined in <cite>A.T.Winfree, Chaos
1:305,1991</cite>: </p>

<p class="math">
 &part;<i>u</i>/&part;<i>t</i>
  &nbsp;=&nbsp;
  &epsilon;<sup>-1</sup>(<i>u</i>-<i>u</i><sup>3</sup>/3-<i>v</i>)
  &nbsp;+&nbsp;
  <i>D</i>&nabla;<sup>2</sup><i>u</i>,
  &emsp;
  &part;<i>v</i>/&part;<i>t</i>
  &nbsp;=&nbsp;&epsilon;(<i>u</i>+&beta;-&gamma;<i>v</i>), 
  &emsp;
 (<i>x</i>,<i>y</i>) &nbsp;&isin;&nbsp;&Omega;
  &nbsp;=&nbsp;[0,<i>L<sub>x</sub></i>]&times;
   [0,<i>L<sub>y</sub></i>] ;
<br />
  &part;<i>u</i>/&part;<b>n</b>&nbsp;=&nbsp; 0,
  &emsp;
 (<i>x</i>,<i>y</i>) &nbsp;&isin;&nbsp;&part;&Omega; ;
<br />
  <i>u</i>(<i>x</i>,<i>y</i>,0)={-1.7, &nbsp; <i>x</i>&le;<i>L<sub>x</sub></i>/2; &emsp;  1.7, &nbsp;
 otherwise},
<br />
  <i>v</i>(<i>x</i>,<i>y</i>,0)={-0.7, &nbsp; <i>y</i>&le;<i>L<sub>y</sub></i>/2; &emsp;  0.7, &nbsp;
 otherwise}.
<br/>
</p>


<p>
It may be executed, say, in the sequential mode by using the
following command:
</p>
<pre>
Beatbox_SEQ minimal.bbs
</pre>


<table class="figure" id="minimal.bbs"> 
<caption>
  File <code>minimal.bbs</code>.
</caption>
<tr><td>
<pre>
state xmax=102 ymax=102 vmax=3;

/* device control variables */
def real begin;
def real output;
def real end;	

/* Schedule */
k_func name=schedule nowhere=1 pgm={
  begin =eq(t,0);
  output=eq(mod(t,100),0);
  end   =ge(t,2000);
};

/* Initial conditions */
k_func name=ic when=begin
  x0=1 x1=100 y0=1 y1=100 pgm={
  u0=-1.7+3.4*gt(x,50);
  u1=-0.7+1.4*gt(y,50);
};

/* Diffusion substep */
diff v0=0 v1=2 D=1.0 hx=0.5;

/* Reaction substep */
euler v0=0 v1=1 ht=0.03
  ode=fhncub par={
  eps=0.2
  bet=0.8
  gam=0.5
  Iu=@2
};

/* Output image files */
ppmout when=output
  file=%04d.ppm
  r=0 r0=-1.7 r1=1.7
  g=1 g0=-0.7 g1=0.7
  b=2 b0=0.0  b1=1.0;

stop when=end;

end;
</pre>
</td></tr>
</table>

<p> The expected results of the run are described <a
 href="#skip-minimal">below</a>, and for now we consider the script
itself, which is shown on the right.  </p>

<p> The script starts with a <code>space</code> command, which defines
the 2D
computational grid of 100&times;100 internal nodes (<code>zmax</code>
defaults to 1),  and three layers,
they will have numbers 0,1,2. Layers 0 and 1 will be used for
variables <i>u</i> and <i>v</i>, and layer 2 will keep the values of
the diffusion term <i>D</i>&nabla;<sup>2</sup><i>u</i>. </p>

<p> The "device control variables" <code>begin,output,end</code> are
required to define which devices work when. They are defined by the
three <code>def</code> commands, their values are updated by the
first <code>k_func</code> device and used as values of
the <code>when</code> parameters of other devices. </p>

<p> The first <code>k_func</code> device does not have a
<code>when</code> parameter, so its value defaults to
<code>always</code> and it is executed at each step. It has
<code>nowhere=1</code> so its k-program is not iterated over any grid
points, but only executed once. The k-program assigns value 1 to
k-variables <code>begin</code> at the very first loop of the
device ring, when the loop counter <code>t</code> is zero, otherwise
<code>begin</code> is assigned zero. Variable
<code>output</code> will be 1 at every 100th step, and 0
otherwise. And variable <code>end</code> will be zero until the step
2000, and from then on it will be assigned 1. 
</p>

<p>
The second <code>k_func</code> device calculates the initial
conditions in accordance with the formula above. It only works during
the very first loop (<code>when=begin</code>), and iterates over all
internal points, as specified by <code>x0,x1,y0,y1</code>.  Its
k-program assigns the values to the <code>u0</code> local k-variable
(which means layer 0 value, i.e. <i>u</i> variable of the model)
and <code>u1</code> local variable (layer 1, <i>v</i> variable),
according to the formulas for the initial conditions above. The
k-expressions depend on local k-variables <code>x,y</code> each of
which runs from 1 through to 100, and the ranges 1..50 and 51..100
represent two halves of the computational box.
</p>

<p>
Notice that the two <code>k_func</code> devices use the optional
<code>name</code> parameter. This is used to tell them from each other
in the output. 
</p>

<p>
The <code>diff</code> device calculates the diffusion term using
values in layer zero (<code>v0=0</code>) and puts the results into
layer two (<code>v1=2</code>). It uses the diffusion coefficient value
of 1.0, and <code>hx=0.5</code> is the spatial discretization
step. The device applies every step (no <code>when</code> parameter),
at all the inner points of the grid (no space parameters, so the
defaults are used).
</p>

<p> The <code>euler</code> device makes the forward Euler timestep.
It also applies at every step and at all the inner points of the
grid. This device uses layers 0 and 1, as <code>v0=0</code>,
<code>v1=1</code>. It uses time discretization step
<code>ht=0.03</code>, and the right-hand sides of the FitzHugh-Nagumo
model are selected by <code>ode=fhncub</code>. The parameters of the
model are defined by the name-value pairs within the codeblock parameter
<code>pgm</code>, namely &epsilon;=0.2, &beta;=0.8, &gamma;=0.5. The
parameter <code>Iu</code> stands for the extra term in the right-hand
side for the <i>u</i> variable, which is defined here, through the
layer substitution call <code>@2</code>, as the value of
layer 2 at the same point, i.e. the value of the diffusion term as
computed by the previous <code>diff</code> device.
</p>

<p> The <code>ppmout</code> device make the results of calculations
usable. Every time it is active, i.e. at every 100th time
step, it outputs a file in
the <a
 href="http://en.wikipedia.org/wiki/Netpbm_format"><code>ppm</code></a>
format. The space for this device is not specified so it defaults to
all inner points.
</p>

<p>
The discretization of the floating point data from the computational
grid to the one-byte unsigned integers in the PPM file is defined by
the following parameters. Integer <code>r=0</code> says that the
red-component will be made from the values in layer 0, i.e. values of
the <i>u</i> variable.  Its values below <code>r0=-1.7</code> will be
mapped to "0" bytes (zero intensity of the red component), the values
above <code>r1=1.7</code> will be mapped to the maximal "255" bytes
(maximal intensity of the red component), with a linear interpolation
of values in between. Similarly, the (g)reen component is made out of
<i>v</i> values in layer 1, and the (b)lue component out of values of
the diffusion term in layer 2. Thus the head of the excitation wave is
red, its back is yellow and the refractory tail is green.  The blue
component, represents the Laplacian but shows only the positive part
of it (as <code>b0=0.0</code>). This shows as a dark blue
stripe ahead of the front of the excitation wave, and a cyan stripe
around its back (the images can be seen 
<a href="#minimal-figures">below</a>).  
</p>

<p> The names of the output files are encoded by the string parameter
<code>file</code>.
The value of this parameter is treated as a file mask, where resulting
file names will have the form of the four
digits representing the file's ordinal number, followed by
<code>.ppm</code>, so the filenames will be
<code>0000.ppm</code>,
<code>0001.ppm</code>,
...,
<code>0020.ppm</code>.
</p>

<p> The last device is <code>stop</code>, which does what it says on
the tin.  Its only one parameter <code>when=end</code> means,
according to the assignment for k-variable <code>end</code> above,
that this device would work at every timestep, starting from 2000 and
above. But it only works once as after that Beatbox terminates.  </p>

<p>
The script is terminated by the <code>end</code> command, which is
purely syntactical, to signal that the script file is complete and the
rest of it, if any, should be ignored.  
</p>


<p id="skip-minimal">
A sequential run of this script may produce standard output like this:
</p>

<pre>
525 $ Beatbox_SEQ minimal.bbs
Beatbox v1.0
------------------------------------------------------------------------------------
Sequential version compiled Aug 31 2012 19:10:55 $
Execution begin at Tue Sep 25 18:24:11 2012 $
Input file minimal.bbs without additional arguments $
with options: noappend nodebug noverbose graph noprofile logname=minimal.log
state   /* grid 102 x 102 x 1 x 3 */ $
k_func $
k_func $
diff $
euler $
ppmout $
stop $
end $
Ring of 6 devices created: (0)schedule (1)ic (2)diff (3)euler (4)ppmout (5)stop $
STOP AT 2000[0]                                                                

BEATBOX_0.1 finished at t=2000 by device 5 "stop"
Tue Sep 25 18:24:14 2012
======================================================
526 $ 
</pre>
<p>
and the file <code>minimal.log</code> with a bit more detail, such as
values of the device parameters read, and k-variables assigned. First the standard output and
the log file show the commands being read in; so if an error happens
at parse time, it is clear which device has caused it. Then the whole
device ring is described again, now giving devices' ordinal numbers in
the ring, and using
their proper names where given. After that there would be output from
devices produced during their work, or debug information if it was
specified, but in this example the only message is from the
<code>stop</code> device.  The final message is a signal of normal
termination: stopping by any other device would probably happen due to
a fatal run-time error.  Wall-clock times are printed before and after
the execution, so we see that this run took about 3 second. 
</p>

<p>
If <code>ppm</code> format is not convenient, the output files can be
converted to another using e.g. an appropriate <code>netpbm</code>
utility, say (in <code>bash</code>):
</p>
<pre>
 for (( i=0 ; $i&lt;=20 ; i=$i+1 )); do n=`printf %04d $i`; pnmtopng $n.ppm > $n.png; done
</pre>
<p id="minimal-figures">
Here are the resulting figures:
</p>
<table> 
  <tr>
  <td><img src="imgs/0000.png" alt="figure 0000"/></td>
  <td><img src="imgs/0001.png" alt="figure 0001"/></td>
  <td><img src="imgs/0002.png" alt="figure 0002"/></td>
  <td><img src="imgs/0003.png" alt="figure 0003"/></td>
  <td><img src="imgs/0004.png" alt="figure 0004"/></td>
  <td><img src="imgs/0005.png" alt="figure 0005"/></td>
  <td><img src="imgs/0006.png" alt="figure 0006"/></td>
  </tr>
  <tr>
  <td><img src="imgs/0007.png" alt="figure 0007"/></td>
  <td><img src="imgs/0008.png" alt="figure 0008"/></td>
  <td><img src="imgs/0009.png" alt="figure 0009"/></td>
  <td><img src="imgs/0010.png" alt="figure 0010"/></td>
  <td><img src="imgs/0011.png" alt="figure 0011"/></td>
  <td><img src="imgs/0012.png" alt="figure 0012"/></td>
  <td><img src="imgs/0013.png" alt="figure 0013"/></td>
  </tr>
  <tr>
  <td><img src="imgs/0014.png" alt="figure 0014"/></td>
  <td><img src="imgs/0015.png" alt="figure 0015"/></td>
  <td><img src="imgs/0016.png" alt="figure 0016"/></td>
  <td><img src="imgs/0017.png" alt="figure 0017"/></td>
  <td><img src="imgs/0018.png" alt="figure 0018"/></td>
  <td><img src="imgs/0019.png" alt="figure 0019"/></td>
  <td><img src="imgs/0020.png" alt="figure 0020"/></td>
  </tr>
  </table>
<!-- =============================================================== -->

<p>
The example we have considered is "minimal" and this sort of task is
routinely done by any cardiac simulation packages. However, Beatbox's
flexibility allows you to do much more than that. To discover
Beatbox's capabilities, do look at further sample scripts provided.
</p>

<h1 class="numbered">Specifics of the parallel execution</h1>

  <p>
BeatBox uses a straightforward MPI parallelization whereby the computational
  mesh is divided into subdomains lines or surfaces parallel to the
  coordinate x,y,z axes, and computations related to each subdomain are
  performed by a dedicated thread. Any information exchange necessary to coordinate the
  work of the threads is performed by message passing. This includes
  information pertaning to global variables, as well as the information about
  nearby points which is required by some devices, e.g. <code>diff</code>
  device used in the simple example above. Hence to allow access to such
  devices, the points in every subdomain that are next to the split
  are considered "halo" points and included in exchange buffers served by
  message passing.
   Currently the notion of "nearby"
  points is restricted to points with the difference by no more than one grid
  point in every coordinate, x, y and z. Hence the depth of the exchange
  buffers (==thickness of the halos) is restricted to 1 grid point. Details of
  related algorithms can be found in
  <a href="https://livrepository.liverpool.ac.uk/3173">
  R. McFarlane, "High-Performance Computing for Computational Biology of the
  Heart", Ph.D. thesis, University of Liverpool, 2011</a>
  and
  <a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0172292">
  M. Antonioletti et al., "BeatBox—HPC simulation environment for
  biophysically and anatomically realistic cardiac electrophysiology",
  PLoS ONE 12(5): e0172292, 2017</a>
  </p>

  <p>
  Some of the devices cannot or have not yet been parallelized, and are only
  available in the sequential version of BeatBox. 
  </p>

<h1 class="numbered">Some more advanced scripts</h1>

<p>
Here we describe a few sample scripts that illustrate some typical
uses of BeatBox and can be used as templates for your specific
tasks. These scripts are located under:
</p>
<ul>
<li><code><a href="../data/scripts/sequential/">data/scripts/sequential</a></code>
for scripts illustrating the fundamentals, which can or should be run
in sequential mode, and
</li>
<li>
<code><a href="../data/scripts/parallel_Hector">data/scripts/parallel_Hector</a></code>
for more specialized script illustrating parallel work.
</li>
</ul>

<p>
These scripts are designed to introduce BeatBox devices in an
informal, "how-to" way; a more formal description of devices is given
later in the <a href="#Beatbox_Device_Reference">Beatbox Device Reference</a>.
</p>


<!-- ===================================== -->
<!-- ===================================== -->
<h2 class="numbered">Sequential</h2>

<!-- ===================================== -->
<h3 class="numbered">fhn0.bbs</h3>
<p>
This script generates action potentials using single cell with
FitzHugh-Nagumo kinetics. See the script below:
</p>
<ul>
<li>
<a href="../data/scripts/sequential/FitzHughNagumo_model/fhn0.bbs">fhn0.bbs</a>
</li>
</ul>

<p>
The APs are initiated repeatedly: a stimulating pulse is issued every
time that the two dynamic variables satisfy certain inequalities,
meaning the system comes back close enough to the resting state. The
solution corresponding to the n-th action potential, <code>n=4</code>,
is output to the file (you need to run the code for this file to be
present):
</p>
<ul>
<li>
<a href="../data/scripts/sequential/FitzHughNagumo_model/fhn0.rec">fhn0.rec</a>
</li>
</ul>
<p>
This file is used in the next example. This example illustrates the
use of:
</p>
  
<ul>
  <li> <code>k_func</code> as a feedback control device: stimulating
  shock is defined as a function of current cell state;</li>
  <li> <code>sample</code> device to convert grid value into a
global k-variable, which is required for the <code>k_func</code>;
  <li> <code>screen</code> command and <code>k_draw</code> device for
run-time VGA graphics output: draw phase trajectory of the system as the
  solution progresses;</li>
  <li> <code>record</code> output device to write contents of the grid
  (in this case, just single cell) to a file.</li>
<li> <code>clock</code> output device that shows integer simulation
  time counter.</li>
</ul>
<p>
Inputs to this script:
<ul>
<li>none
</ul>
Output of this script:
<ul>
<li>The output of this script are run time VGA graphics if using it, and a record file called <code>fhn0.rec</code>.</li>
</ul>
<p>
To run this script with run-time graphics, call it using:
</p>
<pre>
Beatbox_SEQ fhn0.bbs
</pre>
<p>
and without graphics, use:
</p>
<pre>
Beatbox_SEQ fhn0.bbs -nograph
</pre>
<p> The same applies to all examples with run-time VGA graphics.</p>

<!-- ===================================== -->
<h3 class="numbered">fhn1.bbs</h3>

<p>
This script simulates propagation of excitation pulses in a
one-dimensional cable with FitzHugh-Nagumo kinetics. See:
</p>
<ul>
<li>
<a href="../data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs">fhn1.bbs</a>
</li>
</ul>

<p>
The pulses are initiated by non-stationary non-homogeneous Dirichlet
conditions on the left boundary, where u-variable is made
time-dependent according to the record in the <code>fhn0.rec</code>
(the file obtained in the previous example). The input is included in
the fhn1.bbs script code and need not be given at command line. It
outputs a point record during n-th front, <code>n=5</code>, into
file: <code>fhn1.rec</code>.  This record file will be used in the
next example. This example illustrates use of
</p>
<ul>
  <li> angle brackets <code>&langle;...&rangle;</code> to include
contents of another file;</li>
  <li> backticks <code>`...`</code> to capture output of a child process
(here just counting the number of lines in the given file); </li>
  <li> <code>poincare</code> and <code>k_poincare</code> devices to
detect arrivals of wavefronts at selected points, which is then used
both to control execution and to calculate the propagation speed;</li>
  <li> <code>k_plot</code> run-time VGA graphics device: to plot spatial
  profiles of the dynamic fields at selected moments of time.</li>
  <li> <code>pause</code> device for suspending execution and keeping
  the last picture on the screen until the user presses enter in the
  terminal window.</li>
</ul>
<p>
Inputs to this script:
<ul>
<li><code>fhn0.rec</code> obtained by running <code>fhn0.bbs</code>.</li>
</ul>
Output of this script:
<ul>
<li>The output of this script are run time VGA graphics if using it,
and a record file called <code>fhn1.rec</code>.</li>
</ul>
<p>
To run this script with run-time VGA graphics, call it using:
</p>

<pre>
Beatbox_SEQ fhn1.bbs
</pre>

<p>
and without graphics, 
</p>

<pre>
Beatbox_SEQ fhn1.bbs -nograph
</pre>

<!-- ===================================== -->
<h3 class="numbered">fhn2.bbs</h3>

<p> This script simulates a spiral wave in a two-dimensional square sheet with
FitzHugh-Nagumo kinetics, and periodically outputs the
solution. See:
</p>
<ul>
<li>
<a href="../data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs">fhn2.bbs</a>
</li>
</ul>

<p>
Essentially, this is a variant of the <code>minimal.bbs</code> script
discussed above. Some new things that this script illustrates:
</p>

<ul>
  <!-- <li> use of angular brackets &langle;...&rangle; to include contents -->
  <!-- of another file;</li> -->
  <li> more extensive use of k-variables to save typing and ease
  modification;</li>
  <li> use of <code>k_func</code> as a computational device for
  creating intial conditions by phase distribution method, using data
  from file <code>fhn1.rec</code> obtained by the previous fhn1.bbs;
  <li> use of computational devices <code>d_dt</code> and
  <code>grad2d</code> to compute time derivative and absolute value of
  spatial gradient of a field;</li>
  <li> use of run-time VGA graphics device <code>k_paint</code> to
  crudely visualize distribution of dynamic fields in the plane using
  16-colour VGA palette;</li>
  <li> use of <code>singz</code> device which detects spiral wave tips
  and is both computational and output;</li>
  <li> use of <code>shell</code> output device to call arbitrary OS
  command from BeatBox (here to create an output directory for the
  image files);</li>
  <li> use of <code>imgout</code> and <code>k_imgout</code> output
  devices to output image files; </li>
  <li> use <code>pause</code> device for suspending execution and keeping
  the last picture on the screen for a fixed time interval. 
  <li> use of the <code>d_dt</code> device for computing numerical derivative
  of a chosen variable.
</ul>

<p> Note that this script will create file <code>fhn2.trj</code>
containing the records of the detected spiral tips, and directory
<code>fhn2.dir</code> which will contain several <code>png</code>
image files created by <code>imgout</code> and <code>k_imgout</code>
devices. 
</p>

<p>
Inputs to this script are:
</p>
<ul>
<li><code>fhn1.rec</code> (file obtained by
running <code>fhn1.bbs</code>)</li>
</ul>

<p>
Outputs from this script are:
</p>

<ul>
<li>on-screen graphics if used with graphics;</li>
<li>spiral wave trajectory in ASCII file <code>fhn2.trj</code>;</li>
<li>PNG images of frames of the 2D simulation;</li>
</ul>

<p>
Before running this script, make sure that a correct fhn1.rec has been
created by running fhn1.bbs.  To run this bbs script with VGA graphics,
use the following command:
</p>
<pre>
Beatbox_SEQ fhn2.bbs
</pre>
and to run without graphics, use the following command:
<pre>
Beatbox_SEQ fhn2.bbs -nograph
</pre>

<!-- ===================================== -->
<h3 class="numbered">b02.bbs</h3>

<p> This script simulates propagation and destruction of a critical
solution in the model of in a-driven excitation front described in:
</p>
<blockquote>
V.N. Biktashev, "Dissipation of the excitation
wavefronts", Phys. Rev. Lett., 89(16): 168102, 2002,
</blockquote>
<p>
and reproduces figure 5 from that paper. See:
</p>
<ul>
<li> <a href="../data/scripts/sequential/b02/fig5.bbs">fig5.bbs</a>
</ul>
<p>
This script reproduces both panels of the figure, and it is placed in
a separate subdirectory in which some post-processing is done as well.
The new things that this script illustrates are:
</p>
<ul>
  <li> Use of command-line arguments to vary a simulation parameter
  and the name of the output file; </li>
  <li> Slightly more complicated k-expressions for piecewise
  definition of the initial conditions; </li>
  <li> Use of <code>k_print</code> device to write the output files in
  the <code>png</code> format. 
</ul>
<p>
The directory
<a href="../data/scripts/sequential/b02/">../data/scripts/sequential/b02/</a>
also contains <code>Makefile</code> which describes the
workflow leading to creation of the final product,
<code>fig5a.png</code> and <code>fig5b.png</code> files. For this to
work, 
<a href="netpbm">netpbm</a> has to be installed on your
computer. </p>

<p> The following steps can be done to reproduce the workflow: </p>

<ul>
  <li> Create a fresh empty directory, say
<pre>
mkdir ~/b02-test
</pre>
  </li>
  <li> Copy the prerequisite files into that directory. Assuming your
  copy of Beatbox is under <code>~/beatbox-1.2/</code>, this can be
  done by the following commands:
<pre>
cd ~/beatbox-1.2/data/scripts/sequential/b02/
cp Makefile fig5.bbs ~/b02-test/
cd ~/b02-test/
</pre>
  </li>
  <li> The following command will show the entire workflow without
  actually doing it:
<pre>
make --dry all
</pre>
  Using the output of this command as a guide, you can execute the
  whole workflow step by step, by typing or copy/pasting its output to
  your command line.  Note that due to the <code>pause</code> device
  in the script, you would need to press enter in the terminal window
  used to launch BeatBox.
  </li>
 <li> The following command will actually do all the work automatically: 
<pre>
make all
</pre>  
  If all works correctly, you will find files
  <code>fig5a.png</code> and <code>fig5b.png</code> in the
  <code>~/b02-test/</code> directory. Compare them with the ones
  obtained by the BeatBox developers, which are back in
  <code>~/beatbox-1.2/data/script/sequential/b02/</code> directory.
</ul>

Command line inputs to this script are:
<ul>
<li>value of sigma (0.624 or 0.625)
<li>name of output directory
</ul>
The outputs from this script are:
<ul>
<li>onscreen graphics if used with graphics;
<li>PGM output files for visualisation
</ul>
<p>
Before running this script, please read sec 4.1.4 of beatbox.html.
This script comes with a <code>Makefile</code> that will allow you to
do the simulation. To use this <code>Makefile</code> for the
simulations, type at the command line:
</p>
<pre>
make all
</pre>
<p>
Alternatively, to run this bbs script from command line with VGA graphics,
use one of the following commands::
</p>
<pre>
Beatbox_SEQ fig5.bbs 0.624 output_dir   or
Beatbox_SEQ fig5.bbs 0.625 output_dir
</pre>
and to run without graphics, use the following command:
<pre>
Beatbox_SEQ fig5.bbs 0.624 output_dir -nograph or
Beatbox_SEQ fig5.bbs 0.625 output_dir -nograph
</pre>
<!-- ===================================== -->
<!-- ===================================== -->
<h2 class="numbered">Parallel</h2>

<!-- ===================================== -->
<h3 class="numbered">scroll.bbs</h3>

<p>
This script simulates a scroll waves in a cuboidal 3D domain with
Barkley kinetics and explicit Euler approximation of diffusion. It is
a short crude model of actual simulations used in H. Dierckx et al.,
``Buckling of scroll waves'' Phys. Rev. Lett., 109(17):174102, 2012
(that paper also used an alternating-direction semi-implicit
approximation of diffusion, but it is still to be documented). See:
</p>
<ul>
<li>
<a href="../data/scripts/parallel/Barkley/scroll.bbs">scroll.bbs</a>
</li>
</ul>
<p>
The script uses phase-distribution method to create initial
conditions in the form of a slightly twisted scroll wave, using a
pre-recorded file <code>bkl1.rec</code> in the same directory. 
Further things to note in this script are: 
</p>
<ul>
  <li>
  The first command-line argument is the name of the pre-recorded
  file used for the initial conditions.
  </li>
  <li>
  The second command-line argument is a number used as part of the
  name of the output directory. It will be 0 for the sequential run
  and will be a number of threads for parallel runs.
  </li>
  <li>
  The <code>diff</code> device is called twice as in that model both
  equations contain diffusion terms, and with different diffusion
  coefficients. Correspondingly, two extra layers <code>[iu]</code>
  and <code>[iv]</code> are used to keep the values of these terms
  instead of just the usual one.
  </li>
  <li>
  The <code>ppmout</code> device is used to output a
  "three-dimensional image". It has the usual PPM header, showing the
  x- and y-sizes of the 3D array it contains, as width and height
  respectively. However this header is followed not by a
  <code>nx&times;ny</code>
  array of byte triplets, but by <code>nz</code> such
  arrays, thus making the whole 3D <code>nx&times;ny&times;nz</code>
  array. Note that the "3D ppm" format used for that is NOT the
  standard multi-image ppm, which also can have <code>nz</code> arrays
  going one after the other, but there each of them has its own
  header. Our "3D ppm" format is not standard but it is understood by
  the <code>EZView</code> viewer (see below).
  </li>
  <li>
  The <code>singz</code> device outputs not the position of the tip of
  the spiral wave, as in 2D simulations discussed above, but a
  position of such a tip in every <code>z=const</code>
  cross-section. Since in this simulation the filament of the scroll
  wave goes monotonically in vertical direction, such collection of
  spiral tips effectively makes up a description of the filament of
  the scroll wave. This output was used for processing to measure
  "buckling" of a scroll wave in the above cited paper. The
  visualization of the scroll filament can be done independently by
  the visualizer, see below. 
  </li>
</ul>
<p>
The directory
<a href="../data/scripts/parallel/Barkley/">../data/scripts/parallel/Barkley/</a>
also contains <code>Makefile</code> which describes the
workflow leading to creation of the final product,
<code>bkl1.rec</code> pre-recorded file used for the initial
conditions, and <code>report.dat</code> which contains the table of
run time in seconds vs number of processors used when this script was
tested by the developers on a MacPro workstation. As in
<code>b02.bbs</code> example above, you can use <code>make --dry
all</code> to see the workflow involved, or just <code>make all</code>
to do it all automatically.
</p>

<p>
The <code>report.dat</code> obtained by the developers for BeatBox
version 1.2.484 on a MacPro with 2 x 2.4 GHz 6-Core Intel Xeon
processor contained
</p>
<pre>
1	 207.352903 
2	 105.242710 
4	 55.027358 
8	 31.047070 
16	 30.074329 
</pre>

<p>
which indicates that parallelization is effective only up to about 8
processes and further increase of number of processes does not offer
any speed-up. Presumably this is due to the relatively small size of
the box, so communication cost start dominating
after <code>np=8</code>.
</p>

<p>
<strong> Exercise:</strong> Increase the size of the box twice in each
direction and repeat the scaling test.
</p>

<p> 
<strong> Answer:</strong> On the same computer as above, the
resulting <code>report.dat</code> contained:
</p>

<p class="quest">
TBD
</p>

<p>
Visualization of the resulting "3D ppm" files can be done using
<code>EZView</code>. To this end, the 
<a href="../data/scripts/parallel/Barkley/">../data/scripts/parallel/Barkley/</a>
directory contains Perl script <code>view.pl</code>. As can be seen
from the <code>Makefile</code>, to view the result of simultion on 8
processors, you say:
</p>
<pre>
make view-8
</pre>
<p>
on the command line, etc. The Perl script creates an appropriate "task
file" in the relevant directory, and then calls <code>ezscroll</code>
binary which thus has to be already installed on your computer and
visible in your <code>$PATH</code>. See
<a href="http://empslocal.ex.ac.uk/people/staff/vnb262/software/EZView/">
http://empslocal.ex.ac.uk/people/staff/vnb262/software/EZView/
</a> for the EZView source code and instruction; this particular
scroll will work with version 1.1 (beware, different versions of
EZView use different format of task files).
</p>

<p>
Command line inputs:
</p>

<ul>
<li><code>bkl1.rec</code> (provided with this bbs script)</li>
<li>number of MPI processors (integer value)</li>
</ul>

<p>
The outputs from this bbs script are:
</p>

<ul>
<li>dump file called scroll.dmp (in out_dir)</li>
<li>sampled variables in history.dat (in out_dir)</li>
<li>3D ppm files (in directory called ppm)</li>
<li>scroll filament called singz.dat (in out_dir)</li>
</ul>

<p>
Before running this script, make sure that the <code>bkl1.rec</code>
is in your working directory.  You will also need the
provided <code>view.pl</code> (a Perl script) in your working
directory.  To run this script in parallel and do the exercise, you
can edit the <code>scroll.bbs</code> file and then type:
</p>

<pre>
make all
</pre>

<p>
to do all the tasks in the simulation. To do the tasks individually,
see the <code>Makefile</code>.
</p>


<!-- ===================================== -->
<!-- ===================================== -->
<h1 class="numbered">bbg (geometry) data and cell models</h1>
<h2 class="numbered">bbg (geometry)</h2>

<p>
There is an extensive repository (and ever growing) of cardiac
anatomical models in Beatbox. These models are provided as ASCII text
files with an extension <code>.bbg</code> (e.g. <code>ffr.bbg</code>).
The way to include any of the following geometries into a simulation
is by means of a state device call in the bbs program as follows:
</p>

<pre>
state file=name_of_your_geometry.bbg normaliseVectors=1 anisotropy=1 vmax=neqn+1;
</pre>

<p>
The bbs program can then work out the bounding box xmax, ymax, and
zmax.  If you have isotropic simulation, the normaliseVectors and
anisotropy parameters should not be included in the state call.  A
brief description of the geometries, and asssociated bbs programs is
below. The space step is usually obtained from the authors of the
geometry, as is the species type (human, rabbit,...).
</p>

<h3 class="numbered">ffr.bbg</h3>

<p>
This is a rabbit ventricle geometry. The space step in this geometry
is 0.1 mm. The bbs program
that can initiate a spiral wave and gives all other optimised
simulation paramters using LRD kinetics is:
</p>

<ul>
<li>
<a href="../data/scripts/sequential/LRD_model/LRD_ffr.bbs">LRD_ffr.bbs</a>
</li>
</ul>

<p>
The purpose of this script is to allow 3D simulation using the ffr.bbg
rabbit geometry. This bbs script also demonstrated the use of the
anisotropic diff device.
</p>

<p>
The inputs to this script are:
</p>

<ul>
<li> <code>ffr.bbg</code> (this file should be in your working directory)</li>
</ul>

<p>
The outputs of this script are:
</p>

<ul>
<li> 3D ppm files (in <code>sub-dir ppm/</code>)</li>
<li> a record of all dynamical variables at given point location where
the file is called <code>LRD_ffr.rec</code> in <code>out/</code></li>
<li> a dump file called <code>LRD_ffr.dmp</code>
in <code>out/</code></li>
</ul>

<p>
To run this simulation, make sure you have <code>ppm/</code>
and <code>out/</code> sub-directories.  To run this simulation in
serial, use the command:
</p>

<pre>
Beatbox_SEQ LRD_ffr.bbs -verbose
</pre>

<p>
To run this in parallel using np number of processors, use the command:
</p>

<pre>
mpirun -n np Beatbox LRD_ffr.bbs -verbose -profile
</pre>


Quicker calculations with the same geometry can be done using
<ul>
<li>
<a href="../data/scripts/sequential/FitzHughNagumo_model/fhn_ffr.bbs">fhn_ffr.bbs</a>
</li>
</ul>


<h3 class="numbered">ffr_slice.bbg</h3>

<p>
This is a slice of the above rabbit ventricle geometry. The space step
in this geometry is 0.1 mm. There is 1 tissue type in this
geometry. The bbs program that can initiate a spiral wave and gives
all other optimised simulation paramters using LRD kineitcs is:
</p>

<ul>
<li>
<a href="../data/scripts/sequential/LRD_model/LRD_ffr_slice.bbs">LRD_ffr_slice.bbs</a>
</li>
</ul>

<p>
The purpose of this script is to allow 2D simulation using an uneven
geomtry. The inputs to this file are the geometry,
i.e. ffr_slice.bbg. The 2D geometry has fibre orientation and this
file demonstrates the use of the anisotropic diff device. The output
from this script are 2D ppm files (in the sub-dir ppm/).  To run this
simulation in serial, use the command:
</p>

<pre>
Beatbox_SEQ LRD_ffr_slice.bbs -verbose
</pre>

<p>
To run this in parallel using np number of processors, use the command:
</p>

<pre>
mpirun -n np Beatbox LRD_ffr_slice.bbs -verbose -profile
</pre>

<h2 class="numbered">Cell models</h2>

<p>
There is an extensive repository (and every growing) of
electrophysiological and electro-mechanical cardiac cell models in
Beatbox. These cell models are provided as modules and are assigned a
name that can be used in the bbs programs. The cell model module is
accessed in a call to the ode solver, i.e. euler device. The euler
device's generic syntax is:
</p>

<pre>
euler v0=0 v1=neqn-1 ht=ht ode=my_cell_model_name rest=100 par={
ht=ht;
Iu=@[iext];
par1=val1;
par2=val2;
};
</pre>

<p>
where <code>neqn</code> is the number of ODEs in the cell model, and
par1 and par2 are cell model specific parameters that you may want to
modify (e.g. increase gCaL).  Assuming that your diffusing variable is
voltage, the layer of voltage is explained in the sub-sections
below. See <a href="#Beatbox_Cell_Model_Reference">Beatbox Cell Model
Reference</a> below for several cell model available in the package.
</p>

<h1 class="numbered">Beatbox Developer's Guide</h1>
<h2 class="numbered">Hello Beatbox!</h2>

<p>
Devices are the primary building block of a Beatbox simulation. A
simulation consists of two or more devices that are called in turn, at
most once for each simulation timestep. When called, the device can
perform a task, with optional access to the simulation
medium, <code>New</code>. 
</p>

<p>
In this tutorial, we’ll build a device to output the text
“<code>Hello, Beatbox !</code>” in the simulation’s standard output
file. We won’t go into much detail in this section, rather we’ll just
look at the absolute minimum one has to do to build a working device.
</p>

<h3 class="numbered">The Device Skeleton</h3>

<p>
The template below shows the a <code>.c</code> file containing the
basic outline of a minimal device.
</p>

<pre>
#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "system.h"
#include "beatbox.h"
#include "device.h"
#include "state.h"
#include "bikt.h"
#include "qpp.h"

typedef struct {
int dummy;  // Add your own device -specific storage here.
} STR;

RUN_HEAD(myDevice)
/* Put code to perform the device ’s task here. */
RUN_TAIL(myDevice)

DESTROY_HEAD(myDevice)
/* Free any allocated resources here. */
DESTROY_TAIL(myDevice)

CREATE_HEAD(myDevice)
/* Add any initialisation code here. */
CREATE_TAIL(myDevice ,1)
</pre>

<p>
There are four key parts to a device:
</p>

<ol> 
<li>
<p>
The first is the definition of the <code>STR</code> datatype. Every
device in Beatbox defines <code>STR</code> to meet its specific
storage requirements. Usually, <code>STR</code> is used to define a
structure for any constants required by the device. For our
“<code>Hello, Beatbox !</code>” device, we won’t need any persistent
storage, so we’ll just use the minimal implementation that’s given in
the template. We’ll see how to use <code>STR</code> in more detail in the
<a href="#Anatomy_of_a_Device">Anatomy of a Device</a> section.
</p>
</li>
<li>
<p>
The second part of interest is the function used to run our
device. Code between the <code>RUN_HEAD</code>
and <code>RUN_TAIL</code> macros defines what the device does. This is
where whatever computation or output tasks to be performed by the
device will happen. For our “<code>Hello, Beatbox!</code>” device,
this is where we want to output our message. We’ll use
the <code>MESSAGE</code> macro, defined in <code>beatbox.h</code>,
which will print to both
<code>stdout</code> and the simulation’s <code>.res</code> file.
</p>

<pre>
RUN_HEAD(hello)
MESSAGE("Hello , Beatbox!\n");
RUN_TAIL(hello)
</pre>

<p>
We’ll also have to change the name in the parentheses of
the <code>RUN_HEAD</code> and <code>RUN_TAIL</code> macros
from <code>myDevice</code> to <code>hello</code>. <code>hello</code>
will be the name of our device, and we’ll need to use it wherever we
refer to the device. Device names cannot use spaces and are, by
convention, all lower-case, without punctuation. If you really need to
separate words, use an underscore (_).
</p>

</li>
<li>
<p>
The function defined by expanding the <code>DESTROY_HEAD</code>
and <code>DESTROY_TAIL</code> macros is called only once, at the end
of a simulation, and should be used to free any allocated
resources. Since our device won’t allocate anything, we don’t have
anything to free, so we can leave this function empty and just put the
device name in the parentheses:
</p>
<pre>
DESTROY_HEAD(hello)
/* Nothing to do here. */
DESTROY_TAIL(hello)
</pre>
</li>

<li>
<p>
The fourth and final part prepares the device to be run. The function
defined by expanding the <code>CREATE_HEAD</code>
and <code>CREATE_TAIL</code> macros will be called only once, at the
start of the simulation and should be used to perform any
initialisation tasks required by the device. This is discussed in much
more detail in the <a href="#Anatomy_of_a_Device">Anatomy of a
Device</a> section. For our “<code>Hello, Beatbox!</code>” device, we
needn’t add any code here, so just put the device name in the
parentheses.
</p>

<pre>
CREATE_HEAD(hello)
/* Nothing to do here. Quite boring , actually. */
CREATE_TAIL(hello ,1)
</pre>

<p>
Although we’ve not put any code between the <code>HEAD</code>
and <code>TAIL</code> macros, it’s important not to remove them
altogether, as they are all referred to elsewhere in Beatbox. Also, be
sure not to change the order of the macros,
since <code>CREATE_TAIL</code> defines code dependent upon
the <code>RUN_HEAD</code> and <code>DESTROY_HEAD</code> macros. We
can now save our device file. By convention, the
device’s <code>.c</code> file should have the same name as the device,
so ours will be <code>hello.c</code>.
</p>
</li>

</ol>


<h3 class="numbered">Registering our Device</h3>

<p>
Now that we have a new device, we need to inform Beatbox that it’s
available for use in a simulation. We do this by listing our device’s
name in <code>devlist.h</code>. The name listed here must match
exactly (case matters) the name we used in our device code.
</p>

<p>
Open <code>devlist.h</code> and add the following line:
</p>

<pre>
D(hello)
</pre>

<p>
It’s good practice to add your device in alphabetical order. You’ll
see a few devices in there that are listed
as <code>S(somedevice)</code>. These devices will only work in
sequential mode, and will be disabled in parallel. They’re naughty
devices. Since we don’t want our new device to fall in with this rough
crowd, we’re going to use <code>D()</code>, ok?
</p>

<h3 class="numbered">Building Beatbox with our Device</h3>

<p>
Beatbox is built using the GNU Autotools. To include our new device in
the build, we must add it to <code>Makefile.am</code>, which, like
your <code>hello.c</code> file, should be in the <code>src</code>
directory. <code>Makefile.am</code> contains a simple description of
what’s required to build the software. When we’re done changing it,
we’ll use <code>automake</code> to generate a
new <code>Makefile</code>, from which the code will actually be built.
Open <code>Makefile.am</code>. Scroll down the file, past the flags
and other stuff until you find the line:
</p>

<pre>
common_sources = \
</pre>

<p>
followed by a long list of <code>.c</code> and <code>.h</code>
files. In correct alphabetical order, add the following line to the
list:
</p>

<pre>
hello.c\
</pre>

<p>
We can now build Beatbox with our new device. First, we need to
generate a new <code>Makefile</code> by invoking <code>automake</code>
from the <code>beatbox</code> directory.
</p>

<pre>
$ pwd
$ /Users/rossmcf/Working/beatbox
$ automake
</pre>

<p>
With <code>automake</code>, no news is good news. We can now compile
our new version of Beatbox containing the <code>hello</code>
device. We’ll run the local <code>configure</code> script to set up
the build system for our machine, and then make to actually build the
code.
</p>

<pre>
$ pwd
$ /Users/rossmcf/Working/beatbox
$ ./configure
... (Lots of stuff)
$ make
... (Lots more stuff , hopefully no errors.)
</pre>

<p>
This will compile the code. Assuming all is well, you can now install
the binary wherever you want it.
</p>

<pre>
$ make install
... (Even more stuff.)
</pre>

<p>
Don’t be too worried about all the text whizzing by. If anything goes
amiss, the last line usually tells you all you need to know.
</p>

<h3 class="numbered">Running our Device</h3>

<p>
To include our new device in a simulation, we use the device’s name in
the script. So, to print our “<code>Hello, Beatbox!</code>” at each
timestep, we include the following line, making sure to leave a space
between the device name and the semicolon: <code>hello ;</code> You
can try using the following simple script, let’s call
it <code>basic.bbs</code>, to test it:
</p>

<pre>
// The medium
state xmax=1 ymax=1 zmax=1 vmax=4;

// Schedule and display parameters
def real begin;
def real end;
k_func nowhere=1 pgm={
begin =eq(t,0);
end =ge(t,20);
};

// Our new device!
hello ;

stop when=end;
end;
</pre>

<p>
Running the script with the following command:
</p>

<pre>
$ &lt;mpirun commands&gt; Beatbox basic.bbs &lt;-options&gt;
</pre>

<p>
should produce something like:
</p>

<pre>
Beatbox 
------------------------------------------------------------------------------------
BEATBOX_1.0 -- MPI version date Oct 26 2010 22:11:47 $
execution begin at Tue Oct 26 22:14:12 2010 $
Input file basic.bbs without additional arguments $
with options: noappend nodebug noverbose nograph noprofile resname=basic.res
state  Simulation medium (1 x 1 x 1)
Domain decomposed as (001,001,001).
0 processors of 1 remain idle.
$
k_func $
hello $
stop $
end of input file $
Loop of 3 devices created: (0)k_func (1)hello (2)stop $
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
Hello , Beatbox!
TIMING INFO
-------------------------
This run took 0.000266 seconds.
BEATBOX_0.1 finished at t=20 by device 2 "stop"
</pre>

<p>
So, now that you’ve built your first device, you might want to make
one that actually does something. For that, you’ll need to read
<a href="#Anatomy_of_a_Device">Anatomy of a Device</a> sectin.
</p>

<h2 class="numbered">Anatomy of a Device</h2>

<p>
This section assumes that you’ve read <a href="#Hello_Beatbox!">Hello
Beatbox!</a> section and have built a Beatbox device using the method
described therein. We’re now going to go a little more slowly, taking
the time to see how and why things work they way they do in
Beatbox. Much of the generic code required of a device is provided as
a collection of macros and type definitions in <code>device.h</code>,
which must be included by all devices.
</p>

<h3 class="numbered">The Parameter Structure</h3>

<p>
For the persistent storage of data, devices must declare a parameter
structure using the <code>STR</code> datatype. <code>STR</code> is a
marker type that should be defined, using <code>typedef</code> , as
a <code>struct</code>. Typically, the <code>STR</code> struct has
fields for one or more user-specified parameters and any other
constants required by an instance of the device. A minimal
implementation, as shown in <code>hello.c</code>, above, should
define <code>STR</code> as a struct with at least one field.
Commonly, the parameter structure is used to hold values of parameters
read from the script. This process is described in
the <a href="#Reading_Parameters">Reading Parameters</a> subsection.
</p>

<h3 class="numbered">The Device Datatype</h3>

<p>
The <code>Device</code> datatype (<code>device.h</code>) represents an
instance of a device, as called in the user script.
One <code>Device</code> structure is allocated for each of the device
calls in the script, such that if the same type of device
(e.g. <code>k_func</code>) is called multiple times, there will be
multiple <code>Device</code> structures. For the most part,
the <code>Device structure</code> is only used ‘behind the
scenes’. One field of the <code>Device</code> structure that you will
see a lot, however, is the <code>Space</code> structure.
</p>

<p>
Your device’s space determines the points and dynamic variables of the
simulation medium on which it should operate. A device’s
implementation code should not interact directly with
the <code>Device</code> structure, so we won’t look at it any
longer. Forget you even saw it. Some minimal interaction with the
<code>Device</code> structure is provided in the function template
macros defined in <code>device.h</code>. Using these is the best way
to get the job done without wandering into any dangerous territory.
</p>

<h3 class="numbered">Device Function Templates</h3>

<p>
As we saw in the <a href="#Hello_Beatbox!">Hello Beatbox!</a> section,
your device needs to define three functions, referred to
as <code>Create</code>, <code>Run</code>
and <code>Destroy</code>. <code>device.h</code> defines three template
macros that will wrap around your function implementations. Using
these templates is strongly recommended since they ensure reliable
operation of devices, keep code concise and reduce redundancy. Each
template takes the form of a <code>HEAD</code> and <code>TAIL</code>
macro. These open and close the function respectively, and throw in
some standard functionality for good measure.
</p>

<p>
The head macros take at least one argument, the name of the
device. This is included into the function’s name when the macro is
expanded, so that, for example, the <code>euler</code> device will
have functions
called <code>create_euler()</code>, <code>run_euler()</code> and
<code>destroy_euler()</code>. Your chosen device name must be unique
and used consistently throughout all macros and
in <code>devlist.h</code>.
</p>

<h3 class="numbered">CREATE_HEAD and CREATE_TAIL</h3>

<p>
You device’s <code>Create</code> function performs any initialisation
required for the device. The function is run once only, before the
simulation begins. The <code>CREATE_HEAD</code> macro declares and
allocates memory for the device’s parameter structure, <code>S</code>,
a local variable of type <code>STR</code>. You can use the body of the
function to assign values to the parameter structure.
</p>

<p>
The defined function will have the name
of <code>create_&lt;name&gt;</code>, where
<code>&lt;name&gt;</code> is the argument to
the<code>CREATE_HEAD</code> macro. To avoid name collisions, it is
strongly recommended that <code>&lt;name&gt;</code> correspond to the
name of the device.
</p>

<p>
The <code>create_&lt;name&gt;</code> function has two
parameters, <code>dev</code> and <code>w</code>. <code>dev</code> is a
pointer to the <code>Device</code> structure and is used by the
<code>CREATE_TAIL</code> macro to assign values to its
fields. <code>w</code> is a pointer to the parameter string taken from
the device call in the user script. This can be used in combination
with the functions defined in <code>qpp.h</code> to acquire values
from the user script. For more details on how to do this, see
the <a href="#Reading_Parameters">Reading Parameters</a> subsection.
</p>

<p>
The <code>CREATE_TAIL</code> macro assigns the address
of <code>S</code> and pointers to functions
named <code>run_&lt;name&gt;</code> and
<code>destroy_&lt;name&gt;</code> to
the <code>par</code>, <code>p</code> and <code>d</code> fields of the
<code>Device</code> structure respectively. 
</p>

<p>
Although the <code>Create</code> function has access to
the <code>Device</code> structure at this point, it is perilous to
tamper with the device structure, so just don’t.
</p> 

<h3 class="numbered">RUN_HEAD and RUN_TAIL</h3>

<p>
Your device’s <code>Run</code> function describes the task it will
perform. The function will be called <code>run_&lt;name&gt;</code>
where <code>&lt;name&gt;</code> is the argument to the <code>RUN_HEAD
macro</code>. The <code>Run</code> function is pointed to by the <code>p</code>
field of the <code>Device</code> structure, with
the <code>s</code>, <code>w</code> and <code>par</code> fields of the
same structure passed as arguments. 
</p>

<ul>
<li>
<code>s</code> is the device’s <code>Space</code> structure, which is
discussed in the <a href="#Accessing_New">Accessing New</a>
subsection.
</li>
<li>
<code>w</code> is the device’s <code>Window</code>
structure.
</li> 
<li>
<code>par</code> is the device’s parameter structure.
</li>
</ul>

<p>
The <code>RUN_HEAD</code> macro contains code that
assigns <code>par</code> to a local variable, <code>S</code>, of type
<code>STR</code>. Fields of the parameter structure can then be
accessed using <code>S-&gt;fieldName</code>. Commonly,
the <code>Run</code> function begins by retrieving values from the
parameter structure to local variables. This can be done using
shortcut macros defined in <code>device.h</code>. We discuss this in
more detail in the <a href="l#Reading_Parameters">Reading
Parameters</a> subsection.
</p>

<p>
The <code>RUN_TAIL</code> macro closes the function, returning 1 to
indicate success. If the <code>Run</code> function of any device
returns, 0 Beatbox will stop the simulation immediately.
</p>

<h3 class="numbered">DESTROY_HEAD and DESTROY_TAIL</h3>

<p>
In your device’s <code>Destroy</code> function, it should put its toys
away; it’s time for bed. Specifically, the <code>Destroy</code>
function should free any memory allocated for the device and close any
open files. If you use the provided template macros, there is no need
to free <code>par</code>/<code>S</code>. The function is pointed to by
the <code>d</code> field of the <code>Device</code> structure, with
the <code>s</code>, <code>w</code> and <code>par</code> fields of the
same structure passed as arguments. 
</p>

<ul>
<li>
<code>s</code> is the device’s <code>Space</code> structure.
</li>
<li>
<code>w</code> is the device’s <code>Window</code> structure.
</li>
<li>
<code>par</code> is the device’s parameter structure.
</li>
</ul>

<p>
The <code>DESTROY_HEAD</code> macro will again point local
variable <code>S</code> to your device’s parameter
structure. The <code>DESTROY_TAIL</code> macro frees <code>par</code>
and returns 1 to indicate success.
</p>

<h3 class="numbered">Accessing New</h3>

<p>
Beatbox’s simulation medium is a four-dimensional data set - multiple
dynamic variables or layers at points in three-dimensional space.
Beatbox represents the simulation medium with a one-dimensional array
called <code>New</code>, defined in <code>state.h</code>. In addition
to exporting <code>New</code>, <code>state.h</code> provides a
collection of variables and macros with which to navigate it. These
are listed in <a href="#I.1">Table I.1</a>.
</p>

<table border="1" id="I.1">
<caption>
Table I.1: Public <code>state</code> Variables.
</caption>
<tr>
<th>Name</th><th>Description</th>
</tr><tr>
<td><code>t</code> </td><td> The current time step.<br>
</tr><tr>
<td><code>New</code> </td><td> The simulation medium.</td>
</tr><tr>
<td><code>vmax</code> </td><td> Number of layers.</td>
</tr><tr>
<td><code>xmax</code> </td><td> Number of points in the x-axis.</td>
</tr><tr>
<td><code>ymax</code> </td><td> Number of points in the y-axis.</td>
</tr><tr>
<td><code>zmax</code> </td><td> Number of points in the z-axis.</td>
</tr><tr>
<td><code>vmax_xmax</code> </td><td> Number of variables in the v/x
plane.</td>
</tr><tr>
<td><code>vmax_xmax_ymax</code> </td><td> Number of variables in the
v/x/y plane.</td>
</tr><tr>
<td><code>DX</code> </td><td> The number of array locations between
neighbouring points on the x-axis. (See Figure 2.8)</td>
</tr><tr>
<td><code>DY</code> </td><td> The number of array locations between
neighbouring points on the y-axis. (See Figure 2.8)</td>
</tr><tr>
<td><code>DZ</code> </td><td> The number of array locations between
neighbouring points on the z-axis.</td>
</tr><tr>
<td><code>DV</code> </td><td> The number of array locations between
neighbouring points on the v (variable) axis.</td>
</tr><tr>
<td><code>dim</code> </td><td> The dimensionality of the mesh, from 0
(single cell) to 3.</td>
</tr><tr>
<td><code>ONE</code></td><td> 1 if the dimensionality is greater than
or equal to 1. 0 otherwise.</td>
</tr><tr>
<td><code>TWO</code></td><td> 1 if the dimensionality is greater than
or equal to 2. 0 otherwise.</td>
</tr><tr>
<td><code>TRI</code></td><td> 1 if the dimensionality is greater than
or equal to 3. 0 otherwise.</td>
</tr>
</table>

<p>
To access a point in <code>New</code>, use the <code>ind()</code>
function to obtain the index of the desired
location. <code>ind()</code> takes 4
coordinates, <code>{x,y,z,v}</code>. For a pointer, you will commonly
use <code>New+ind(x,y,z,v)</code>, and for an absolute
value <code>New[ind(x,y,z,v)]</code>. 
</p>
<p>
When accessing <code>New</code>, your device MUST only alter values at
points within its space, i.e. <code>i0 &lt;= i &lt;= i1</code>. When
iterating over the medium, it is advised that the space structure’s
fields be used as loop bounds. Not doing so will produce inconsistent
behaviour for users.
</p>

<pre>
RUN_HEAD(example)
int x, y, z;
real HUGE *u;
for(z=s.z0;z&lt;=s.z1;z++){
    for(y=s.y0;y&lt;=s.y1;y++){
        for(x=s.x0;x&lt;=s.x1;x++){

            u=New+ind(x,y,z,s.v0);
            /* do something to u here */

        }
     }
}
RUN_TAIL(example)
</pre>

<p>
Accessing points immediately <code>(x ± 1,y ± 1,z ± 1)</code> outside
of the device’s space is acceptable, provided such access is
read-only. If your device does reference neighbouring points in this
fashion, it MUST include the <code>DEVICE_REQUIRES_SYNC</code> macro
in its <code>Create</code> function. This will ensure that the device
continues to operate correctly in parallel. 
</p>

<p>
Great care should also be exercised when writing to locations
in <code>New</code>. Since <code>New</code> may hold values relating
to more than one timestep, the mathematical procedure may be corrupted
if values required by other devices are overwritten. In general,
operations on <code>New</code> MUST be commutative — the device MUST
NOT assume a particular order of execution. In addition, devices that
are not explicitly parallelised MUST NOT assign values derived from
<code>New</code> to their parameter structure, or any other global
variable. This will stop terrible things from happening when the
device is run in parallel. 
</p>

<p>
To keep users happy, layers accessed by your device should be
specified via the <code>Space</code> structure. In most
cases, <code>v0</code> and <code>v1</code> describe a range, but some
devices use them separately, e.g. <code>s.v0</code> as ‘source’
and <code>s.v1</code> as ‘destination’. 
</p>

<h3 class="numbered">Tissue Geometry</h3>

<p>
If your device is interested in accessing data about the underlying
tissue geometry, you’ll find it
in <code>Geom</code>. <code>Geom</code> is organised in much the same
way as <code>New</code>, and we use <code>geom_ind(x,y,z,v)</code> to
access it. The <code>v</code> variable can have one of four values:
</p>
<ul>
<li><code>GEOM_STATUS</code>,</li>
<li><code>GEOM_FIBRE_1</code>,</li>
<li><code>GEOM_FIBRE_2</code>,</li>
<li><code>GEOM_FIBRE_3</code>.</li>
</ul>

<p>
To test if a point is tissue, use <code>isTissue(x,y,z)</code>. The
same rules apply to <code>Geom</code> as to <code>New</code>, in
particular, stick to your <code>Space</code> structure and don’t
reference any further away than <code>( x ± 1,y ± 1,z ± 1)</code>.
</p>

<h3 class="numbered">Reading Parameters</h3>

<p>
Commonly, a device will take some parameters from the user via the
script. We call this process ‘accepting’ a parameter. There are two
steps to this process:
</p>

<ol> 
<li>
Firstly, the parameter is read by the script
preprocessor, and assigned to the device’s parameter structure.
</li>
<li>
Later, in order to use the parameter, the device will retrieve the
value from the parameter structure. Both of these steps are greatly
simplified by some handy macros defined in <code>qpp.h</code>.
</li>
</ol>

<h3 class="numbered">Parameter Accept Macros</h3>

<p>
Parameter accept macros provide a quick way to pull a parameter value
from the script and assign it to its namesake field in the device’s
parameter structure. The first thing to consider is the type of
parameter you’d like to accept. There are four common types:
</p>
<ul>
<li><code>Integers</code> Requires an <code>int</code> in the
parameter structure.</li>
<li><code>Real Numbers</code> Requires a <code>double</code> in the
parameter structure.</li>
<li><code>Strings</code> Requires a <code>char[]</code> array in the
parameter structure.</li>
<li><code>Files</code> Requires two fields in the parameter structure;
a <code>FILE *</code> with the same name as the parameter, and
a <code>char[]</code> array of size <code>MAXPATH</code> with the name
<code>&lt;param&gt;name</code>, where <code>&lt;param&gt;</code> is
the name of the parameter.</li>
</ul>

<p>
The corresponding parameter accept macros are listed below. They each
have a default argument that, if given the corresponding null value,
will require that the user supplies a value, rather than merely making
it optional.
</p>

<dl>
<dt><pre>ACCEPTI(name,deflt,minv,maxv);</pre></dt>
<dd>
<ul>
<li>
<code>name</code> Name of the parameter whose value is to be read.
</li>
<li>
<code>deflt</code> Default value, in case no parameter
called <code>name</code> is found. If <code>INONE</code>, a script
parameter MUST be found.
</li>
<li>
<code>minv</code> Minimum allowed value. If <code>INONE</code>, no
minimum is prescribed.
</li>
<li>
<code>maxv</code> Maximum allowed value. If <code>INONE</code>, no
maximum is prescribed.
</li>
</ul>
</dd>
<dt><pre>ACCEPTR(name,deflt,minv,maxv);</pre></dt>
<dd>
<ul>
<li><code>name</code> Name of the parameter whose value is to be read.
</li>
<li><code>deflt</code> Default value, in case no parameter called
<code>name</code> is found. If <code>RNONE</code>, a script parameter
MUST be found.</li>
<li><code>minv</code> Minimum allowed value. If <code>RNONE</code>, no
minimum is prescribed.</li>
<li><code>maxv</code> Maximum allowed value. If <code>RNONE</code>, no
maximum is prescribed.</li>
</ul>
</dd>
<dt><pre>ACCEPTS(name,deflt);</pre></dt>
<dd>
<ul>
<li><code>name</code> Name of the parameter whose value is to be
read.</li>
<li><code>deflt</code> Default value, in case no parameter called
<code>name</code> is found. If <code>NULL</code>, a script parameter
MUST be found.</li>
</ul>
</dd>
<dt><pre>ACCEPTF(name,mode,deflt);</pre></dt>
<dd>
<ul>
<li><code>name</code> Name of the parameter whose value is to be
read.</li>
<li><code>mode</code> Access mode in which the file is to be
opened. Syntax is identical to a <code>fopen()</code> call:
<ul>
<li><code>r</code> or <code>rb</code> Open existing le for reading.</li>
<li><code>w</code> or <code>wb</code> Create le or wipe existing le
before writing.</li>
<li><code>a</code> or <code>ab</code> Append to end of existing le,
creating if necessary.</li>
<li><code>rt</code> or <code>rbt</code> or <code>rtb</code> Open
existing le for updatereading and writing.</li>
<li><code>wt</code> or <code>wbt</code> or <code>wtb</code> Create le
or wipe existing le before updating.</li>
<li><code>at</code> or <code>abt</code> or <code>atb</code> AppendOpen
or create le for update, writing at end of le.</li>
</ul>
</li>
<li><code>deflt</code> Default filename, in case no parameter called
<code>name</code> is found. If <code>NULL</code>, a filename MUST be
found in the script.
</li>
</ul>
</dd>
</dl>


<h3 class="numbered">Parameter Shortcut Macros</h3>

<p>
To aid access to fields of the parameter
structure, <code>device.h</code> provides shortcut macros to declare
local variables and initialise them with values from their namesake
fields in the parameter structure.
</p>

<ul>
<li>
<code>CONST</code> is used to copy values from <code>S</code> to a
local variable.
</li>
<li>
<code>VAR</code> copies the address of a variable in <code>S</code> to
a local pointer.
</li>
<li>
<code>ARRAY</code> copies the address of the first element of an array
in <code>S</code> to a local pointer.
</li>
</ul>

<h3 class="numbered">The Laws of Devices</h3>

<p>
Beatbox allows simulations to be run on distributed-memory parallel
machines using MPI. Many devices can be run in parallel without
special adaptation, but it’s difficult to tell exactly what will and
won’t work in parallel. The ‘Laws of Devices’ below describe how a
device should behave in order to ensure its safety in parallel. If
these rules aren’t followed, there is a very real chance that your
device will crash horribly in parallel, or worse, quietly produce
incorrect results. Please read and stick to them.
</p>

<ol>
<li>A device must only alter layers of <code>New</code> in its space,
at points in its space.</li>
<li>All operations on <code>New</code> must be commutative — the order
of operation cannot be assumed.</li>
<li>Aside from the permitted regions of <code>New</code>, a device may
only alter the values of local variables or those in its parameter
structure.</li>
<li>Assignments made to a device’s parameter structure must not be
derived from data in <code>New</code>.</li>
<li>Assignments made to a device’s parameter structure must not be
derived from data in its <code>Space</code> structure.</li>
<li>Assignments made to a device’s parameter structure must not be
derived from local minima or maxima
(e.g. <code>local_xmax</code>).</li>
<li>Assignments made to a device’s parameter structure must not be
derived from a random number generator.</li>
<li>From any point in its space, a device may not reference points in
<code>New</code> beyond <code>{x ± 1 ,y ± 1 ,z ± 1}</code>.</li>
<li>A device that references neighbouring points in <code>New</code>
must put the <code>DEVICE_REQUIRES_SYNC</code> macro in
its <code>Create</code> function.</li>
<li>From any point in its space, a device may not reference points in
<code>Geom</code> beyond <code>{x ± 1 ,y ± 1 ,z ± 1}</code>.</li>
<li>Files accessed from a device must only be read.</li> 
</ol>

<p>
If you’re planning on making a device that needs to do something
forbidden by the laws above, it will need to be explicitly
parallelised to run in parallel. Please consult your local MPI
expert. In the meantime, you can enable the device as sequential only,
by going to <code>devlist.h</code> and changing the <code>D</code>
before your device’s name to an <code>S</code>. It’s now one of the
naughty devices.
</p>





<h2 class="numbered"> Specification of Ionic Modules</h2>
<h3 class="numbered">Overview</h3>

<p>
The ionic modules split the system of equation describing the kinetics
of the reaction system according to their type into:
</p>

<ul class="org-ul">
<li>Hodgkin-Huxley type gating variables
<ul class="org-ul">
<li>dependent on membrane voltage (tabulated)
</li>
<li>dependent on other variables (non-tabulated)
</li>
</ul>
</li>
<li>Markov chain models
</li>
<li>"other" (non-gating) variables
</li>
</ul>

<p>
Ionic modules are solved using ruslarsen device, which allows to
exploit specific properties of the specific types of variables by
using exponential integration method. In particular it allows using
Rush-Larsen method for gating variables and Matrix Rush-Larsen method
for Markov chain variables. 
</p>

<h3 class="numbered"> Data Structure of Ionic Modules</h3>
<p>
The device for integration of ionic modules (rushlarsen device) assumes
the data structures as shown on the <a href="#fig:str-ionic">Figure 4</a>.  The top level structure
<code>STR</code> contains an element <code>I</code> which refers to an underlying structure
<code>ionic_str</code>. The structure <code>ionic_str</code> points to <code>channel_str</code> called
<code>channel</code> which contains Markov chains. Each Markov chain is divided
to a number of subchains of type <code>subchain_str</code> to which the
<code>channel_str</code> point through the element named <code>subchain</code>.
</p>


<div id="fig:str-ionic" class="figure">
<p><img src="./imgs/str_ionic.png" alt="str_ionic.png" />
</p>
<p><span class="figure-number">Figure 4:</span> Data structures in rushlarsen device. Elements accepted from <code>BBScript</code> (red font); elements specifying underlying substructures (blue font, with arrow); new elements introduced for the implementation of Markov chain models (gray background).</p>
</div>

<p>
Some elements of the rushlarsen data structure <code>STR</code> can be
provided through parameters of <code>BBScript</code> (in red
on <a href="#fig:str-ionic">Figure 4</a>). The name of the parameter
in <code>BBScript</code>, which initialises an element of the
structure, is normaly identical to the variable name of the element
(except <code>p</code> initialised by <code>par</code>
parameter). Most of the parameters are not required
in <code>BBScript</code>, and when they are missing the element adopts
its default value.
</p>

<p>
The detailed information about the elements initialised from
<code>BBScript</code> can be found
in <a href="#tab:rushlarsen-bbs">this Table</a>. The other elements of
the data structures are used to participate on internal tasks of the
rushlarsen device such as hold intermediate results, look up tables,
or translation a <code>BBScript</code> variables in a different type.
</p>


<h3 class="numbered">C-Preprocessing with Function-Like Macros</h3>

<p>
The function-like macros used in BeatBox are normaly in a format
similar to <code>_(&lt;code1&gt;,&lt;code2&gt;)</code>, where <code>&lt;code1&gt;</code>, and <code>&lt;code2&gt;</code> are
pieces of code. The function like macros are processed by <code>C</code>
preprocessor (cpp) according to the definition of a particular
macro. An example of such definition is:
</p>

<pre class="example">
#define _(variable,initial) var_##variable,
#import "&lt;filename&gt;.h"
#undef _
</pre>

<p>
where the string <code>var_</code> is concatenated with the first argument called
<code>variable</code> (through cpp operator <code>##</code>). During the preprocessing stage
of the compilation the cpp processes the code after the definition
(for instance from the <code>#import "&lt;filename&gt;.h"</code> files) and substitute
each construct a defined expression. For example a code definiting
initial value of membrane voltage: <code>_(V,-80.0)</code> would be substituted
by =var<sub>V</sub>,=.
</p>

<p>
The following code listing illustrates the idea of expansion of
function-like macros included from header files. This case shows for
enumeration of all dynamical variables:
</p>

<pre class="example">
/* Enumerate the dynamical ("state") variables within the vector
   of dynamical variables */
enum {
  #define _(variable,initial) var_##variable,
  #include "&lt;ionic&gt;_other.h"
  #include "&lt;ionic&gt;_ngate.h"
  #include "&lt;ionic&gt;_tgate.h"
  #undef _
  NV            /* total number of variables */
};
</pre>

<p>
Notice, that due to the use of enumeration the <code>var_V</code> can be used
interchangeably with a number corresponding to the position position
of specific function-like macro (starting from <code>0</code>). The value of <code>NV</code>
now corresponds to the total number of dynamical variables. The macro
<code>NV</code> is required by the ionic module. In the same fashion we define
other macros such as number of "other" (<code>NO</code>), tabulated (<code>NT</code>) and
non-tabulated gating variables (<code>NN</code>), as well as number of tabulated
transition rates (<code>NTAB</code>).
</p>

<p>
The counting and initialisation of variables can be done through
including of separate header files named <code>&lt;ionic&gt;_&lt;type&gt;.h</code> into the
main file (<code>&lt;ionic&gt;.c</code>). Here <code>&lt;type&gt;</code> stands for <code>other</code> ("other"
variables), <code>ngate</code> (non-tabulated gating variables), <code>tgate</code>
(tabulated gating variables), <code>par</code> (parameters), <code>fun</code> (other
voltage-dependent tabulated functions). 
</p>







<h3 class="numbered"> IONIC_CREATE_HEAD(&lt;ionic&gt;) and IONIC_CREATE_TAIL(&lt;ionic&gt;)</h3>

<p>
The <code>IONIC_CREATE_HEAD(&lt;ionic&gt;)</code> and <code>IONIC_CREATE_TAIL(&lt;ionic&gt;)</code>
macros define a <code>IonicCreate</code> <code>C</code>-function. Once the macros have been
expanded the name of the <code>C</code>-function becomes <code>create_&lt;ionic&gt;</code>.  The
<code>create_&lt;ionic&gt;</code> is called only once and its purpose is to alocate
memory of the data structures to the default values or to the values
provided from the <code>BBScript</code>.
</p>

<p>
The Markov chains are defined within this function through a template
macro <code>SUBCHAIN(fun_tr, index, min, max, incr, sc)</code>. This assigns the
transition rates function <code>trans_rates_mat</code>, the index of the control
(independent) variable for tabulation <code>i_control</code>, the minimum <code>tmin</code>,
and the maximum <code>tmax</code> limits of the control variable in the table,
the tabulation step <code>tincr</code> on the corresponding tabulation scale and
the scale of the tabulation <code>scale</code>. The predefined macro also
calculates the number of subchains (<code>num_sub</code>) automatically.
</p>


<h3 class="numbered">IONIC_FTAB_HEAD(&lt;ionic&gt;) and IONIC_FTAB_HEAD(&lt;ionic&gt;)</h3>

<p>
The <code>IONIC_FTAB_HEAD(&lt;ionic&gt;)</code> and <code>IONIC_FTAB_HEAD(&lt;ionic&gt;)</code> macros
define <code>IonicFtab</code> <code>C</code>-function which computes the tabulated
transition rates (voltage dependent) of gating variables.  The
dynamical equations of the gating variables have a standard form, so
the time derivative can be inferred from the known form and given
values of transition rates.
</p>

<h3 class="numbered">IONIC_FDDT_HEAD(&lt;ionic&gt;,NV,NTAB,NO,NN) and IONIC_FDDT_TAIL(&lt;ionic&gt;)</h3>

<p>
The <code>IONIC_FDDT_HEAD(&lt;ionic&gt;,NV,NTAB,NO,NN)</code> and
<code>IONIC_FDDT_TAIL(&lt;ionic&gt;)</code> macros define <code>IonicFddt</code> type
<code>C</code>-function. This <code>C</code>-function computing the time derivative of the
non-gating ("other") variables as defined on the right hand side of
the equation and computing the non-tabulated transition rates
(dependent on "other" variables).
</p>

<p>
Once the macros have been expanded the name of the
<code>C</code>-function becomes <code>fddt_&lt;ionic&gt;</code>. The variables in the template of
the macros are the numerical value of total number of variables <code>NV</code>,
the number of voltage-dependent tabulated functions <code>NTAB</code>, the number
of non-gating "other" variables <code>NO</code>, and the number of
"non-tabulated" gating variables <code>NN</code>.
</p>
<h3 class="numbered">CHANNEL_TR_MATRIX(&lt;ionic&gt;_&lt;subchain&gt;)</h3>

<p>
The <code>C</code>-functions to fill transition rates matrices of Markov chains
are generated using a macro <code>CHANNEL_TR_MATRIX(&lt;ionic&gt;_&lt;subchain&gt;)</code>
which defines <code>TransRatesMat</code> <code>C</code>-function. After the macro has been
expanded the name of the <code>C</code>-function becomes <code>&lt;ionic&gt;_&lt;subchain&gt;</code>.
</p>

<p>
The macro <code>_RATE</code> helps to generate <code>TransRatesMat</code> functions that
fills the transition rates matrix of a subchain.
</p>

<pre class="example">
CHANNEL_TR_MATRIX(&lt;ionic&gt;_ical){
  #define v u[0]
  #define _(n,i)
  #define _VFUN(name,expression) real name=expression;
  #define _RATE(from,to,direct,reverse)     \
    TR_MAT(&lt;channel&gt;,from,to,direct,reverse)
  #include "&lt;ionic&gt;_&lt;channel&gt;.h"
  #undef _RATE
  #undef _VFUN
  #undef _
  #undef v
  return 1;
}
</pre>

<p>
The transition rates matrix is constructed from macro
<code>_RATE(from,to,direct,reverse)</code>, where as the name suggest the first
two arguments specify two states <code>from</code>, <code>to</code> between which the
transition rates are defined in <code>direct</code>, and <code>reverse</code> expressions.
</p>

<p>
The diagram <a href="#fig:mc-mat-diag">Figure 5</a> ilustrates the process of filling the
entries of the transition rates matrix. The pannel (a) shows the form
of the function-like macro with arguments. The arguments are
substituted during the preprocessing phase of the compilation with the
names of the states and the expressions for the transtion rates. A
diagram of a part of the Markov chain described by given function-like
macro is shown on the pannel (b). The panel (c) shows the
corresponding entries in the transition rates matrix filled with the
expressions for the transition rates.
</p>


<div id="fig:mc-mat-diag" class="figure">
<p><img src="./imgs/mc_mat_diag.png" alt="mc_mat_diag.png" />
</p>
<p><span class="figure-number">Figure 5:</span> Construction of the transition rates matrix: (a) a form of the function-like macro with arguments; (b) a diagram of the Markov chain (with additional states S<sub>1</sub> and S<sub>2</sub>) corresponding to the function-like macro; (c) part of the transition rates matrix constructed from the function-like macro.</p>
</div>

<p>
In the figure, the possition of the state is given by <code>&lt;channel&gt;_from</code>
and <code>&lt;channel&gt;_to</code> where the <code>from</code> and <code>to</code> are substituted with the
arguments of the function-like macro. 
</p>


<h3 class="numbered"> Minimalist Example of Ionic Module</h3>
<p>
A minimalist example of ionic module including Markov chains can be found in
</p>


<pre>
src/hh52m.c
</pre>    







<h1 class="numbered">Visualisation</h1>

<p>
Beatbox has the functionality to output <code>ppm</code> files which
allow easy visualisation, especially of large data sets. The
visualisation can be further improved using <code>BBXVIEW</code>
package.
</p>

<p>
To convert <code>ppm</code> to <code>jpg/png</code>, use something
like this in a shell script from <code>netpbm</code> and usually 0. If
voltage is being output to the <code>ppm</code> files, then the:
</p>


<pre>
for (( i = $start; i &lt;= $finish; i++))
do
   ppmtojpeg out/ord2_${i}.ppm &gt; jpegs/ord2_${i}.jpg
done
</pre>

<p>
Further, to make an animation,
use <a href="http://www.imagemagick.org">ImageMagick</a> using the
convert command:
</p>
<pre>
convert -delay 20 -loop 0  sphere*.gif animatespheres.gif 
</pre>

<p>
A shell script to handle these tasks will have the following contents: 
</p>
<pre>
#!/bin/bash
for (( i = $start; i &lt;= $finish; i++))
do
   ppmtojpeg out/ord2_${i}.ppm > jpegs/ord2_${i}.jpg
done
#
convert -delay 20 -loop 0  sphere*.gif animatespheres.gif 
</pre>

<p>
You will need to make this shell script executable. For example, if
you save it as myscript.sh, then you need to do the following:
</p>

<pre>
chmod 766 myscript.sh
</pre>

<p>
After this, you can run your script like any other program from
the command line as:
</p>

<pre>
./myscript.sh
</pre>
<p>
<code>ParaView</code> can be used to make animations using the
3D <code>ppm</code> data. To do this, first run the
script <a href="ppmx2paraview">ppm_2_paraview</a>. This perl script
needs the inputs bgr bgg bgb channel threshold
<code>filename.ppm</code> where the rgb values are from the bbs file,
or default values <code>(255 255 255)</code>. The channel is again
from the bbs file threshold is usually around 127. Once the vtk files
are produced in this manner, use paraview to prepare the visualisation
interactively using the first file. An output to animation will then
produce the desired
<code>jpeg</code>s / <code>tiff</code>s
/ <code>png</code>s. Use <code>convert</code> from ImagemMagick to make
a low maintainence animated <code>gif</code> that can be put into
powerpoint or web pages.
</p>

<h1 class="numbered">Advanced</h1> 
<p>
call graphs to show how the code works for developer's.
</p>

<h1 class="numbered">How to implement a CellML cell model into Beatbox</h1>

<p>
Following is a method involving minimal manipulation of CellML cell
model code to incorporate it into Beatbox format. We use the
OHara-Rudy 2011 model as an example to illustrate the method.
</p>

<h2>Step 1: Get the CellML file</h2> 

<p>
Published cardiac and other simulation models are distributed by means
of the CellML Project website, that can be found
here: <a href="http://www.cellml.org/" target="_blank">CellML Project</a>. In
particular, the cell models are listed in the
repository: <a href="http://models.cellml.org/cellml" target="_blank">CellML
Repository</a>. The desired CellML file should be downloaded from the
repository. The file that we are looking for is usually has an
extension of <code>.cellml</code>. As an example, the OHara-Rudy (ORd)
cell model file looks like this: <a href="Ohara_Rudy_2011.cellml" target="_blank">ORd
CellML file</a>. There are other formats in which the cell model may
be provided (C, C++, MATLAB,...) and the best location to get the
CellML file is from the provided tar.gz download all files section.
</p>

<h2>Step 2: Convert the CellML file to C code</h2>

<p>
The information in the CellML file obtained as in Step 1 needs to be
converted into suitable C format. In principle, the converted codes
as delivered by the CellML website may be sufficient. However, to
obtain all the information required to construct the cell model in
Beatbox format (i.e. initial conditions and the algebraic-differential
equations for the model dynamics) is ideally obtained by means of COR
software. COR (Cellular Open Resource) is primarily a Windows
software, but may be installed on Linux and MAC-OS if the operating
system is 32 bit or if there are 32 bit emulators available. As of the
date of this document, a Linux variant is also being developed. So the
next thing to do is download and
install <a href="http://www.opencor.ws/cor/index.html"  target="_blank">COR</a>.
Once it is
installed, open the CellML file that you downloaded in Step 1 and
export it to C. The exported files are a <code>.c</code> and
a <code>.h</code> with the same name as the CellML file. For example,
the ORd exported files
are: <a href="Ohara_Rudy_2011.c" target="_blank">Ohara_Rudy_2011.c</a>
and <a href="Ohara_Rudy_2011.h" target="_blank">Ohara_Rudy_2011.h</a>.
</p>

<h2>Step 3: Define the constant modelling default
parameters</h2>

<p>
The header file as exported in Step 2 simply declares all constants
and variables. The format that the declarations appear in the header
file depend on the original CellML file and how the model authors
provided the original codes to CellML. In the C file
(<code>Ohara_Rudy_2011.c</code> in our case), there is hopefully an
annotated section (called "Constants" or similar) that shows the model
constants and this section should be identified. It should be borne in
mind that these constants should be simply numerical assignments to
place holders, i.e. a formula should not appear on the right hand side
of these assignments. Further, due to the Beatbox format, these
modelling constants should all be real (i.e. <code>float</code>
or <code>double</code>) numbers. All derived constants and integer
constants are handled otherwise (see below).
</p>

<p>
Take this list of constants and put them in a file called, say
<code>ord_par.h</code>. The format of the list of constants should be further
manipulated such that Beatbox macro's can do what they should do. The
final <code>ord_par.h</code> should look like
this: <a href="ord_par.h" target="_blank">ord_par.h</a>.
</p>

<h2> Step 4: Define the initial conditions to the model</h2>

<p>
A <code>void init(void)</code> (or similarly named function) is
provided4 in the exported C file. Contents of this function without any
alterations should be copied to another file. In the ORd example, we
choose to call this file <code>ord_init.h</code>. Note that none of
the contents of the initialisation have been altered. The exported C
file probably (hopefully) uses a vector to maintain values of dynamic
variables, and that should also be retained to reduce manipulation of
original code. The prepared <code>ord_init.c</code> file can be found
here: <a href="ord_init.h" target="_blank">ord_init.h</a>. Note that unlike in the
parameter file of Step 3, the code in the initialisation has not been
manipulated at all.
</p>

<h2> Step 5: Define the actual model calculation</h2>

<p>
After having defined the constant real parameters and assigned initial
values to the dynamic variables vector, we now construct the code that
will be used for the actual cell model integration. This step starts
with identifying the function called void compute(double t) or similar
in the exported C file. The contents of this function should be
imported into another header file, say called ord_step.h. You may
notice that in this code, there are several derived variables
(e.g. currents, fluxes,...), integer constants, etc. These derived
variables are typically declared as "Computed Variables" or with
similar annotation. These declarations should be put at the top before
the model code. The resulting <code>ord_step.h</code> look like this:
<a href="ord_step.h" target="_blank">ord_step.h</a>.
Thus obtained code may be slightly optimized by hand by replacing
<code>pow</code> function with integer exponents, which is not
efficient in C, with inline C macros, such as
<a href="../src/ord_step.h" target="_blank">ord_step.h</a>.
Note that no integration (forward
Euler or otherwise) is included in this <code>ord_step.h</code>; this
is simply the code for computing the right-hand sides of the
differential equations. These are stored in a vector called dY[] may also be found in this code. We will deal with
this in a bit.
</p>

<h2> Step 6: Update rhslist.h</h2>

<p>
The list of RHS of cell models needs to be updated. This list is in:
</p>

<ul>
<li><code>Beatbox/src/rhslist.h</code></li>
</ul>

<p>
of the package. Code, similar to what is shown below, should be added
to this file:
</p>

<pre>
   D(ord)
</pre>

<p>
Explanations on the meaning of the macro D, the choice of names
etc. are to be found in the developers guide.
</p>

<h2> Step 7: Define the wrapper for the model simulation</h2>

<p>
The main C wrapper that initialises, declares local placeholders, and
provides the cell model code to the Euler solver is given a consistent
name. For example, in case of ORd, it is simply called <code>ord.c</code>. This
wrapper contains headers, macros, and basically includes the code from
the above files. 
</p>

<ul>
<li>
To begin with, the file contains several generic headers, and if
required, the cell model specific headers.
</li>
<li>
Then the number of dynamic variables should be defined, typically
using a <code>#define N</code> directive.
</li>
<li>
Next, a structure is declared that includes the parameter file, and
other modelling parameters. For cell models, this is typically the
(constant) time step and the stimulus current variable. Using
the <code>RHS_CREATE_HEAD</code> macro, we initialise members of the
structure with constant parameters and initial values using the files
that we created above. In the <code>RHS_RUN</code> macro, first the
parameters are declared as part of the structure <code>S</code>. Since
the local vector of variables is probably called something different
from <code>u[]</code> (probably <code>Y[]</code>), we make that
association here.
</li>
<li>
The next thing to do is simply include the <code>_step.h</code>. If
required, add the current stimulus to the appropriate ODE variable and
then the macro can be closed.
</li>
</ul>
The result can be seen <a href="ord.c" target="_blank">here</a>. 


<h2> Step 8: Update the Makefile.am</h2>

<p>
There is a <code>Makefile.am</code> in the <code>Beatbox/src</code>
directory. Add entries for <code>_step.h</code>, 
<code>_init.h</code>, <code>_par.h</code>, and <code>.c</code> files
that you have just created. Save, do a distclean, configure, and make
again. Hopefully, it all compiles. To start using the cell model, make
a <code>bbs</code> file as shown in the template below.
</p>

<h2> Step 9: Make a bbs file to simulate the AP</h2>

A <code>bbs</code> file example:
<a href="ord0.bbs" target="_blank">ord0.bbs</a>.
Use it to test the new device by generating an action potential. 



<h1 class="numbered">A Practical Guide for Automake if you add new modules</h1>

<p>
The inclusion of cellular modules into BeatBox requires changes of BeatBox source files and files of the GNU build system of BeatBox <code>configure.ac</code> (the suffix is an abreviation from Autoconf) and <code>Makefile.am</code> (the suffix is an abreviation from Automake). Those files are used to create configuration <code>configure</code> and build script <code>Makefile</code>.
</p>

<p>
The building of a new ionic module starts by including its name into the <code>ioniclist.h</code> in a form <code>D(&lt;ionic&gt;)</code>.
</p>

<pre class="example">
D(hh52)
  D(hh52m)
</pre>

<p>
The building of a new rhs module starts by including its name into the <code>rhslist.h</code> in a form <code>D(&lt;rhs&gt;)</code>.
</p>

<pre class="example">
#if HH
  D(hh)
#endif
</pre>

<pre class="example">
#define HH 1
</pre>

<p>
The main module file contains formal definition of the model. It is expected in the file <code>&lt;name&gt;.c</code>. The time stepping devices require the module module to initialise specific structures and functions.
</p>

<p>
All files used in for the implementation of those modules have to be listed within <code>common_sources</code> variable in <code>src/Makefile.am</code> in BeatBox root directory:
</p>

<pre class="example">
common_sources = \
  hh52.c hh52_other.h hh52_tgate.h hh52_par.h hh52_ftab.h\
  hh52m.c hh52m_ik.h hh52m_ina.h\
  hh.c \
  hh.h \
</pre>

<p>
this file maintains the list of the source files. The Automake takes care of generating the =Makefile=s specific for build on a target computer architecture, that BeatBox executable is aimed for. This allows for portability of the code to a large variety of different machines.
</p>

<p>
The template files <code>Makefile.am</code> and <code>configure.ac</code> (not modified in this example) are processed to generate and install corresponding <code>configure</code> and <code>Makefile</code> in the appropriate directories. This is done by a command
</p>

<pre class="example">
autoreconf -fi
</pre>

<p>
in the root directory of BeatBox (<code>-f</code> for force, <code>-i</code> for install).
</p>


<h1 class="numbered">Bash / perl scripting for increased Beatbox
functionality
</h1>

<p class="quest">
Content to be added.
</p>

<h1 class="numbered">Beatbox Device Reference</h1>

<!-- ======================== --> 
<h2 class="numbered">activation</h2>
<h3>Overview</h3>

<p> This is a computational device, which computes and stores
activation times at all points in the grid, within its space. The
activation time at a point of the grid is defined as the most recent
moment when the value of a certain field at that point has crossed a
given value in a given direction. The typical intended use is that the
"certain field" is the transmembrane voltage. The activation times are
in terms of the integer counter <code>t</code>, but their values are
real, and defined by linear interpolation between the current and the
previous value of the selected field at the given point. If activation
times in terms of the model time are required, these values should be
properly interpreted, typically just multiplied by the time
step. Since the device needs the current and the immediately preceding
values of the given field, it should be run at continuous time
intervals for correct work.  </p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>

  <td><code>int</code></td><td><code>v0</code></td><td> The layer
  containing the field used for definining the activation time,
  e.g. the transmembrane voltage layer.</td>

</tr><tr>

  <td><code>int</code></td><td><code>v1</code></td><td> The layer used
  for storing the computed activation times. Must be different from
  <code>v0</code>.</td>

</tr><tr>

  <td><code>int</code></td><td><code>vd</code></td><td> An auxiliary
  layer, used for storing previous values of the field. Must be
  different from both <code>v0</code> and <code>v1</code>, and must
  not be modified by any other devices. In particular, it should be
  outside the range of layers used by the cell model(s).</td>

</tr><tr>

  <td><code>real</code></td><td><code>threshold</code></td><td>Activation
  is the event when the selected field crosses this value, in the
  direction defined by the next parameter, <code>sign</code>.</td>

</tr><tr>

  <td><code>int</code></td><td><code>sign</code></td><td>Only the sign of
  this parameter matters. If positive, activation is defined when the
  selected field value crosses the threshold value upwards; if
  negative, activation is when the value crosses the threshold downwards;
  if zero, then crossing in either direction will be counted as
  activation.</td>

</table>

<p>
All parameters are mandatory.
</p>

<h3>Typical Syntax</h3>

<pre>activation v0=[Volt] vd=[p] v1=[a] threshold=Vact sign=1;</pre>

<p>
where string macro <code>[Volt]</code> contains the number of the
layer used for storing transmembrane voltage, <code>[p]</code> and
<code>[a]</code> are layers outside the kinetic model, where layer
<code>[a]</code> will contain the most recent activation times in all
points through which the excitation wave passed at least
once. Excitation wave is considered to have passed through a point
when the voltage at that point crossed the value given by the
previously assigned k-variable <code>Vact</code> upwards.
</p>

<h3>Instances in Example Scripts</h3>

<pre>
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttp06/benchmark.bbs
</pre>

<p>
This script can be run e.g. using the following command:
</p>

<pre>
Beatbox_SEQ benchmark.bbs 0.5.bbg 0.5 0.05 0.5_0.05.dat
</pre>

<p>
where <code>0.5.bbg</code> is the geometry file, 0.5 and 0.05 are
space and time discretization steps, and <code>0.5_0.05.dat</code> is
the output file where the results of the benchmark will be stored.
More results will be also stored in files in the subdirectory
<code>0.5_0.05.dat.dir</code>.  See the <code>Makefile</code> and
<code>eport.pdf</code> in that directory for more details.
</p>

<!-- ======================== --> 
<h2 class="numbered">adi3d</h2>
<h3>Overview</h3>

<p> This is a computational device, which performs an
alternating-direction implicit (ADI) timestep for an isotropic
diffusion operator with Neumann boundary conditions in box geometry in
3D.  We use the Brian algorithm as described e.g. in Carnahan et
al. book for implicit solution of heat equation (eqn. 7.56 on page
453).


<h3>Parameters</h3>

<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>

  <td><code>int</code></td><td><code>v0</code></td><td> The layer
    containing the diffusive field.</td>
    
</tr><tr>
    
  <td><code>int</code></td><td><code>v1</code></td><td> An auxiliary layer, used
    for intermediate ADI calculations. Must be different from
    <code>v0</code>.</td>
      
</tr><tr>
      
  <td><code>real</code></td><td><code>ht</code></td><td>
    Time step.
  </td>
  
</tr><tr>
      
  <td><code>real</code></td><td><code>hx</code></td><td>
    Space step.
  </td>
      
</tr><tr>
      
  <td><code>real</code></td><td><code>D</code></td><td>
    Diffusion coefficient.
  </td>
      
</tr><tr>     
</table>

<p>
All parameters are mandatory.
</p>

<h3>Typical Syntax</h3>

<pre> adi3d v0=[u] v1=[aux] D=D hx=hx ht=ht; </pre>

<p>
where string macro <code>[u]</code> contains the number of the
layer used for storing the diffusive field (say the transmembrane
voltage),
<code>[aux]</code> is a layer outside the kinetic model, and
<code>D</code>, <code>hx</code> and <code>ht</code> are k-variables
for the diffusion coefficient, space step and time step. 
</p>

<h3>Instances in Example Scripts</h3>

<pre>
beatbox/data/scripts/sequential/Barkley_model/implicit.bbs
</pre>

<p>
This script can be run using the following command:
</p>

<pre>
Beatbox_SEQ implicit.bbs
</pre>

<p>
and the directory containing this script also contains the
pre-requisite file <code>bkl1.rec</code>.
It also contains Perl script <code>view.pl</code>.
To view the result of simultion, 
you say in that directory: 
</p>
<pre>
./view.pl implicit.dir
</pre>
<p>
on the command line. 


<!-- ========================= -->
<h2 class="numbered">clock</h2>
<h3>Overview</h3>
<p>
Prints the current integer timestep to <code>stdout</code> and VGA graphics
window. 
</p>
<h3>Parameters</h3>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>int</code></td><td><code>when</code></td><td>rate of output</td>
</tr><tr>
<td><code>int</code></td><td><code>col0</code></td><td> starting column of VGA
  graphics window (measured in characters).</td>
</tr><tr>
<td><code>int</code></td><td><code>row0</code></td><td> starting row of VGA
  graphics window (measured in characters).</td>
</tr><tr>
<td><code>int</code></td><td><code>color</code></td><td> Color code of line graphics.</td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The clock device is mainly used during simulations with run time VGA graphics.
The typical syntax of <code>clock</code> device is as follows.
The clock device is mainly used during run time graphics simulations.
The typical syntax of <code>clock</code> device is as follows.
</p>

<pre>
clock when=often color=WHITE row0=10 col0=20; 
</pre>

<h3>Instances of clock in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs
</pre>
The inputs, outputs, and methods of running for fhn0-fhn2.bbs
have been described in previous sections. 

<!-- ========================= -->
<h2 class="numbered">ctlpoint</h2>
<h3>Overview</h3>

<p>
Saves the entire simulation state for disaster recovery, or to
facilitate a branching point in long simulations.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>str</code></td><td><code>file</code></td><td> Control point
file to be restored from / saved to.</td>
</tr><tr>
<td><code>int</code></td><td><code>enrich</code></td><td> Can the
restored control point define k variables not present in the script.</td>
</tr>
</table>

<!-- ========================= -->
<h2 class="numbered">d_dt</h2>
<h3>Overview</h3>

<p>
Computes the time derivative of a layer (dynamical variable) at a
given location.
</p>

<h3>Parameters</h3>
<p>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>real</code></td><td><code>ht</code></td><td> time step</td>
</tr><tr>
<td><code>int</code></td><td><code>vd</code></td><td>Dynamical variable for which derivative is sought.</td>
</table>
<h3>Typical Syntax</h3>
d_dt ht=ht vd=1;
<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/sequential/FitzHughNagumo_model/fhn2.bbs
</pre>

<p>
The inputs, outputs, and method of simulation for fhn2.bbs have been
described above.
</p>

<!-- ========================= -->
<h2 class="numbered">diff</h2>
<h3>Overview</h3>
<p>
Computes the Laplacian (or Laplacian-Beltrami for anisotropic case),
with Neumann (resp. non-flux) boundary conditions.
</p>
<h3>Parameters</h3>

<p>
<code>diff</code> must be used with the default
space. The <code>v0</code> space parameter is used to indicate the
diffused variable, usually the transmembrane
voltage. The <code>v1</code> space parameter is used to indicate the
layer in which the Laplacian should be stored.
</p>

<table border="1">
<tr>
<th>Type</th><th> Name </th><th> Description</th>
<th>Isotropic or Anisotropic</th>
</tr><tr>

  <td><code>int</code></td><td><code>v0</code></td><td>
    The layer containing the diffusive field.
  </td><td>Both</td>
    
</tr><tr>
    
  <td><code>int</code></td><td><code>v1</code></td><td>
    The layer that will contain the Laplacian of the diffusive field.
    Must be different from <code>v0</code>.
  </td><td>Both</td>
      
</tr><tr>
      
</tr><tr>
  
  <td><code>real</code></td><td><code>hx</code></td><td>
    Space step.
  </td><td>Both</td>
      
</tr><tr>

  <td><code>real</code></td><td><code>D</code></td><td>
    Isotropic diffusion coefficient.
  </td><td>Isotropic only</td>
  
</tr><tr>
  
  <td><code>real</code></td><td><code>Dpar</code></td><td>
    Anisotropic diffusion coefficient parallel to the fibres.
  </td><td>Anisotropic only</td>
  
</tr><tr>
  
  <td><code>real</code></td><td><code>Dtrans</code></td><td>
    Anisotropic diffusion coefficient in the transverse direction,
    perpendicular to the fibres.
  </td><td>Anisotropic only</td>

</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>diff</code> device is as follows. Assuming
that the diffusing layer is <code>diff_layer</code> (a number) and the
layer in which the Laplacian is to be stored
is <code>lap_layer</code>, the syntax for the isotropic diffusion is:
</p>

<pre>
diff v0=diff_layer v1=lap_layer D=D hx=hx;
</pre>

<p>
where uniform diffusion is used throughout the tissue. In case of
anisotropic diffusion, the syntax changes to account for diffusion
parallel to the fibres (signified by <code>Dpar</code>) and transverse
to the fibres (signified by <code>Dtrans</code>) and is:
</p>

<pre>
diff v0=diff_layer v1=lap_layer Dpar=D Dtrans=D/4 hx=hx;
</pre>

<h3>Instances of diff in Example Scripts</h3>

<p>
All example scripts can be found in <code>beatbox/data/scripts</code> of the
distribution package. Examples of <code>dump</code> device can be
found in the following:
</p>

<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
beatbox/data/scripts/sequential/LRD_model/LRD_ffr.bbs
</pre>

<p>
and for the anisotropic case can be found in
</p>

<pre>
beatbox/data/scripts/sequential/LRD_model/LRD_ffr.bbs
</pre>

<p>
The inputs, outputs, and method of simulation
for <code>fhn1.bbs</code>, <code>fhn2.bbs</code>, and
<code>LRD_ffr.bbs</code> have been described above.
</p>


<!-- ========================= -->
<h2 class="numbered">diffstep</h2>
<h3>Overview</h3>
<p>
As <code>diff</code> device, but in addition to calculating  the
diffusion operator &nabla;<i>D</i>&nabla;<i>V</i>,
it implements the explicit Euler timestep with this operator for the
diffused variable. That, is, if the diffusive variable is <i>V</i> and
the time step is <code>ht</code>, then after this
device's work, the field in the <code>diff_layer</code> will be
incremented by <code>ht</code> times the Laplacian. 

<p class="math" align="center">
<i>V</i>(<i>x</i>,<i>y</i>,<i>z</i>,<i>t</i>)
&nbsp;&rightarrow;&nbsp;
<i>V</i>(<i>x</i>,<i>y</i>,<i>z</i>,<i>t</i>+<i>h</i><sub><i>t</i></sub>)
&nbsp;=&nbsp;
<i>V</i>(<i>x</i>,<i>y</i>,<i>z</i>,<i>t</i>)
+
<i>h</i><sub><i>t</i></sub>
&nabla;(<i>D (<i>x</i>,<i>y</i>,<i>z</i>)</i>&nabla;<i>
V(<i>x</i>,<i>y</i>,<i>z</i>,<i>t</i>)
</i>)
<br/>
</p>

Hence this device can be used to make the diffusion substep in an
operator-splitting scheme, without the need to transfer the values of
the Laplacian to the timestepper for the reaction term. 

<h3>Parameters</h3>

<p>
<code>diffstep</code> must be used with the default
space. The <code>v0</code> space parameter is used to indicate the
diffused variable, usually the transmembrane
voltage. The <code>v1</code> space parameter is used to indicate the
layer in which the Laplacian should be stored.
</p>

<table border="1">
<tr>
<th>Type</th><th> Name </th><th> Description</th>
<th>Isotropic or Anisotropic</th>
</tr><tr>

  <td><code>int</code></td><td><code>v0</code></td><td>
    The layer containing the diffusive field.
  </td><td>Both</td>
    
</tr><tr>
    
  <td><code>int</code></td><td><code>v1</code></td><td>
    The layer that will contain the Laplacian of the diffusive field.
    Must be different from <code>v0</code>.
  </td><td>Both</td>
      
</tr><tr>
      
  <td><code>real</code></td><td><code>ht</code></td><td>
    Time step.
  </td><td>Both</td>
  
</tr><tr>
  
  <td><code>real</code></td><td><code>hx</code></td><td>
    Space step.
  </td><td>Both</td>
      
</tr><tr>

  <td><code>real</code></td><td><code>D</code></td><td>
    Isotropic diffusion coefficient.
  </td><td>Isotropic only</td>
  
</tr><tr>
  
  <td><code>real</code></td><td><code>Dpar</code></td><td>
    Anisotropic diffusion coefficient parallel to the fibres.
  </td><td>Anisotropic only</td>
  
</tr><tr>
  
  <td><code>real</code></td><td><code>Dtrans</code></td><td>
    Anisotropic diffusion coefficient in the transverse direction,
    perpendicular to the fibres.
  </td><td>Anisotropic only</td>

</tr>
</table>

<h3>Typical Syntax</h3>

<p>
is very similar to <code>diff</code>, only it should contain
<code>ht=</code> definition; otherwise parameter <code>ht</code> will
be assume the default value of zero and the work of this device will
be identical to that of <code>diff</code> only slightly less
efficient. So, assuming
that the diffusing layer is <code>diff_layer</code> (a number) and the
layer in which the Laplacian is to be stored
is <code>lap_layer</code>, the syntax for the isotropic diffusion is:
</p>

<pre>
diffstep v0=diff_layer v1=lap_layer D=D hx=hx ht=ht;
</pre>

<p>
where uniform diffusion is used throughout the tissue. In case of
anisotropic diffusion, the syntax changes to account for diffusion
parallel to the fibres (signified by <code>Dpar</code>) and transverse
to the fibres (signified by <code>Dtrans</code>) and is:
</p>

<pre>
diffstep v0=diff_layer v1=lap_layer Dpar=D Dtrans=D/4 hx=hx ht=ht;
</pre>

<p>
Notice that if a positive value for <code>ht</code> is given then after this
device's work, the field in the <code>diff_layer</code> will be
incremented by <code>ht</code> times the Laplacian, and the layer
<code>diff_layer</code> may be recycled for another purpose, say as a
Laplacian layer for another diffusion device. 
</p>

<p>
CAVEAT: in the (straightforward) operator-splitting schemes, the value of parameter
<code>ht</code> in this device should, obviously, be equal to the time
step used in the devices that do other substeps (unless the contrary
is required by a more sophisticated operator-splitting scheme
e.g. Strang splitting, where some of the substeps are done with time
step <code>ht/2</code>). 

If <code>ht=0</code> (which is the default value), then the contents
of the layer <code>diff_layer</code> will remain unchanged, and the
only result of the work of the <code>diffstep</code> device will be
the values of the Laplacian stored in the layer
<code>lap_layer</code>, i.e. the outcome will be identical to that of
a <code>diff</code> device.


<h3>Instances of diff in Example Scripts</h3>

<p>
All example script can be found in data/scripts of the package
distribution:
following:
</p>

<pre>
beatbox/data/scripts/sequential/CRN/compare1D.bbs
</pre>

<p>
This script is considered in detail in the section for the
<code>rushlarsen</code> device. 
</p>


<!-- ========================= -->
<h2 class="numbered">dump</h2>
<h3>Overview</h3>

<p>
Writes the contents of the simulation medium within its space to a
binary file.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr><tr>
<td><code>str</code></td><td><code>file</code></td><td> Relative path
to the dump file.</td>
</tr><tr>
<td><code>int</code></td><td><code>append</code></td><td> Should the
file be appended to?</td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>dump</code> device is as follows. Assuming
that the dynamical layers are between <code>ode_layer0</code> (a
number) and the layer <code>ode_layer1</code> the syntax for the dump
device is:
</p>

<pre>
dump when=end v0=ode_layer0 v1=ode_layer1 append=0 file=my_dump_file.dmp;
</pre>

<h3>Instances of dump in Example Scripts</h3>

<p>
All example scripts can be found in <code>beatbox/data/scripts</code> of the
distribution package. Examples of <code>dump</code> device can be
found in the following:
</p>

<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
beatbox/data/scripts/sequential/LRD_model/LRD_ffr.bbs
</pre>

<p>
The simulation state saved in such a manner may be used to continue
the simulation using the <code>load</code> device.  The inputs,
outputs, and method of simulation for <code>fhn1.bbs</code> and
<code>LRD_ffr.bbs</code> are described elsewhere in this document. 
</p>



<!-- ========================= -->
<h2 class="numbered">elliptic</h2>

<h3>Overview</h3>

<p> Solves an elliptic problem (Poisson equation) for the
Laplace-Beltrami operator corresponding to the fiber direction field
of the current geometry and given diffusion coefficients along and
across fibers (as in <code>diff</code> device). The primary intended
use is calculation of the extracellular (or intracellular) potential
field for a given transmembrane field in the bidomain model.  The
method of solution is Full Multigrid with vertex-centered
restrition/prolongation operators with bi/tri-linear interpolation,
and (multicoloured) Gauss-Seidel or Jacobi smoother. Can be used
either for Dirichlet boundary conditions, where boundary values are
those that are just outside the device box, or Neumann boundary
conditions. In the latter case, this will require an extra "pinning"
condition, to select a unique solution out of infinitely many: the
solution at a given point should have a given value. 

</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Default</th><th>Description</th>
</tr><tr>
  
<td><code>real</code></td><td><code>Dpar</code></td><td>-</td><td> Anisotropic
diffusion coefficient parallel to the fibres.</td>
</tr><tr>

<td><code>real</code></td><td><code>Dtrans</code></td><td>-</td><td> Anisotropic
diffusion coefficient in the transverse direction, perpendicular to
the fibres.</td>
</tr><tr>

<td><code>real</code></td><td><code>hx</code></td><td>-</td><td> Space
step.</td>
</tr><tr>

<td><code>real</code></td><td><code>tolerance</code></td><td>-</td><td> One step
  tolerance: if maximal pointwise change of solution during one
  iteration, the iterations are considered converged. 
</td>
</tr><tr>

<td><code>int</code></td><td><code>maxiter</code></td><td>-</td><td>
  Maximal number of final iterations after the Full Multigrid cycle. 
</td>
</tr><tr>

<td><code>int</code></td><td><code>maxiter</code></td><td>-</td><td>
  Maximal number of final iterations after the Full Multigrid cycle. 
</td>
</tr><tr>

<td><code>int</code></td><td><code>pin</code></td><td> 0 </td><td>
  If nonzero, then a pinning condition will be engaged.
</td>
</tr><tr>

<td><code>int</code></td><td><code>xpin</code></td><td>-</td><td>
  x-coordinate of the pinning point.
</td>
</tr><tr>

<td><code>int</code></td><td><code>ypin</code></td><td>-</td><td>
  y-coordinate of the pinning point.
</td>
</tr><tr>

<td><code>int</code></td><td><code>zpin</code></td><td>-</td><td>
  z-coordinate of the pinning point.
</td>
</tr><tr>

<td><code>real</code></td><td><code>upin</code></td><td>-</td><td>
  The pinning value. 
</td>
</tr><tr>

<td><code>int</code></td><td><code>upper_level</td><td></code>-1</td><td>
  The maximal number of lavels in multigrid.
  The original (basic) grid is at level 0, and each next level has the
  number of points in each dimension approximately twice smaller.
  When this parameter is 0 or -1, straightforward iterations at basic
  level (i.e. without multigrid) are performed; only for <code>upper_level=-1</code> they are
  performed right with the <code>New</code> array, whereas for
  <code>upper_level=0</code> the right-hand side and solution data are copied to a from the
  separate structures designed for multigrid. 
</td>
</tr><tr>

<td><code>string</code></td><td><code>smoother</code></td><td><code>GS</code></td><td>
  Name of the smoother used at each iteration.
  This can be either <code>Jacobi</code>, or <code>GS</code> for Gauss-Seidel.
</tr><tr>
  
<td><code>string</code></td><td><code>transfer</code></td><td><code>correct</code></td><td>
  The method of transfer of the problem from one level to the other.
  Can be either <code>transfer</code> or <code>correct</code>.
  In case of <code>transfer</code>, all levels compute the same
  problem but at different discretization. In case of <code> correct
  </code>, higher levels compute corrections to the lower-level solutions.
</tr><tr>

<td><code>real</code></td><td><code>damping</code></td><td><code>1.0</code></td><td>
  Relaxation coefficient. Normally <code>damping=1</code>. If
  <code>0&lt;damping&lt;1</code>, the iterations are done half-way; use
  <code>damping&gr;1</code> for the successive over-relaxation (not
  recommended when multigrid is engaged). 
</tr><tr>

<td><code>real</code></td><td><code>delta</code></td><td><code>1.0</code></td><td>
  Tolerance factor for multigrid. The tolerance of iterations of the
  next level is <code>delta</code> times bigger than the tolerance
  of the previous level. 
</tr><tr>

<td><code>int</code></td><td><code>FMGlevel</code></td><td><code>upper_level</code></td><td>
  The range of the Full Multigrid (Nested) iterations. 
</tr><tr>

<td><code>int</code></td><td><code>vcycles</code></td><td><code>1</code></td><td>
  The number of V-cycles per one nested iteration.
</tr><tr>

<td><code>int</code></td><td><code>preiter</code></td><td><code>maxiter</code></td><td>
  The number of pre-iterations in a V-cycle.
</tr><tr>

<td><code>int</code></td><td><code>postiter</code></td><td><code>maxiter</code></td><td>
  The number of post-iterations in a V-cycle.
</tr><tr>

<td><code>int</code></td><td><code>postiter</code></td><td><code>maxiter</code></td><td>
  The number of post-iterations in a V-cycle.
</tr><tr>

<td><code>int</code></td><td><code>tol0, tol1,
  ...</code></td><td>(same from prev level)</td><td>
  parameter <code>tol</code> can be specified for individual multigrid
  levels 0, 1, ...
</tr><tr>

<td><code>int</code></td><td><code>preiter0, preiter1,
  ...</code></td><td>(same from prev level)</td><td>
  parameter <code>preiter</code> can be specified for individual multigrid
  levels 0, 1, ...
</tr><tr>

<td><code>int</code></td><td><code>postiter0, postiter1,
  ...</code></td><td>(same from prev level)</td><td>
  parameter <code>postiter</code> can be specified for individual multigrid
  levels 0, 1, ...
</tr><tr>

<td><code>str</code></td><td><code>debug</code></td><td>-</td><td>
  Relative path
to output file for debugging purposes. If <code>stdout</code>, will
print to screen of the parent shell.</td>
</tr><tr>

<td><code>str</code></td><td><code>profile</code></td><td>-</td><td>
  Relative path
  to output profiling information. This will measure separately time spent at
  each of the levels of the multigrid (and noticeably slow down
  computations). Now is available only in sequential mode. 
  If <code>stdout</code>, will
print to screen.</td>
</td>
</tr><tr>

</table>

<h3>Typical Syntax</h3>

<p>
see in the example of use referred to below.
</p>

<h3>Instances of <code>elliptic</code> in Example Scripts</h3>

An examples of <code>elliptic</code> device can be found in the following:
<pre>
beatbox/data/scripts/sequential/ZFK_model/zfkmod2.bbs
</pre>
It does not require command-line parameters so can be run e.g. by
<pre>
Beatbox_SEQ zfkbid2.bbs
</pre>

This calculates a bidomain model with the one-component Zeldovich-Frank-Kamenetsky (a.k.a.
Nagumo) kinetics, with initial and (Dirichlet) boundary conditions
chosen in such a way as to accommodate an exact analytical solution
for a front propagating at the angle of 30 degrees wrt the x-axis. 
For comparison, there is a file <code>zfkmod2.bbs</code> script in the
same directory, which solves a similar problem in the monodomain
formulation. 

<!-- ========================= -->
<h2 class="numbered">euler</h2>

<h3>Overview</h3>
<p>
General pointwise ODE stepper for the rhs modules.
</p>

<h3>Parameters</h3>

<table border="1">
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>ht</code></td>
<td class="left">Timestep duration.</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>ode</code></td>
<td class="left">Name of the RHS module to use.</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>rest</code></td>
<td class="left">If nonzero, the device will make so many steps with the given model to find an approximation of the initial conditions, and then fill the whole device space with this initial condition.</td>
</tr>

<tr>
<td class="left"><code>codeblock</code></td>
<td class="left"><code>par</code></td>
<td class="left">The parameters of the RHS module; their list depends on the module. The codeblock contains k-assignments of the form <code>&lt;parameter&gt;=&lt;k-expression&gt;</code>, separated by blank spaces.</td>
</tr>
</tbody>
</table>

<p>
The parameter <code>ht</code> defines a duration of one time step used in forward
Euler calculations.
</p>

<p>
The parameter <code>ode</code> is a name of the rhs module that implements the
cellular kinetics. This module is used for the simulation. The <code>ode</code>
model has to follow the rhs format.
</p>

<p>
The parameter <code>rest</code> is used if the device determines the initial
conditions of the dynamical variables by a steady state
approximation. The device runs the simulation for the number of steps
specified in <code>rest</code> using the initial conditions as specified in the
code of <code>rhs</code> module. 
</p>

<p>
Model dependent parameters of rhs module are passed to euler device
through the <code>par</code> parameter in <code>BBScript</code>. The assignment has to
follow the format <code>{&lt;parameter&gt;=&lt;value&gt;}</code> (within curly brackets <code>{}</code>
as shown). When multiple parameters are assigned, their definition
must be all given within the same curly brackets and each assignment
must be separated by a blank space (such as space, or newline).
</p>

<h3>Typical Syntax</h3>

<p>
The typical syntax of euler device is as follows. Assuming that the
ODE layers are between <code>ode_layer0</code> (a number) and the layer
<code>ode_layer1</code>, the ODE module (i.e. cell model) that you are using od
ode\<sub>module</sub>, and the user defined model parameters are defined in bbs
parameters p1, and p2, the syntax is:
</p>

<pre class="example">
euler name=name_to_device_call v0=ode_layer0 v1=ode_later1 ht=ht ode=ode_module rest=100 par={par1=p1; par2=p2;};
</pre>

<p>
You can given the device call a convinient name, <code>name_to_device_call</code>
in this case, to refer to your device elsewhere in the bbs script.
</p>


<h3>Instances of euler in Example Scripts</h3>

<p>
All example scripts can be found in <code>beatbox/data/scripts</code> of the
package distribution. Examples of euler device can be found in the
following:
</p>

<pre class="example">
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs
</pre>

<p>
Indeed, most bbs scripts in the examples use the euler device.
</p>

<!-- ========================= -->
<h2 class="numbered">ezpaint</h2>

<h3>Overview</h3>

<p>

This is 2D visualising device using <code>OpenGL</code>, based on the
graphical part of D. Barkley's <a
href="http://homepages.warwick.ac.uk/~masax/Software/ez_software.html">
<code>EZSPIRAL</code> </a>.
In comparison to EZSPIRAL, it does not provide any run-time dialogue, but does include the
function of plotting tip path on top of the raster. The position of
the tip is not computed in this device, but is expected to
be computed elsewhere, say by the singz device, and passed via
k-variables. The colour scheme is either defined by k-functions
computing the RGB colour components, or by linear mapping of grid values of
selected layers to these components. The possibility of saving the
graphics as image files is provided. Further detail are in the
description of the parameters that follows, and
<a href="#ezpaint-explanations">after it</a>. 

<h3>Parameters</h3>
<table border="1">
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Default</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td class="left"><code>codeblock</code></td>
<td class="left"><code>pgm</code></td>
<td class="left"><code>""</code></td>
<td class="left">k-program computing colour of a particular rectangle
  constituting the raster to be painted. In its absence (i.e. when
  <code>pgm=</code> key is absent in the device description in the script), the raster is
  defined by the alternative methods, based on grid values. 
  In addition to standard
  global k-variables, the following local variables are defined:
  <code>abs</code> (abscissa, the horizontal coordinate in the raster),
  <code>ord</code> (ordinate, the vertical coordinate in the raster),
  <code>app</code> ("applicate", a term denoting the third Cartesian
  coordinate, in the present context may be described as "depth" but its exact meaning is discussed <a href="#ezpaint-explanations">below</a>);
  <code>red</code> (red colour component),
  <code>grn</code> (green colour component),
  <code>blu</code> (blue colour component).
  All the six variables are real; the coordinates are input variables
  (to be used only in right-hand sides of the assignments), whereas
 the colour variables are output variables (each of them must appear
  in the left-hand side of an assignment at least once). The
  coordinate values are assigned values according to loop parameters
  described below. The meaningful range of a colour variable is between 0
  (absence of colour component) and 1.0 (maximal intensity of the
  colour component). 
</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>nabs</code></td>
<td class="left"><code>-</code></td>
<td class="left">Number of <code>abs</code> values, i.e. number of
  "pixels" in the raster in the horizontal direction.
  To be used only with the <code>pgm={...}</code> codeblock,
  otherwise it is defined by the Space parameters of this device instance. 
</td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>absmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">Mininal value of <code>abs</code> variable.
  To be used only with the <code>pgm={...}</code> codeblock. 
</td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>absmax</code></td>
<td class="left"><code>nabs-1</code></td>
<td class="left">Maximal value of <code>abs</code> variable.
  To be used only with the <code>pgm={...}</code> codeblock. 
</td>
</tr>


<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>nord</code></td>
<td class="left"><code>-</code></td>
<td class="left">Number of <code>ord</code> values, i.e. number of
  "pixels" in the raster in the horizontal direction.
  To be used only with the <code>pgm={...}</code> codeblock,
  otherwise it is defined by the Space parameters of this device instance.   
</td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>ordmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">Mininal value of <code>ord</code> variable.
  To be used only with the <code>pgm={...}</code> codeblock. 
</td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>ordmax</code></td>
<td class="left"><code>nord-1</code></td>
<td class="left">Maximal value of <code>ord</code> variable.
  To be used only with the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>napp</code></td>
<td class="left"><code>1</code></td>
<td class="left">Number of <code>app</code> values, i.e. number of
  "pixels" in the raster in the "depth" direction.
  To be used only with the <code>pgm={...}</code> codeblock,
  otherwise it is defined by the Space parameters of this device instance. 
</td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>appmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">Mininal value of <code>app</code> variable.
  To be used only with the <code>pgm={...}</code> codeblock. 
</td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>appmax</code></td>
<td class="left"><code>napp-1</code></td>
<td class="left">Maximal value of <code>app</code> variable.
  To be used only with the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>aspec</code></td>
<td class="left"><code>"xy"</code></td>
<td class="left"> When used in 3D with the "grid colours" option, defines
  which pair of Cartesian coordinates are used to paint the raster. Valid
  values are "xy", "yx", "xz", "zx", "yz" and "zy". 
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>


<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>rlayer</code></td>
<td class="left"><code>-1</code></td>
<td class="left">For the values between 0 and <code>vmax-1</code>
  inclusive, this defines the grid layer that determines the red
  colour componenent. Negative values mean red component will not be
  included. 
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>rmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">Values at or below this will produce zero red
  colour componenent.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>rmax</code></td>
<td class="left"><code>1</code></td>
<td class="left">Values at or above this will produce maximal red
  colour componenent.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>glayer</code></td>
<td class="left"><code>-1</code></td>
<td class="left">For the values between 0 and <code>vmax-1</code>
  inclusive, this defines the grid layer that determines the green
  colour componenent. Negative values mean green component will not be
  included. 
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>gmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">Values at or below this will produce zero green
  colour componenent.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>gmax</code></td>
<td class="left"><code>1</code></td>
<td class="left">Values at or above this will produce maximal green
  colour componenent.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>blayer</code></td>
<td class="left"><code>-1</code></td>
<td class="left">For the values between 0 and <code>vmax-1</code>
  inclusive, this defines the grid layer that determines the blue
  colour componenent. Negative values mean blue component will not be
  included. 
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">Values at or below this will produce zero blue
  colour componenent.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bmax</code></td>
<td class="left"><code>1</code></td>
<td class="left">Values at or above this will produce maximal blue
  colour componenent.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>
 
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bg_r</code></td>
<td class="left"><code>0</code></td>
<td class="left">red component of the background colour representing
  the void.
  To be used only without the <code>pgm={...}</code> codeblock. 
</td>
</tr>
  
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bg_g</code></td>
<td class="left"><code>0</code></td>
<td class="left">green component of the background colour representing
  the void.
  To be used only without the <code>pgm={...}</code> codeblock. 
</tr>
  
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bg_b</code></td>
<td class="left"><code>0</code></td>
<td class="left">blue component of the background colour representing
  the void.
  To be used only without the <code>pgm={...}</code> codeblock. 
</tr>
  
<tr>
<td class="left"><code>k-variable</code></td>
<td class="left"><code>xtip</code></td>
<td class="left"><code>""</code></td>
<td class="left">Name of the k-variable containing the current
  x-coordinate of the tip (in the grid system of coordinates). </td>
</tr>
  
<tr>
<td class="left"><code>k-variable</code></td>
<td class="left"><code>ytip</code></td>
<td class="left"><code>""</code></td>
<td class="left">same, y-coordinate. </td>
</tr>
  
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>ntipmax</code></td>
<td class="left"><code>100</code></td>
<td class="left">Maximal number of preceding tip positions used to draw
  the tip path. Only used when <code>xtip</code> and <code>ytip</code>
  are specified.
</td>
</tr>
  
<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>filter</code></td>
<td class="left"><code>""</code></td>
<td class="left">The mask of a shell command line that will receive the content of
the window in the PPM format; expected to be used to produce an image
  file of the same. The mask can contain a C-style format field for
printing a floating-point value, e.g. "%.0f" which can be used to enumerate the
  output files. </td>
</tr>

<tr>
<td class="left"><code>k-expression</code></td>
<td class="left"><code>filtercode</code></td>
<td class="left"><code>t</code></td>
<td class="left">a formula to compute the enumerator for the images: 
  will be interpreted as a real and printed through the format defined
by <code>filter</code> to produce the actuall shell command. </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>winx</code></td>
<td class="left"><code>-1</code></td>
<td class="left">horizontal position of the window from left edge of screen, pixels </td>
</tr>
<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>winy</code></td>
<td class="left"><code>0</code></td>
<td class="left">vertical position of the window from top edge of screen, pixels</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>width</code></td>
<td class="left"><code>640</code></td>
<td class="left">window width, pixels</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>height</code></td>
<td class="left"><code>640</code></td>
<td class="left">window height, pixels</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>doublebuffer</code></td>
<td class="left"><code>0</code></td>
<td class="left">A 0/1 flag showing whether the double buffer will be
  used for rendering. The advantages and disadvantages are probably
  minor but are platform dependent. </td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>title</code></td>
<td class="left"><code>"ezpaint t=%.0f"</code></td>
<td class="left">The title of the window. May contain one '%' field. </td>
</tr>
  

<tr>
<td class="left"><code>k-expression</code></td>
<td class="left"><code>titlecode</code></td>
<td class="left"><code>t</code></td>
<td class="left">The formula computing the value to be displayed in
  the window title.</td>
</tr>  
</table>

<p id="ezpaint-explanations">
<h3> Further detail </h3>
</p>

<p>
Some explanation is required regarding usage of <code>ezpaint</code> in the 3D
case, and in particular the use of the "applicate" (depth) dimension.
</p>

<p>
In the "grid colours" version, any pair of Cartesian coordinates can be used
to generate the raster, as defined by the <code>aspect</code> parameter. 
The most straightforward use in 3D is for <code>aspect=xy</code> by setting 
<code>z0=z1</code> in its Space. This would then display the selected
z-cross-section of the solution. Setting instead <code>z0 &lt; z1</code>
allows the possibility to represent a layer of grid as a 2D image. This is
done by averaging the colours of all the points with the given <code>x</code>
and <code>y</code> coordinates and for all <code>z0 &le; z &le; z0</code>,
excluding any void points. If all points in this range happen to be
void, then the "background colour" <code>bg_r, bg_g, bg_b</code> is displayed.
Similar for other aspects (<code>yx,xz,zx,yz,zy</code>), <i>mutatis mutandis</i>. 
</p>

<p>
The "k-version" (with the <code>pgm={...}</code> block) allows more
flexibility, e.g. it can be used to represent cross-sections other than
orthogonal to any coordinate axis. In fact, it allows depiction of an arbitrary 2D raster
in which the colour of each pixel is defined by an arbitrary formula depending
on any k-variables and functions including any grid values. In this context,
the k-variable <code>app</code> merely allows this function to be defined as a result of
<code>napp</code> iterations of the same k-program, which may involve the
variable <code>app</code> which runs through a regular grid of values from
<code>appmin</code> through to <code>appmax</code>.
</p>

<p>
Note that the <code>xtip</code> and <code>ytip</code> variables always
represent the position of the tip in the raster coordinates, rather than grid
coordinates even in the case of "grid colour" version. 
</p>

<h3>Instances of ezpaint in Example Scripts</h3>

<p>
Examples of ezpaint device can be found in the
following:
</p>

<pre class="example">
beatbox/data/scripts/sequential/Barkley_model/ezspiral.bbs
beatbox/data/scripts/sequential/Barkley_model/rabbit.bbs
</pre>



<!-- ========================= --> <h2 class="numbered">ezstep</h2>

<h3>Overview</h3>
<p>
This is a timestepper emulating those of the "basic" model of
D. Barkley's
<a href="http://homepages.warwick.ac.uk/~masax/Software/ez_software.html">
<code>EZSPIRAL</code> and <code>EZSCROLL</code>
</a>
(depending on the dimensionality of the grid for which it is called).
That is, it can be used to simulate Barkley's model in 2D and 3D,
including both the reaction and diffusion.  Care is taken to reproduce
as far as possible all the optimizations used in
there. Correspondingly, this timestepper works only in sequential
mode, with box geometries, isotropic diffusion and spatially uniform
parameters.  However, the compilation flags from <code>EZSPIRAL</code>
and <code>EZSCROLL</code> are now device parameters.
</p>

<p>
As a trivial extension, this device can also do reaction-only
computations for the Barkley model, without the diffusion. In this case, the
device may be used in nontrivial geometries.
With the
choice <code>explicit=1</code>, this is mathematically equivalent to using <code>euler
ode=fhnbkl ...;</code> except for the advantage of optimizations done
in EZSPIRAL's <code>ezstep</code> which make it noticeably
faster. This possibility is realised by setting <code>D=0</code> in
the parameter list, in which case it is expected that
<code>Dv=0</code> as well. Naturally, this choice renders parameters
<code>hx</code>, <code>split</code> and <code>manypoints</code>
(described below) irrelevant, so setting them in the script will cause
warning messages.
</p>

<h3>Parameters</h3>

<table border="1">
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>a</code></td>
<td class="left">kinetic constant (slope of fast null-cline)</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>b</code></td>
<td class="left">kinetic constant (threshold)</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>eps</code></td>
<td class="left">kinetic constant (time separation)</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>D</code></td>
<td class="left">diffusivity of the activator (u-variable)</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>Dv</code></td>
<td class="left">diffusivity of the inhibitor (v-variable)</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>hx</code></td>
<td class="left">space discretization step</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>ht</code></td>
<td class="left">time discretization step</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>delta</code></td>
<td class="left"> shortcut round-up tolerance </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>explicit</code></td>
<td class="left">if 0 then implicit u-kinetics, else explicit;
  defaults to 0</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>split</code></td>
<td class="left">if nonzero then split diffusion and kinetics steps;
  defaults to 1</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>manypoint</code></td>
<td class="left">Equivalent of <code>NINEPOINT</code> and
  <code>NINETEENPT</code> flags from EZ software. Defaults to 0.</td>
</tr>
</table>

<h3>Instances of ezstep in Example Scripts</h3>

<p>
Examples of ezstep device can be found in the
following:
</p>


<pre class="example">
beatbox/data/scripts/sequential/Barkley_model/ezspiral.bbs
beatbox/data/scripts/sequential/Barkley_model/ezscroll.bbs
beatbox/data/scripts/sequential/Barkley_model/rabbit.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">ezview</h2>

<h3>Overview</h3>

<p>

This is a 3D visualising device using <code>OpenGL</code>, based on the
graphical part of D. Barkley and M. Dowle's <a
href="http://homepages.warwick.ac.uk/~masax/Software/ez_software.html">
<code>EZSCROLL</code> </a>.  It provides similar (somewhat extended)
run-time dialogue possibilities as the original. The list of device parameters
is also extended compared to what is specified in the "task file" of the
original. The possibility of saving the graphics as image files and of the
detected filament as text files is provided.  The layers containing the
variables for finding the surface, and for finding the filaments, are
(independent) parameters.  There are variations of the algorithm of painting
the surface compared the original.
An extra option, available for anisotropic diffusion case,
is visualization by plotting "fibres" constructed according to fibre directions
defined by the geometry. 
More explanation
<a href="#ezview-explanations">ahead</a>, below the list of parameters.

<h3>Parameters</h3>

<table border="1">
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Default</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>winx</code></td>
<td class="left"><code>-1</code></td>
<td class="left">horizontal position of the window from left edge of screen, pixels </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>winy</code></td>
<td class="left"><code>0</code></td>
<td class="left">vertical position of the window from top edge of screen, pixels</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>width</code></td>
<td class="left"><code>640</code></td>
<td class="left">window width, pixels</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>height</code></td>
<td class="left"><code>640</code></td>
<td class="left">window height, pixels</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>theta</code></td>
<td class="left"><code>0</code></td>
<td class="left"> view angle: rotation about z axis, degrees </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>phi</code></td>
<td class="left"><code>0</code></td>
<td class="left"> view angle: elevation about z=0 plane, degrees </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>psi</code></td>
<td class="left"><code>0</code></td>
<td class="left"> view angle: rotation around view line, degrees </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>distance</code></td>
<td class="left"><code>5.0</code></td>
<td class="left"> former <code>DISTANCE</code> of
  <code>ezgraph3d.h</code> in <code>EZSCROLL</code>.
  <code>distance=1</code> corresponds to the largest dimension of the
  visualized volume. 
</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>theta0</code></td>
<td class="left"><code>20</code></td>
<td class="left"> initial </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>phi0</code></td>
<td class="left"><code>60</code></td>
<td class="right"> &nbsp; &nbsp; values  </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>psi0</code></td>
<td class="left"><code>0</code></td>
<td class="right"> &nbsp; &nbsp; of the  </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>distance0</code></td>
<td class="left"><code>5.0</code></td>
<td class="right"> &nbsp; &nbsp; same    </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>imin</code></td>
<td class="left"><code>1</code></td>
<td class="left"> 3D  subset     </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>imax</code></td>
<td class="left"><code>xmax-2</code></td>
<td class="right"> &nbsp; &nbsp;  of the box    </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>jmin</code></td>
<td class="left"><code>1</code></td>
<td class="right"> &nbsp; &nbsp; to be displayed       </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>jmax</code></td>
<td class="left"><code>ymax-2</code></td>
<td class="right"> &nbsp; &nbsp; (similar to <code>Space</code>   </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>kmin</code></td>
<td class="left"><code>1</code></td>
<td class="right"> &nbsp; &nbsp; parameters <code>x0,...,z1</code>     </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>kmax</code></td>
<td class="left"><code>zmax-2</code></td>
<td class="right"> &nbsp; &nbsp; but changeable in dialogue) </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>norm_res</code></td>
<td class="left"><code>1</code></td>
<td class="left"> view and run mode resolution </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>rot_res</code></td>
<td class="left"><code>1</code></td>
<td class="left"> rotate mode resolution </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>show_surface</code></td>
<td class="left"><code>1</code></td>
<td class="left"> whether to draw the surface </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>ulayer</code></td>
<td class="left"><code>0</code></td>
<td class="left"> isosurface layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>uc</code></td>
<td class="left"><code>0</code></td>
<td class="left"> isosurface critical value </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>vlayer</code></td>
<td class="left"><code>0</code></td>
<td class="left"> "other variable" layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>vc</code></td>
<td class="left"><code>0</code></td>
<td class="left"> "other variable" critical value </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>vmin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> "other variable" range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>maxv</code></td>
<td class="left"><code>1</code></td>
<td class="left"> "other variable" range upper end
  (NB: global variable <code>vmax</code> is reserved for the total
  number of layers)
</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>rlayer</code></td>
<td class="left"><code>0</code></td>
<td class="left"> red  component layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>rmin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> red component range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>rmax</code></td>
<td class="left"><code>1</code></td>
<td class="left"> red component range upper end </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>glayer</code></td>
<td class="left"><code>0</code></td>
<td class="left"> green component layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>gmin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> green component range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>gmax</code></td>
<td class="left"><code>1</code></td>
<td class="left"> green component range upper end </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>blayer</code></td>
<td class="left"><code>0</code></td>
<td class="left"> blue component layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bmin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> blue component range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bmax</code></td>
<td class="left"><code>1</code></td>
<td class="left"> blue component range upper end </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>alayer</code></td>
<td class="left"><code>0</code></td>
<td class="left"> alpha (opacity) layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>amin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> alpha range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>amax</code></td>
<td class="left"><code>1</code></td>
<td class="left"> alpha range upper end </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>color_mode</code></td>
<td class="left"><code>1</code></td>
<td class="left"> surface colouring algorithm </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>alphamin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> minimal opacity </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>alphamax</code></td>
<td class="left"><code>0</code></td>
<td class="left"> maximal opacity </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>show_filament</code></td>
<td class="left"><code>0</code></td>
<td class="left"> whether to draw filaments </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>layer1</code></td>
<td class="left"><code>0</code></td>
<td class="left"> singular filament layer 1 </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>const1</code></td>
<td class="left"><code>0</code></td>
<td class="left"> singular filament constant 1 </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>layer2</code></td>
<td class="left"><code>0</code></td>
<td class="left"> singular filament layer 2 </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>const2</code></td>
<td class="left"><code>0</code></td>
<td class="left"> singular filament layer constant 2 </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>flm_r</code></td>
<td class="left"><code>1</code></td>
<td class="left"> filament          </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>flm_g</code></td>
<td class="left"><code>1</code></td>
<td class="left">  &nbsp; &nbsp;  colour         </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>flm_b</code></td>
<td class="left"><code>0.8</code></td>
<td class="left">  &nbsp; &nbsp;  components     </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>flm_wt</code></td>
<td class="left"><code>3.0</code></td>
<td class="left"> &nbsp; &nbsp;  and the linewidth </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>flm_balls</code></td>
<td class="left"><code>0</code></td>
<td class="left"> .., plot it by spheres </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>flm_em</code></td>
<td class="left"><code>0</code></td>
<td class="left"> emission property </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>remove_backs</code></td>
<td class="left"><code>0</code></td>
<td class="left"> remove (positive=1/negative=-1/none=0) part of surface </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>clipping</code></td>
<td class="left"><code>0</code></td>
<td class="left"> use the extra clipping plane </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>ezdepth</code></td>
<td class="left"><code>1</code></td>
<td class="left"> use the depth buffer </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>write_images</code></td>
<td class="left"><code>0</code></td>
<td class="left"> save all images </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>write_filament</code></td>
<td class="left"><code>0</code></td>
<td class="left"> write all filament data </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bg_r</code></td>
<td class="left"><code>0.0</code></td>
<td class="left"> background        </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bg_g</code></td>
<td class="left"><code>0.0</code></td>
<td class="left"> &nbsp;  &nbsp;   colour         </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bg_b</code></td>
<td class="left"><code>0.0</code></td>
<td class="left"> &nbsp;  &nbsp;  components     </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bbox_r</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> bounding box      </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bbox_g</code></td>
<td class="left"><code>0.5</code></td>
<td class="left">  &nbsp;  &nbsp; colour         </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bbox_b</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> &nbsp;  &nbsp;  components,    </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bbox_a</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> &nbsp;  &nbsp;  its opacity </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>bbox_wt</code></td>
<td class="left"><code>2.0</code></td>
<td class="left"> &nbsp;  &nbsp;  and the linewidth </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>verbose</code></td>
<td class="left"><code>1</code></td>
<td class="left"> verbosity level of <code>ezview</code> </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>autostart</code></td>
<td class="left"><code>1</code></td>
<td class="left"> autostart flag </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>lightx</code></td>
<td class="left"><code>-50.0</code></td>
<td class="left"> position  </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>lighty</code></td>
<td class="left"><code>+10.0</code></td>
<td class="left"> &nbsp;  &nbsp; of the </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>lightz</code></td>
<td class="left"><code>+10.0</code></td>
<td class="left"> &nbsp;  &nbsp; directional </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>lightw</code></td>
<td class="left"><code>1</code></td>
<td class="left"> &nbsp;  &nbsp; light </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>amb_r</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> color </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>amb_g</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> &nbsp;  &nbsp; of the </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>amb_b</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> &nbsp;  &nbsp; ambient </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>amb_a</code></td>
<td class="left"><code>0.5</code></td>
<td class="left"> &nbsp;  &nbsp; light </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>show_fibres</code></td>
<td class="left"><code>0</code></td>
<td class="left"> whether to show fibres </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_dx</code></td>
<td class="left"><code>xmax/10</code></td>
<td class="left">number of grid points between fibre stems in the
  <code>x</code> direction</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_dy</code></td>
<td class="left"><code>fib_dx</code></td>
<td class="left">number of grid points between fibre stems in the
  <code>y</code> direction</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_dz</code></td>
<td class="left"><code>fib_dx</code></td>
<td class="left">number of grid points between fibre stems in the
  <code>z</code> direction</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_x0</code></td>
<td class="left"><code>imin</code></td>
<td class="left"><code>x</code>-coordinate of the initial point of the
  fibre stems grid </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_y0</code></td>
<td class="left"><code>jmin</code></td>
<td class="left"><code>y</code>-coordinate of the initial point of the
  fibre stems grid </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_z0</code></td>
<td class="left"><code>kmin</code></td>
<td class="left"><code>z</code>-coordinate of the initial point of the
  fibre stems grid </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_step</code></td>
<td class="left"><code>1.0</code></td>
<td class="left">length of fibre segments</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_len</code></td>
<td class="left"><code>10*xmax</code></td>
<td class="left">number of fibre segments either way from the stem</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_rlayer</code></td>
<td class="left"><code>0</code></td>
<td class="left">fibres red component layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_rmin</code></td>
<td class="left"><code>0</code></td>
<td class="left"> fibre red component range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_rmax</code></td>
<td class="left"><code>1</code></td>
<td class="left"> fibre red component range upper end </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_glayer</code></td>
<td class="left"><code>0</code></td>
<td class="left">fibre green component layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_gmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">fibre green component range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_gmax</code></td>
<td class="left"><code>1</code></td>
<td class="left">fibre green component range upper end </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>fib_blayer</code></td>
<td class="left"><code>0</code></td>
<td class="left">fibre blue component layer </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_bmin</code></td>
<td class="left"><code>0</code></td>
<td class="left">fibre blue component range lower end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_bmax</code></td>
<td class="left"><code>1</code></td>
<td class="left">fibre blue component range upper end </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>fib_wt</code></td>
<td class="left"><code>1.0</code></td>
<td class="left">fibre linewidth </td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>show_marker</code></td>
<td class="left"><code>0</code></td>
<td class="left"> whether to show the marker </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_size</code></td>
<td class="left"><code>0</code></td>
<td class="left"> size and             </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_x</code></td>
<td class="left"><code>xmax/2-1</code></td>
<td class="left">  &nbsp;  &nbsp; coordinates       </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_y</code></td>
<td class="left"><code>ymax/2-1</code></td>
<td class="left"> &nbsp;  &nbsp;  of the marker     </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_z</code></td>
<td class="left"><code>zmax/2-1</code></td>
<td class="left"> &nbsp;  &nbsp;  position          </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_r</code></td>
<td class="left"><code>1.0</code></td>
<td class="left"> marker               </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_g</code></td>
<td class="left"><code>1.0</code></td>
<td class="left">  &nbsp;  &nbsp; colour            </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_b</code></td>
<td class="left"><code>0.0</code></td>
<td class="left">  &nbsp;  &nbsp; components,       </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_a</code></td>
<td class="left"><code>1</code></td>
<td class="left">  &nbsp;  &nbsp; its opacity  </td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>marker_wt</code></td>
<td class="left"><code>2.0</code></td>
<td class="left"> &nbsp;  &nbsp;  and the linewidth </td>
</tr>


<tr>
<td class="left"><code>file</code></td>
<td class="left"><code>filament</code></td>
<td class="left"><code>-</code></td>
<td class="left">text file to output the found filaments</td>
</tr>

<tr>
<td class="left"><code>string</code></td>
<td class="left"><code>images</code></td>
<td class="left"><code>-</code></td>
<td class="left">template for filenames to output the images</td>
</tr>

<tr>
<td class="left"><code>k-expression</code></td>
<td class="left"><code>imagescode</code></td>
<td class="left"><code>-</code></td>
<td class="left">a formula to compute the enumerator for the images' filenames</td>
</tr>

</table>

<p id="ezview-explanations">

<h3> Further detail </h3>

The surface is defined as the isosurface at the level <code>uc</code> of the field
contained in the layer <code>ulayer</code>. Parameter values
<code>color_mode=1,2,3</code> have similar meaning to the original
<code>EZSCROLL</code> implementaion, where
<code>ulayer</code> plays the role of the u-variable and <code>vlayer</code>
plays the role of the v-variable; the values
<code>color_mode=4,5</code> activate the same new colour-coding
algorithm in which the colour components are defined by: for red,
<code>rlayer</code> is the field, the value <code>rmin</code> maps to its zero
and <code>rmax</code> to its full strength, and similarly for the green, blue
and alpha (opacity) components. Additionally, "zero" and "full strength" of
the opacity component are defined correspondingly by <code>alphamin</code> and
<code>alphamax</code>. Other values of the <code>color_mode</code>
parameter correspond
to the default algorithm where the three colour components are defined
by the three spatial
coordinates.  The filaments, when requested, are computed as intersections of
isosurfaces of fields in <code>layer1</code> and <code>layer2</code> at
levels <code>const1</code> and <code>const2</code> respectively. Unlike in the
original, an attempt is made to connect the segments of the found filaments
into contiguous chains, both for display and for text output purposes. There
is an option to visualise filaments not by segments of straight lines but by
balls, by setting <code>flm_balls=1</code>.  Another new facility is
the "marker",
whose position and size (in gridpoits), color, and weight (linewidth) can be
specified. Parameters of the directional and ambient light can also be
specified. </p>

<p>
The visualization "by fibres" involves plotting curves that are tangent to the
fibre directions and colouring them using a scheme similar to
<code>color_mode=4</code> used for surfaces as described above, only the
parameters of the colour coding are prefixed with a <code>fib_</code> to allow
simultaneous and independent use of surface and fibres coloured differently
(this is not a recommendation or endorsement, just statement of the
possibility!). The algorithm is as follows. The "fibres" are drawn from
selected grid points called here "stems", in both directions. They are
constructed by effectively solving the initial-value problem for a system of 3
ODEs defined by the fiber direction field. The
ODE system is solved numerically using the forward Euler method with step
<code>fib_step</code>. The direction field between the grid nodes is defined
by tri-linear interpolation. Solution continues for <code>fib_len</code> steps
or until the curve reaches the void, whichever comes first. The initial points
for the curves, or the "stems", are selected in a regular subgrid. This
"grid of stems" is
defined thus: the <code>x</code> coordinates start from <code>fib_x0</code>
and go with the sep <code>fib_dx</code> for as long as the <code>x</code>
coordinate stays within the <code>Space</code> of the device, and similar for
<code>y</code> and <code>z</code> coordinates.
</p>

<p>
The mouse and hot-key control of the visualization are possible in much the
same way as in the original, with some extensions.  Parameter
<code>autostart=0</code> means that the program will stop after drawing the
first image and await user's instructions in the dialogue mode. Mouse click-and-draw gestures can
be used to change the view. The use of keyboards is considerably extended, and
is explained briefly by a table below. Features different compared to
<code>EZSCROLL</code> are marked by *. Caveat: original features may be assigned to different letters. 
</p>

<table border="1">
<thead>
<tr>
<th scope="col" class="left">Key</th>
<th scope="col" class="left">Action</th>
</tr>
</thead>
<tbody>

<tr><td class="left"><code>P,p</code></td><td class="left">pause <code>BeatBox</code>  and enter into <code>ezview</code> dialogue mode </td></tr>
<tr><td class="left"><code>Q,q</code></td><td class="left">exit <code>ezview</code> device and command <code>BeatBox</code> to stop </td></tr>
<tr><td class="left"><code>(space)</code></td><td class="left">exit <code>ezview</code> dialogue mode and let <code>BeatBox</code> resume simulation </td></tr>

<tr><td class="left"><code>S,s</code></td><td class="left"> * toggle Surface drawing </td></tr>
<tr><td class="left"><code>F,f</code></td><td class="left"> toggle Filament plotting </td></tr>
<tr><td class="left"><code>B,b</code></td><td class="left"> * toggle fiBres plotting </td></tr>
<tr><td class="left"><code>M,m</code></td><td class="left"> * toggle Marker drawing </td></tr>
<tr><td class="left"><code>V,v</code></td><td class="left"> * switch remoVal of fronts/backs/none </td></tr>
<tr><td class="left"><code>C,c</code></td><td class="left"> toggle Clipping plane </td></tr>
<tr><td class="left"><code>D,d</code></td><td class="left"> toggle Depth buffer </td></tr>
<tr><td class="left"><code>O,o</code></td><td class="left"> Original view <code>theta=theta0</code> etc </td></tr>
<tr><td class="left"><code>R,r</code></td><td class="left"> Redraw </td></tr>
<tr><td class="left"><code>W,w</code></td><td class="left"> Write "all" (image and filament) </td></tr>
<tr><td class="left"><code>X,x</code></td><td class="left"> * view along/against X axis </td></tr>
<tr><td class="left"><code>Y,y</code></td><td class="left"> * view along/against Y axis </td></tr>
<tr><td class="left"><code>Z,z</code></td><td class="left"> view along/against Z axis </td></tr>
<tr><td class="left"><code>0..9</code></td><td class="left"> change the <code>color_mode</code </td></tr>

<tr><td class="left"><code>(arrows)</code></td><td class="left"> * rotate the box by changing <code>theta</code> and <code>phi</code> angles; SHIFT+: big steps (same below)</td></tr>
<tr><td class="left"><code>(PgUp/PgDn)</code></td><td class="left"> * tilt the image: change the <code>psi</code> angle </td></tr>
<tr><td class="left"><code>(ALT+arrows,PgUp/PgDn)</code></td> <td class="left"> * rotate the image in an alternative way ("yaw","pitch","roll")</td></tr>
<tr><td class="left"><code>(CTRL+arrows)</code></td> <td class="left"> * move the window about the screen</td></tr>
<tr><td class="left"><code>(CTRL+ALT+arrows,PgUp/PgDn)</code></td> <td class="left"> * move the marker (change its x,y,z coords)</td></tr>
<tr><td class="left"><code>CTRL+, CTRL-</code></td><td class="left"> * increase and decrease <code>distance</code> of the viewpoint from the box</td></tr>
<tr><td class="left"><code>=</code></td><td class="left"> * change the parameters in a text dialogue </td></tr>

</table>

<p>
The "removal" function is a slight extension of <code>EZSCROLL</code>'s
function of "back removals". Here it is not a toggle but a three-position
switch: remove "fronts" (polygons of the surface for which
<code>v&lt;vc</code>), remove "backs" (<code>v&gt;vc</code>) or do not remove
any, where <code>v</code> is the field value in the layer
<code>vlayer</code>. 
</p>

<p>
The (rather rudimentary) text dialogue that follows pressing a "<code>=</code>"
key takes place in the parent shell from which <code>BeatBox</code> was
started, and requires the user to enter a parameter name to be changed
following the "<code>parameter=</code>" prompt, and then the new value following
"<code>old value=XXX new value=</code>" prompt. Trailing spaces in user inputs
are ignored. An empty string entered as the value confirms the old
value; an empty
string entered as the parameter name finishes the dialogue and returns control
to the <code>ezview</code> graphics window. Entering anything that is not a
valid parameter name will print the list of known parameter names.
</p>

<p>

Finally, the window and icon name is composed of a
customizable part and a
standard part. The customizable part is defined in the script by parameters
<code>title</code> and <code>titlecode</code> and interpreted in much the same
way as for <a href="#ezpaint"><code>ezpaint</code></a> device. The standard
part includes a "busy" indicator in angular brackets, a sequence of upper- or
lower-case characters "SFBM VCD" in square brackets for the flags, and the camera position in
round brackets. The "busy" indicator is one of:
<ul>
  <li> blank space for "running"
mode, meaning that this instance of <code>ezview</code> is not busy neither in
  drawing nor in dialogue with the user, </li>
  <li> '-' meaning that drawing is in progress
  (this phase may not be noticeable for simple scenes), </li>
  <li> '+' meaning that the
execution has paused, drawing of the current scene is completed, and
  <code>ezview</code> is waiting for the user's input;
  <li> '=' meaning that <code>ezview</code> is in "rotating" mode,
  i.e. changing the viewing angle, either caused by mouse gestures or hot
  keys.
</ul>
The flag string displays characters corresponding to toggle hot keys,
uppercase when the flag is "on" and lowercase when the flag is "off"; the 'V'
flag is prefixed by '+' or '-' for removal of fronts/backs respectively.
The position of the camera is represented by the current values of parameters
<code>theta</code>, <code>phi</code>, <code>psi</code> and
<code>distance</code>. 
</p>

<h3>Instances of ezview in Example Scripts</h3>

<p>
Examples of ezview device can be found in the
following:
</p>

<pre class="example">
beatbox/data/scripts/sequential/Barkley_model/ezscroll.bbs
beatbox/data/scripts/sequential/Barkley_model/rabbit.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">grad2d</h2>
<h3>Overview</h3>

<p>
Computes the absolute value of the 2D gradient of the field in layer
<code>v0</code>, and puts it into layer <code>v1</code>.
Computation is done using second-order accurate central differences. 
</p>

<h3>Parameters</h3>
<p>
The only parameter is the space step, <code>hx</code>. 
<h3>Typical Syntax</h3>
grad2d hx=hx;
<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/sequential/FitzHughNagumo_model/fhn2.bbs
</pre>
The input, output, and simulation method of fhn2.bbs has been described
previously.

<!-- ========================= -->
<h2 class="numbered">imgout</h2>

<h3>Overview</h3>

<p>
The purpose of this device is to produces image files representing the current
state of the grid. Values from specified layers of the
simulation medium are mapped to colour channels by linear
interpolation using specified minima and maxima. This device is intended to produce a
new file every time it is run, enumerated in a prescribed way. 
</p>

<h3>Parameters</h3>

<table border="1">
  <tr>
    <th scope="col" class="left">Type</th>
    <th scope="col" class="left">Name</th>
    <th scope="col" class="left">Default</th>
    <th scope="col" class="left">Description</th>
  </tr>
  <tr>
    <td class="left"><code>str</code></td>
    <td class="left"><code>filter</code></td>
    <td class="left"><code> - </code></td>
    <td class="left">The mask of a shell command line that will receive the
      generated image in the PPM format; expected to be used to produce actual
      image file of the same, using appropriate NETPBM modules and/or other
      appropriate command-line tools. The mask can contain a C-style format
      field for printing a floating-point value, e.g. "%.0f" which can be used
      to enumerate the output files. </td>
    </tr>
  <tr>
    <td class="left"><code>k-expression</code></td>
    <td class="left"><code>code</code></td>
    <td class="left"><code>t</code></td>
    <td class="left">a formula to compute the enumerator for the images: 
      will be interpreted as a real and printed through the format defined
      by <code>filter</code> to produce the actuall shell command. </td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>r</code></td>
    <td> - </td>
    <td> Layer of the simulation medium from which the red colour channel should be mapped.</td>
  </tr>
  <tr> 
    <td><code>real</code></td><td><code>r0</code></td>
    <td> - </td>
    <td> Value of the layer assigned to r that should map to 0. </td>
  </tr>
  <tr>
    <td><code>real</code></td>
    <td><code>r1</code> </td>
    <td> - </td>
    <td> Value of the layer assigned to r that should map to 255. </td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>g</code></td>
    <td> - </td>
    <td> Layer of the simulation medium from which the blue colour channel should be mapped.</td>
  </tr>
  <tr>
    <td><code>real</code></td>
    <td><code>g0</code></td>
    <td> - </td>
    <td> Value of the layer assigned to <code>g</code> that should map to 0.</td>
  </tr>
  <tr>
    <td><code>real</code></td>
    <td><code>g1</code></td>
    <td> - </td>
    <td> Value of the layer assigned to <code>g</code> that should map to 255.</td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>b</code></td>
    <td> - </td>
    <td> Layer of the simulation medium from which the green colour channel should be mapped.</td>
  </tr>
  <tr>
    <td><code>real</code></td>
    <td><code>b0</code></td>
    <td> - </td>
    <td> Value of the layer assigned to b that should map to 0.</td>
  </tr>
  <tr>
    <td><code>real</code></td>
    <td><code>b1</code></td>
    <td> - </td>
    <td> Value of the layer assigned to <code>b</code> that should map to 255.</td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>bgr</code></td>
    <td><code>255</code></td>
    <td> Red value of the background colour, to be displayed at void points.</td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>bgg</code></td>
    <td><code>255</code></td>
    <td> Green value of the background colour, to be displayed at void points.</td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>bgb</code></td>
    <td><code>255</code></td>
    <td> Blue value of the background colour, to be displayed at void points.</td>
  </tr>
  <tr>
    <td><code>str</code></td>
    <td><code>debug</code></td>
    <td> "" </td>
    <td> Path to output file for debugging purposes. If <code>stdout</code>, will print to screen of the parent shell.</td>
  </tr>
</table>

<h3>Typical Syntax</h3>
The typical syntax of <code>imgout</code> device is as follows.
<pre>
imgout filter="pnmflip -tb | pnmtopng > [outdir]/uvi%07.0f.png" mode="w" r=[u] r0=umin r1=umax g=[v] g0=vmin g1=vmax b=[i] b0=-1 b1=1;
</pre>
<h3>Instances of <code>imgout</code> in Example Scripts</h3>
Examples of using <code>imgout</code> device can be found in the following:
<pre>
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttp06/benchmark.bbs
beatbox/data/scripts/sequential/CRN_model/pd_crn2.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn_crossFieldStim_ffr_slice.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn_spiral_ffr_slice_aniso.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs
beatbox/data/scripts/sequential/ZFK_model/zfkbid2.bbs
beatbox/data/scripts/sequential/ZFK_model/zfkmon2.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_clock</h2>

<h3>Overview</h3>
<p>
Prints the current time to <code>stdout</code> and VGA graphics window. 
</p>
<h3>Parameters</h3>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>int</code></td><td><code>col0</code></td><td> starting column of VGA
  graphics (measured in characters).</td>
</tr><tr>
<td><code>int</code></td><td><code>row0</code></td><td> starting row of
  graphics (measured in characters).</td>
</tr><tr>
<td><code>int</code></td><td><code>color</code></td><td> Color code of line graphics.</td>
</tr><tr>
<td><code>real</code></td><td><code>code</code></td><td> k-expression for the
  value to be displayed.</td>
</tr><tr>
<td><code>string</code></td><td><code>format</code></td><td>string defining format of output real</td>
</tr>
</table>

<h3>Typical Syntax</h3>
The <code>k_clock</code> device is mainly used during simlations with run time VGA
graphics. It is similar to <code>clock</code> but offers more flexibility by
allowing the displayed value to be defined by an arbitrary k-expression. 
The typical syntax of <code>k_clock</code> device is as follows.
<pre>
k_clock when=often color=WHITE row0=1 col0=21 code=t*ht format="T=%4.1f ms"; 
</pre>
<h3>Instances of <code>k_clock</code> in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0.bbs
</pre>
The inputs, outputs, and methods of running for fhn0.bbs
have been described in previous sections. 


<!-- ========================= -->
<h2 class="numbered">k_draw</h2>
<h3>Overview</h3>
Draws a curve in the VGA graphics window. Unlike <code>k_plot</code> device,
this one adds one segment or point to the curve at each call. 
<h3>Parameters</h3>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>int</code></td><td><code>col0</code></td><td> starting column of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>col1</code></td><td> end column of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>row0</code></td><td> starting row of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>col1</code></td><td> end column of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>color</code></td><td> Color code of line graphics.</td>
</tr>
</table>
<h3>Typical Syntax</h3>
The typical syntax of k_draw device is as follows.
<pre>
def str win1 col0=col0 col1=col1 row0=row0 row1=row1 color=15*16+15;
k_draw when=always [win1] color=BLUE*16;
</pre>
<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_func</h2>

<h3>Overview</h3>

<p>
Allows the user to specify user defined functions to be executed as
part of the simulation run.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr><tr>
  
  <td><code>int</code></td><td><code>restricted</code></td><td>
    If this parameter is nonzero, this device will never run in any
    non-tissue points.
  </td>

</tr><tr>
 
  <td><code>str</code></td><td><code>file</code></td><td>
    Path to file for phase distribution. See Beatbox
    Scripting Guide.
  </td>
  
</tr><tr>
  
<td><code>str</code></td><td><code>debug</code></td><td>
  Relative path to output file for debugging purposes. If
  <code>stdout</code>, will print to screen of the parent shell.
</td>
  
</tr><tr>
  
  <td><code>codeblock</code></td><td><code>pgm</code></td><td>
    The function to be executed when the device is run.
    The codeblock contains k-assignments of the form
    <code>&lt;k-variable&gt;=&lt;k-expression&gt;</code>,
    separated by semicolons. Users should note that the
    behaviour of <code>k_func</code> changes significantly in relation to
    the nowhere parameter.When <code>nowhere=1</code>, assignments can be
    made to k variables only. Assignments from the simulation medium or
    random number generators are disallowed. When <code>nowhere=0</code>,
    assignments can be made to the simulation medium only. It is possible
    to define intermediate variables in <code>k_func</code> programs,
    using the def keyword. Variables must be initialised before they are
    used, and are reinitialised on each iteration of the
    <code>k_func</code> program.
  </td>
  
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>k_func</code> device is as follows.
</p>

<pre>
k_func name=timing nowhere=1 pgm={
  begin = eq(t,0);          // 1 when t is equal to zero, 0 otherwise. 
  often = eq(mod(t,10),0);  // 1 if t is divisible by 10, 0 otherwise.
  end   = ge(t,100000);	    // 1 if t is greater or equal than 100000, 
                            // 0 otherwise.
};
</pre>

<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_imgout</h2>

<h3>Overview</h3>

<p>
Produces png images of the space. Similar to <code>imgout</code> device, with
more flexibility due to use of k-expressions to code the colours instead of
direct linear mapping of the grid values.
</p>

<h3>Parameters</h3>

<table border="1">
  <tr>
    <th scope="col" class="left">Type</th>
    <th scope="col" class="left">Name</th>
    <th scope="col" class="left">Default</th>
    <th scope="col" class="left">Description</th>
  </tr>
  <tr>
    <td class="left"><code>str</code></td>
    <td class="left"><code>filter</code></td>
    <td class="left"><code> - </code></td>
    <td class="left">The mask of a shell command line that will receive the
      generated image in the PPM format; expected to be used to produce actual
      image file of the same, using appropriate NETPBM modules and/or other
      appropriate command-line tools. The mask can contain a C-style format
      field for printing a floating-point value, e.g. "%.0f" which can be used
      to enumerate the output files. </td>
  </tr>
  <tr>
    <td class="left"><code>k-expression</code></td>
    <td class="left"><code>filtercode</code></td>
    <td class="left"><code>t</code></td>
    <td class="left">a formula to compute the enumerator for the images: 
      will be interpreted as a real and printed through the format defined
      by <code>filter</code> to produce the actuall shell command. </td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>width</code></td>
    <td> - </td>
    <td> Horizontal size of the images, in pixels.</td>
  </tr>
  <tr>
    <td><code>int</code></td>
    <td><code>height</code></td>
    <td> - </td>
    <td> Vertical size of the images, in pixels.</td>
  </tr>
  <tr>
    <td class="left"><code>codeblock</code></td>
    <td class="left"><code>pgm</code></td>
    <td class="left"><code>-</code></td>

    <td class="left">A k-program computing the colour of each pixel of the
      output image. In the lexical scope of this program, local variables
      <code>i</code>, <code>j</code> (integer) <code>r</code>, <code>g</code>
      and <code>b</code> (real) are defined. If synonymous global variables
      exist, these local variables supercede those. 
      The real variables <code>r</code>,
      <code>g</code> and <code>b</code> are output variables.
      Their values have to be computed (each of them must
      occur at least once in the left hand-sides of the assignments in the
      k-program). They are then cropped to the range <code>0..1</code> and
      represent correspondingly the red, green and blue components of the
      pixel colour. Their values may depend on the read-only variables
      <code>i</code> and <code>j</code> which represent the integer
      coordinates of the pixel (running in the ranges <code>0..width-1</code>,
      <code>0..height-1</code> respectively, inclusive).
    </td>
  </tr>
</table>

<h3>Typical Syntax</h3>
An example of the <code>k_imgout</code> syntax:
<pre>
k_imgout when=out
  filter="pnmflip -tb | pnmtopng > [outdir]/udg%06.0f.png"
  filtercode="t/tout"
  width=nx height=ny
  pgm={
    r=(u(1+i,1+j,0,[u])-umin)/(umax-umin);
    g=fabs(u(1+i,1+j,0,[d]))/2.0;
    b=u(1+i,1+j,0,[g])/2.0;
  };
</pre>
<h3>Instances of k_imgout in Example Scripts</h3>
Examples of <code>k_imgout</code> device can be found in the following:
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn_crossFieldStim_ffr_slice.bbs
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttp06/benchmark.bbs
</pre>


<!-- ========================= -->
<h2 class="numbered">k_paint</h2>

<h3>Overview</h3>

<code>k_paint</code> is a device for run-time graphics to paint the field using VGA emulator.

<h3>Parameters</h3>

<table border="1">
  <tr>
    <th scope="col" class="left">Type</th>
    <th scope="col" class="left">Name</th>
    <th scope="col" class="left">Default</th>
    <th scope="col" class="left">Description</th>
  </tr>

  <tr>
    <td><code>int</code></td>    
    <td><code>nabs</code></td>
    <td> - </td>
    <td>Horizontal (abscissa) size of the virtual raster</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>absmin</code></td>
    <td><code>0</code></td>
    <td>Minimal value of he abscissa counter</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>absmax</code></td>
    <td><code>nabs-1</code></td>
    <td>Maximal value of the abscissa counter</td>
  </tr>

  <tr>
    <td><code>int</code></td>    
    <td><code>nord</code></td>
    <td> - </td>
    <td>Vertical (ordinate) size of the virtual raster</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>ordmin</code></td>
    <td><code>0</code></td>
    <td>Minimal value of he ordinate counter</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>ordmax</code></td>
    <td><code>nord-1</code></td>
    <td>Maximal value of the ordinate counter</td>
  </tr>

  <tr>
    <td class="left"><code>codeblock</code></td>
    <td class="left"><code>pgm</code></td>
    <td class="left"><code>-</code></td>

    <td class="left">A k-program computing the colour of each virtual pixel of the
      output image. In the lexical scope of this program, local variables
      <code>abs</code>,
      <code>ord</code>,
      <!-- <code>app</code>, -->
      <code>red</code>,
      <code>grn</code> and
      <code>blu</code>
      (all real) are defined. If synonymous global variables
      exist, these local variables supercede those. 
      The variables <code>red</code>,
      <code>grn</code> and <code>blu</code> are output variables.
      Their values have to be computed (each of them must
      occur at least once in the left hand-sides of the assignments in the
      k-program). They are then cropped to the range <code>0..1</code> and
      represent correspondingly the red, green and blue components of the
      pixel colour. 
      Their values may depend on the read-only real variables
      <code>abs</code>
      and
      <code>ord</code>,
      <!-- <code>app</code>, -->
      for "abscissa" and "ordinate" of the image raster, which in this device
      are distinint from pixel enumeration. These scan
      <code>nabs</code> values from <code>absmin</code> to <code>absmax</code>,
      respectively
      <code>nord</code> values from <code>ordmin</code> to <code>ordmax</code>
      which are linearly mapped to the
      area of the VGA emulator with coordinates
      <code>col0..col1</code> and <code>row0..row1</code>.
    </td>
  </tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>k_paint</code> device is as follows.
</p>

<pre>
k_paint when=out nabs=nx nord=ny          // how many abscissa and ordinate values
  col0=col0 col1=col1 row0=row0 row1=row1 // output it into the left panel
  color=WHITE*16+WHITE                    // white borders for the panel
  pgm={                                   // program should calculate colour for given (abs,ord)
                                          // and we take abs=x and ord=y
  col=ifge0(u(abs,ord,0,[u]),LIGHTRED,0)  // red component there if u field is above 0
  + ifge0(u(abs,ord,0,[v]),GREEN,0)};     // and green if [v] field is above 0
</pre>


<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_paintgl</h2>

<h3>Overview</h3>

This is similar in purpose to the <code>k_paint</code>, but uses its own X
window and produces run-time graphics using OpenGL. 
A copy of each image can be written to a file through a filter.
This device is obsolete by <code>ezpaint</code> and is retained only for
compatibility with legacy scripts. 

<h3>Parameters</h3>

<table border="1">
  <tr>
    <th scope="col" class="left">Type</th>
    <th scope="col" class="left">Name</th>
    <th scope="col" class="left">Default</th>
    <th scope="col" class="left">Description</th>
  </tr>

  <tr>
    <td class="left"><code>str</code></td>
    <td class="left"><code>title</code></td>
    <td class="left"><code>k_paintgl t=%.0f</code></td>
    <td class="left">Title of the window. May countaing a C format specifier for a real value.</td>
  </tr>

  <tr>
    <td class="left"><code>str</code></td>
    <td class="left"><code>titlecode</code></td>
    <td class="left"><code>t</code></td>
    <td class="left">k-expression computing the real value to be represented in the windown title.</td>
  </tr>

  <tr>
    <td class="left"><code>int</code></td>
    <td class="left"><code>winx</code></td>
    <td class="left"><code>-1</code></td>
    <td class="left">horizontal position of the window from left edge (or
    right, if negative) of screen, pixels </td>
  </tr>

  <tr>
    <td class="left"><code>int</code></td>
    <td class="left"><code>winy</code></td>
    <td class="left"><code>1</code></td>
    <td class="left">vertical position of the window from top edge (or bottom,
    if negative) of screen, pixels</td>
  </tr>

  <tr>
    <td><code>int</code></td>
    <td><code>width</code></td>
    <td> 512 </td>
    <td> Horizontal size of the window, in pixels.</td>
  </tr>

  <tr>
    <td><code>int</code></td>
    <td><code>height</code></td>
    <td> 512 </td>
    <td> Vertical size of the window, in pixels.</td>
  </tr>

  <tr>
    <td><code>int</code></td>    
    <td><code>nabs</code></td>
    <td> - </td>
    <td>Horizontal (abscissa) size of the virtual raster</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>absmin</code></td>
    <td><code>0</code></td>
    <td>Minimal value of he abscissa counter</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>absmax</code></td>
    <td><code>nabs-1</code></td>
    <td>Maximal value of the abscissa counter</td>
  </tr>

  <tr>
    <td><code>int</code></td>    
    <td><code>nord</code></td>
    <td> - </td>
    <td>Vertical (ordinate) size of the virtual raster</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>ordmin</code></td>
    <td><code>0</code></td>
    <td>Minimal value of he ordinate counter</td>
  </tr>
  
  <tr>
    <td><code>int</code></td>    
    <td><code>ordmax</code></td>
    <td><code>nord-1</code></td>
    <td>Maximal value of the ordinate counter</td>
  </tr>

  <tr>
    <td class="left"><code>codeblock</code></td>
    <td class="left"><code>pgm</code></td>
    <td class="left"><code>-</code></td>

    <td class="left">A k-program computing the colour of each virtual pixel of the
      output image. In the lexical scope of this program, local variables
      <code>abs</code>,
      <code>ord</code>,
      <!-- <code>app</code>, -->
      <code>red</code>,
      <code>grn</code> and
      <code>blu</code>
      (all real) are defined. If synonymous global variables
      exist, these local variables supercede those. 
      The variables <code>red</code>,
      <code>grn</code> and <code>blu</code> are output variables.
      Their values have to be computed (each of them must
      occur at least once in the left hand-sides of the assignments in the
      k-program). They are then cropped to the range <code>0..1</code> and
      represent correspondingly the red, green and blue components of the
      pixel colour. 
      Their values may depend on the read-only real variables
      <code>abs</code>
      and
      <code>ord</code>,
      <!-- <code>app</code>, -->
      for "abscissa" and "ordinate" of the image raster, which in this device
      are distinint from pixel enumeration. These scan
      <code>nabs</code> values from <code>absmin</code> to <code>absmax</code>,
      respectively
      <code>nord</code> values from <code>ordmin</code> to <code>ordmax</code>
      which are linearly mapped to 
      <code>width*height</code>
      of the X raster. 
    </td>
  </tr>

  <tr>
    <td class="left"><code>str</code></td>
    <td class="left"><code>filter</code></td>
    <td class="left"><code> "" </code></td>
    <td class="left">The mask of a shell command line that will receive the
      generated image (screen shot) in the PPM format; expected to be used to produce actual
      image file of the same, using appropriate NETPBM modules and/or other
      appropriate command-line tools. The mask can contain a C-style format
      field for printing a floating-point value, e.g. "%.0f" which can be used
      to enumerate the output files. </td>
  </tr>

  <tr>
    <td class="left"><code>k-expression</code></td>
    <td class="left"><code>filtercode</code></td>
    <td class="left"><code>t</code></td>
    <td class="left">a formula to compute the enumerator for the image files: 
      will be interpreted as a real and printed through the format defined
      by <code>filter</code> to produce the actuall shell command. </td>
  </tr>

</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>k_paintgl</code> device is as follows.
</p>

<pre>
k_paintgl when=out width=300 height=300 nabs=100 nord=100
  pgm={red=u(abs,ord,0,0); grn=u(abs,ord,0,1)/0.8; blu=0};
</pre>


<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/Barkley_model/ez.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_plot</h2>
<h3>Overview</h3>
Plots curves in the VGA graphics window. Unlike <code>k_draw</code>, this
device plots a whole curve at each call. 

<h3>Parameters</h3>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>int</code></td><td><code>col0</code></td><td> starting column of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>col1</code></td><td> end column of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>row0</code></td><td> starting row of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>row1</code></td><td> end column of graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>color</code></td><td> Color code of line graphics.</td>
</tr><tr>
<td><code>int</code></td><td><code>linewidth</code></td><td> Width of line.</td>
</tr><tr>
<td><code>int</code></td><td><code>absmin</code></td><td> Minimum value of variable.</td>
</tr><tr>
<td><code>int</code></td><td><code>absmax</code></td><td> Maximum value of variable.</td>
</tr><tr>
<td><code>int</code></td><td><code>clean</code></td><td>Clean or not.</td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>k_plot</code> device is as follows:
</p>

<pre>
k_plot name=uplot when=often 
  col0=col0 col1=col1 row0=row0 row1=row1 // defines the part of the graph window for this output
  color=WHITE*16+WHITE			  // colour of the "window" border	
  lines=1 				  // connect the dots
  clean=1                                 // clean window before drawing this graph
  ordmin=umin ordmax=umax		  // limits for the ordinate of the plot
  N=nx					  // the abscissa will be integer running from 1 to nx
  pgm={ord=u(abs,0,0,[u]);col=LIGHTRED};  // ordinate is value of u variable at the point, plot in light red
</pre>


<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_poincare</h2>

<h3>Overview</h3>

<p>
Watches a "trajectory", represented by a set of k-assignments, for the
moment when a chosen component of this trajectory crosses the zero level.
You can choose to watch for crossing up, crossing down, or
crossing in either direction.
</p>

<h3>Parameters</h3>

<p>
Since the <code>k_poincare</code> device works with a k-variable, it
does not apply to any subset of the dynamic grid, so must be run
with <code>nowhere=1</code>.
</p>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Default</th><th>Description</th>
</tr><tr>
  <td>
    <code>codeblock</code> </td>
    <td><code>pgm</code></td>
    <td><code>-</code></td>
    <td>Semicolon-separated set of
    k-assignments, defining the trajectory. Semantics of the
    k-assignments are not the same and are not straightforward; the
    details are explained below under "Typical syntax". 
  </td>
  </tr><tr>
    <td><code>int</code></td>
    <td><code>which</code></td>
    <td><code>0</code></td>
    <td>Identifies which trajectory component is watched for. Here
      <code>which=0</code> means it will be the component defined by
      the first assignment, <code>which=1</code> means it will be the
      second assignment, etc. </td>
  </tr><tr>
    <td><code>int</code></td>
    <td><code>sign</code></td>
    <td><code>1</code></td>
    <td>The sign of the crossings to be detected:
      <ul>
	<li><code>1</code> indicates positive crossings only (from negative to positive),</li> 
	<li><code>-1</code>  indicates negative crossings only (from positive to negative),</li>
	<li><code>0</code>  indicates that crossings in either direction will be accepted.</li>
      </ul>
    </td>
  </tr>
</table>
  
  <h3>Typical Syntax</h3>
  
<p>
The typical syntax of <code>k_poincare</code> device is as follows.
</p>

<pre>
k_poincare nowhere=1 sign=1 pgm={front1=U1-umid;tfront1=t};
</pre>

<p> In this example, parameter <code>which</code> defaults to
<code>0</code>, so the first component of the trajectory, defined by
the k-assignment <code>front1=U1-umid</code>, is watched for. As a
result, the value of k-variable <code>front1</code> will be
<code>1</code> if the value of the expression of <code>U1-umid</code>
has changed from negative to positive since the last call of this device;
and it will <code>0</code> otherwise. This counter-intuitive semantics
applies only to the k-assignment identified by the <code>which</code>
parameter. For all other k-assigments, the semantics is more
expectable: the k-variable in the left-hand side takes the value of
the k-expression in the right-hand side, <em>if the crossing has
happened</em>; otherwise the value of the k-variable in the left-hand
side remains unchanged. More precisely, the value of
the k-expression in the right-hand side is estimated for the "time of
crossing", using linear interpolation between the previous and the
current calls of the device. In the given example, there is only one
"other" assignment, and the interpolated
value of the step counter <code>t</code> will be stored
<code>tfront1</code>.  </p>

<h3>Instances of k_poincare in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">k_print</h2>
<h3>Overview</h3>

<p> Outputs values of k-expressions into a text file/stream. In that
it is different from <code>record</code> device which outputs only the
grid values. It is the possibile to repeat the output expressions
<code>N</code> times, with the expressions depend on k-variable
<code>i</code> local to this device which runs from 0 to
<code>N-1</code> inclusive. As the <code>record</code> device,
<code>k_print</code> uses a hierarchical set of separators, which are
<code>valuesep</code>, <code>fieldsep</code> and
<code>recordsep</code>. As a matter of convenience, some extra text at the
beginning of the file and/or at the beginning of each line may be specified. </p>

<p>
The <code>k_print</code> is allowed to work with k-expressions
involving global k-variables, but not any subset of the dynamic grid,
so must be run with <code>nowhere=1</code>.
</p>



<h3>Parameters</h3>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Default </th><th> Description </th>
</tr><tr>
<td><code>str</code></td><td><code>file</code></td><td>-</td><td> Path
to the output file.</td>
</tr><tr>
<td><code>int</code></td><td><code>append</code></td><td>0</td><td> Should the
file be appended to? (0 for no, 1 for yes) </td>
</tr><tr>
<td><code>str</code></td><td><code>filehead </code></td><td>""</td><td> Text to 
be placed at the beginning of the output file, or at the beginning of
  the newly written section, if the file is appended to.</td>
</tr><tr>
<td><code>str</code></td><td><code>headformat</code></td><td>""</td><td> If
  non-empty, defines the text in the beginning of each output line. May
contain a C format specifiers (using <code>%</code> sign), which will
  then be used to represent the current value produced by <code>headcode</code>.</td>
</tr><tr>
<td><code>k-expression</code></td><td><code>headcode</code></td><td>""</td><td>
 k-expression to be represented in <code>headcode</code>; evaluated as
real. </td>
</tr><tr>
<td><code>long</code></td><td><code>N</code></td><td>1</td><td> How man times
  should the contents of the <code>list</code> be output? </td>
</tr><tr>
<td><code>listblock</code></td><td><code>list</code></td><td>-</td><td> A list
  of k-expressions, separated by <code>;</code> and enclosed in <code>{...}</code> </td>
</tr><tr>
<td><code>str</code></td><td><code>valuesep</code></td><td>","</td><td> Separator
  between the values in the <code>list</code>. Must be at most 80 characters in length.</td>
</tr><tr>
<td><code>str</code></td><td><code>fieldsep</code></td><td>" "</td><td> Separator
  between different <code>i</code>-iterations of the output. Must be
  at most 80 characters in length.</td>
</tr><tr>
<td><code>str</code></td><td><code>recordsep</code></td><td>"\n"</td><td> Separator
  between records, i.e. outputs produced by individual calls of the
  device.</td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>k_plot</code> device is as follows:
</p>

<pre>
// Calculate and report the propagation speed to standard output
k_print nowhere=1 when=end file=stdout headformat="c=" headcode=0 list={(xout2-xout1)*hx/(T2-T1)};

// Output the record of dynamical variables u and v at the "samplepoint" 
// while "paceout" is nonzero into the file fhn1.rec.
k_print nowhere=1 when=paceout file=[0].rec append=0 valuesep="\t" list={U2;V2};
</pre>


<h3>Instances in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/singz.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0_ap.bbs
beatbox/data/scripts/parallel/Barkley/scroll.bbs
</pre>
and many more
    
<!-- ========================= -->
<h2 class="numbered">load</h2>

<h3>Overview</h3>
<p>
Loads data from a file saved by <code>dump</code> into the simulation
medium.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr><tr>
<td><code>str</code></td><td>file</td><td>Relative path to the file to
be read.</td>
</tr><tr>
<td><code>int</code></td><td>rewind</td><td>Should the file be rewound
before reading?</td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>load</code> device is as follows. Assuming
that the dynamical layers are between <code>ode_layer0</code> (a
number) and the layer <code>ode_layer1</code> the syntax for the dump
device is, and that the dump file (see above) has been saved to a file
called <code>my_dump_file.dmp</code>, then the syntax is:
</p>

<pre>
load when=begin v0=ode_layer0 v1=ode_layer1 append=0 file=my_dump_file.dmp;
</pre>
<h3>Instances of load in Example Scripts</h3>

<p>
All example scripts can be found in <code>beatbox/data/scripts</code> of the
package distribution. Examples of <code>load</code> device can be found in the
following:
</p>

<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1_load.bbs
</pre>

<p>
The purpose of this script is to give an example of the use of load
device.  The input that this file expects is the dump
file <code>fhn1.dmp</code>, say the one created by running the
<code>fhn1.bbs</code>. The script also produces its own dump file
at the end of the run. To run this script, use the following command:
</p>

<pre>
Beatbox_SEQ fhn1_load.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">matout</h2>

<h3>Overview</h3>
<p>
Saves grid data to a Matlab readable file ("MAT-file").  The current
implementation saves data as a 5-dimensional array, with dimensions
<code>v*z*y*x*t</code> (in that order, <code>v</code> index changing
the fastest, and <code>t</code> the slowest); any of these dimensions
may be equal to 1.  The (possibly counter-intuitive) order
<code>v*z*y*x</code> corresponds to the order in which the grid data
are allocated in BeatBox memory. The actual dimensions are not
specified as such, but are determined by this devices Space parameters
and the "decimation" parameters <code>dx,dy,dz,dv</code> defined
below.  The <code>t</code>-dimension is filled up one by one by
successive calls of this instance of <code>matout</code> device, by
the end of the current run the last timension of the output array will
be 7 if this instance has been called 7 times during the run, but will
contain a smaller array, with the corresponding correct value of the
<code>t</code>-dimension, if the job has been killed before
completion. 
</p>

<p>
The user has the choice of the Matlab type of data to be saved: the eight
integer types (from signed 8-bit to unsigned 64-bit) and two floating
point (single and double). The default is the BeatBox's main floating
point format (normally double, but depends on how BeatBox has been
compiled). For the integer types, the script will need to specify the
range of real numbers that is to be mapped to the full scale of the
integers representable by the chosen type. 
</p>

<p> <strong> Limitations: </strong>

<ul>

  <li> Currently the device is implemented only for the sequential
  mode, 

  <li> and ignores the geometry, i.e. outputs grid values in the same
  way for tissue points and void points. 
  
  <li> This implementation produces only non-compressed MAT-files,
  containing exactly one array with 5 dimensions, some of which may be
  equal to 1. If a compressed MAT-file and/or arrays without singleton
  dimensions are desired, one can process it in Matlab using its
  <code>load</code>, <code>squeeze</code> and <code>save</code>
  functions.</li>
  
  <li> Matlab documentation states that the format of MAT-files is
  endian-neutral in that Matlab will accept files written on machines
  with either endianness. However the current implementation is
  written on a little-endian platform and tested by Matlab running on
  the same platform. It will probably need to be
  amended if it is to be used on a big-endian platform.</li>

</ul>

<h3>Parameters</h3>


<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Default</th><th>Description</th>
</tr><tr>
  
<td><code>str</code></td><td><code>head</code></td><td>(automatic)</td><td>
  Text of the header of the MAT-file. Default is an automatically
  generated text reporting the version of BeatBox and the date and
  time of creation of the MAT-file</td>
</tr><tr>

<td><code>str</code></td><td><code>file</code></td><td>-</td><td>
    Relative path to the file to be written.</td>
</tr><tr>

<td><code>str</code></td><td><code>array_name</code></td><td>"beatbox"</td><td>
  Matlab name of the array to be created. This must be a valid Matlab
  identifier (not checked by BeatBox, so is the user's responsibility)</td>
</tr><tr>

<td><code>str</code></td><td><code>array_type</code></td><td>"native"</td><td>
  Matlab type of the array to be created. Valid values are:
  "int8",
  "uint8",
  "int16",
  "uint16",
  "int32",
  "uint32",
  "int64",
  "uint64",
  "single",
  "double",
  "native".
  In the integer types, prefix "u" stands for unsigned, and the
  digital postfix is the number of bits in the type, so in C terms, "uint8" is <code>unsigned
  char</code>, and "int64" is 8-byte signed <code>long int</code>. 
  Value "native" stands for the <code>real</code> (floating-point) type used by
  BeatBox for calculations (usually "double"). 
</td>
</tr><tr>

<td><code>real</code></td><td><code>u0</code></td><td>-</td><td>
  Only used when <code>array_type</code> is one of the integer types.
  Grid values that are less or equal to <code>u0</code> will be output
  as the minimal possible value allowed by <code>array_type</code>,
  e.g. <code>-128</code> for "int8". 
</td>
</tr><tr>

<td><code>real</code></td><td><code>u1</code></td><td>-</td><td>
  Only used when <code>array_type</code> is one of the integer types.
  Grid values that are greater or equal to <code>u1</code> will be output
  as the maximal possible value allowed by <code>array_type</code>,
  e.g. <code>127</code> for "int8".
  Grid values that are between
  <code>u0</code> and <code>u1</code> will be linearly interpolated
  and discretized to the full range of values allowed by
  <code>array_type</code>. 
</td>
</tr><tr>

<td><code>int</code></td><td><code>dx</code></td><td>1</td><td>
    
  Must be a positive integer. The output data will include only the
  points of the grid whose <code>x</code> coordinate is such that
  <code>x-x0</code> is divisible by <code>dx</code> where
  <code>x0</code> is value from this instance's Space parameters.

  E.g. for <code>dx=3</code>, every third gridpoint in <code>x</code>
  direction will be output.

</td>
</tr><tr>

<td><code>int</code></td><td><code>dy</code></td><td>1</td><td>
  Same, for the <code>y</code> dimension.     
</td>
</tr><tr>

<td><code>int</code></td><td><code>dy</code></td><td>1</td><td>
  Same, for the <code>z</code> dimension.
</td>
</tr><tr>
  
<td><code>int</code></td><td><code>dy</code></td><td>1</td><td>
  Same, for the <code>v</code> dimension. So, the overall size of data
  output to the MAT-file will be roughtly <code>dx*dy*dz*dv</code>
  times smaller than the default. 
</td>
</tr><tr>

<td><code>str</code></td><td><code>debug</code></td><td>-</td><td>
  Relative path to output file for debugging purposes. If
  <code>stdout</code>, will print to screen of the parent shell.
</td>
</tr><tr>

</table>

<h3>Example</h3>

<p>
of using this device is available as the test script 
<pre>
beatbox/data/tests/matout.bbs
</pre>

To run this script, use the following command:
</p>

<pre>
Beatbox_SEQ matout.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">poincare</h2>

<h3>Overview</h3>

<p>
This device has a similar purpose to <code>k_poincare</code> device
described above, but is more efficient and less flexible.  Rather than
watching for an arbitrary k-expression, it samples a dynamic variable
at a single point in the mesh, to detect a crossing in time of a
specified value. When the crossing has happened, the device just raises a
flag and remembers the value of the time step, linearly interpolated
to the moment of crossing, rather than that of any k-variable.
</p>

<h3>Parameters</h3>

<p>
The <code>poincare</code> device must be run on a single point. Upper
space parameters <code>x1</code>, <code>y1</code>, <code>z1</code>
and <code>v1</code> are unused by this device. The <code>v0</code>
space parameter is the grid layer from which dynamic variable is to be sampled at point
<code>(x0,y0,z0)</code>.
</p>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr><tr>
  <td>k-variable</td>
  <td><code>result</code></td>
  <td>Name of the k-variable into
which the result should be stored: 1 if a crossing has been detected
on this timestep, 0 otherwise. This must be a real variable.
</tr><tr>
  <td>k-variable</td>
  <td><code>timestep</code></td>
  <td> Name of the k-variable into which the timestep of the last crossing should be
    stored. An assignment will only be made to this variable on the
    timestep when a crossing is detected. This must be a real variable
    (even though it will be only assigned integer values).</td>
</tr><tr>
  <td><code>real</code></td>
  <td><code>cross</code></td>
  <td>The crossing threshold. If previous and
    current values of the sampled dynamic variable straddle<code>cross</code>, a
    crossing is detected.</td>
</tr><tr>
  <td><code>int</code>
  </td><td><code>sign</code></td>
  <td>The sign of the crossings to be detected:
    <ul>
      <li> 1 indicates positive crossings only,</li> 
      <li>-1 indicates negative crossings only,</li>
      <li> 0 indicates that crossings in either direction will be accepted.</li>
    </ul>
  </td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>poincare</code> device is as follows.
</p>

<pre>
poincare x0=xout y0=yout z0=zout v0=[u] cross=umid sign=1 result=front timestep=tfront;
</pre>

<p>
In this example, when the value of the <code>[u]</code> fild at point 

syntax, front1 will become 1 when the variable <code>U1</code>
is increasing (slope sign 1).  Additionally, the value of the integer
time counter <code>t</code> will be stored <code>tfront1</code>.
</p>

<h3>Instances of k_poincare in Example Scripts</h3>
<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn1.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">ppmin</h2>

<h3>Overview</h3>

<p>
Reads PPM images and maps its colour components into grid values; quasi-inverse of the <code>ppmout</code> device described below.
Makes little sense in actual simulations, but can be used e.g. for post-processing previously computed data recorded via <code>ppmout</code>.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr><tr>
<td><a href="#sequence"><code>sequence</code></a></td><td>file</td><td>Format specifier for
the sequence of the read files.</td>
</tr><tr>
<td><code>int</code></td><td><code>r</code></td><td> Layer of the
simulation medium to which the red colour channel is
mapped.</td>
</tr><tr> 
<td><code>real</code></td><td><code>r0</code></td><td> Value of the
layer <code>r</code> to which 0 of the red colour component is mapped. </td>
</tr><tr>
<td><code>real</code></td><td> <code>r1</code> </td><td> Value of the
layer <code>r</code> to which 255 of the red colour component is mapped. </td>
</tr><tr>
<td><code>int</code></td><td><code>g</code></td><td> Layer of the
simulation medium to which the green colour channel is
mapped.</td>
</tr><tr> 
<td><code>real</code></td><td><code>g0</code></td><td> Value of the
layer <code>g</code> to which 0 of the green colour component is mapped. </td>
</tr><tr>
<td><code>real</code></td><td> <code>g1</code> </td><td> Value of the
layer <code>g</code> to which 255 of the green colour component is mapped. </td>
</tr><tr>
<td><code>int</code></td><td><code>b</code></td><td> Layer of the
simulation medium to which the blue colour channel is
mapped.</td>
</tr><tr> 
<td><code>real</code></td><td><code>b0</code></td><td> Value of the
layer <code>b</code> to which 0 of the blue colour component is mapped. </td>
</tr><tr>
<td><code>real</code></td><td> <code>b1</code> </td><td> Value of the
layer <code>b</code> to which 255 of the blue colour component is mapped. </td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>ppmin</code> device is as follows.
</p>

<pre>
ppmin when=always
  file="[in]/%06d.ppm3"			// input files 
  filecode=t	                        // .. enumerated by the step number
  r=[u]    r0=umin r1=umax		// the first channel from u, umin->0, umax->255
  g=[v]    g0=vmin g1=vmax		// the second channel from v, ...
  b=[i]    b0=-1 b1=1			// the third channel from [i]; rarely used
;
</pre>

<h3>Instances of ppmin in Example Scripts</h3>

<p>
(none for the moment)
</p>


<!-- ========================= -->
<h2 class="numbered">ppmout</h2>

<h3>Overview</h3>

<p>
Produces PPM images of the space. Values from specified layers of the
simulation medium are mapped to colour channels by linear
interpolation using specified minima and maxima. ppmout produces a
new, sequentially numbered file every time it is run. In
three-dimensional meshes, ppmout produces non-standard PPM files, in
which multiple <code>z</code>-layers are stacked into a single
file. For a reading program, the <code>z</code> dimension an be
inferred from the <code>x</code> and <code>y</code> dimensions
specified in the PPM header and the file size. 
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Description</th>
</tr><tr>
<td><a href="#sequence"><code>sequence</code></a></td><td>file</td><td>Format specifier for
the sequence of files produced.</td>
</tr><tr>
<td><code>int</code></td><td><code>r</code></td><td> Layer of the
simulation medium from which the red colour channel should be
mapped.</td>
</tr><tr> 
<td><code>real</code></td><td><code>r0</code></td><td> Value of the
layer assigned to r that should map to 0. </td>
</tr><tr>
<td><code>real</code></td><td> <code>r1</code> </td><td> Value of the
layer assigned to r that should map to 255. </td>
</tr><tr>
<td><code>int</code></td><td><code>g</code></td><td> Layer of the simulation
medium from which the blue colour channel should be mapped.</td>
</tr><tr>
<td><code>real</code></td><td><code>g0</code></td><td> Value of the
layer assigned to <code>g</code> that should map to 0.</td>
</tr><tr>
<td><code>real</code></td><td><code>g1</code></td><td> Value of the
layer assigned to <code>g</code> that should map to 255.</td>
</tr><tr>
<td><code>int</code></td><td><code>b</code></td><td> Layer of the
simulation medium from which the green colour channel should be
mapped.</td>
</tr><tr>
<td><code>real</code></td><td><code>b0</code></td><td> Value of the
layer assigned to b that should map to 0.</td>
</tr><tr>
<td><code>real</code></td><td><code>b1</code></td><td> Value of the
layer assigned to <code>b</code> that should map to 255.</td>
</tr><tr>
<th colspan="3">Geometry Only</th>
</tr><tr>
<td><code>int</code></td><td><code>bgr</code></td><td> Red value of the
background colour, to be displayed at void points.</td>
</tr><tr>
<td><code>int</code></td><td><code>bgg</code></td><td> Green value of the
background colour, to be displayed at void points.</td>
</tr><tr>
<td><code>int</code></td><td><code>bgb</code></td><td> Blue value of
the background colour, to be displayed at void points.</td>
</tr>
</table>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>ppmout</code> device is as follows.
</p>

<pre>
ppmout file="ppm/%04d.ppm" mode="w" r=[u] r0=umin r1=umax g=[v] g0=vmin g1=vmax b=[i] b0=0 b1=255;
</pre>

<p>
where the red, green, and blue channel are defined by maximum,
minumum, and mid-point values of user defined dynamical variables.
</p>

<h3>Instances of ppmout in Example Scripts</h3>

<p>
All example scripts can be found in data/scripts of the package
distribution. Examples of <code>ppmout</code> device can be found in the following:
</p>

<pre>
beatbox/data/scripts/sequential/fhn2.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">record</h2>

<h3>Overview</h3>

<p>
Writes values from the computational grid to file(s) in ASCII
format. A hierarchical set of separators
— <code>vsep</code>, <code>xsep</code>, <code>ysep</code>
and <code>zsep</code> — are used between
values. <code>recordsep</code> is used between records, i.e. separate
runs of the record device.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
  <th>Type</th><th>Name</th><th>Default</th><th>Description</th>
</tr><tr>
  <td><a href="#sequence"><code>sequence</code></a></td>
  <td>filesequence</td>
  <td><code>""</code></td>
  <td>Format specifier for the sequence of files produced. This is alternative to <code>file</code>. Exactly one of these must be specified. </td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>file</code></td>
  <td><code>""</code></td>
  <td> Path to the (single) file to be written. This is alternative to <code>filesequence</code>. Exactly one of these must be specified. </td>
</tr><tr>
  <td><code>int</code></td>
  <td><code>append</code></td>
  <td><code>1</code></td>
  <td> Should the file be appended to? (0/1) </td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>filehead </code></td>
  <td><code>""</code></td>  
  <td> Text to be placed at the top of (each of) the record file(s).</td>
</tr><tr>
  <td><code>int</code></td>
  <td><code>timestamp</code></td>
  <td><code>0</code></td>
  <td>Should a time stamp showing the current value value of <code>t</code> precede each record? (0/1)</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>timestampformat</code></td>
  <td><code>"%-6ld\t"</code></td>
  <td>Format of the time stamp. May contain text but must contain a C format specifier for an integer.</td>
</tr><tr>
  <td><code>int</code></td>
  <td><code>timestampwidth</code></td>
  <td><code>8</code></td>
  <td>Number of characters to be occupied by a time stamp. Agreement with <code>timestampformat</code> is responsibility of the user.</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>format</code></td>
  <td><code>"%38f"</code></td>
  <td>Format for writing the recorded grid values. Must contain a C format specifier for a float.</td>
</tr><tr>
  <td><code>int</code></td>
  <td><code>formatwidth</code></td>
  <td><code>38</code></td>
  <td>Number of characters to be occupied by a grid value record. Agreement with <code>format</code> is responsibility of the user.</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>vsep</code></td>
  <td><code>"  "</code></td>
  <td> v-axis separator. Must be at most 2 characters in length.</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>zsep</code></td>
  <td><code>", "</code></td>
  <td> z-axis separator. Must be at most 2 characters in length.</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>ysep</code></td>
  <td><code>"; "</code></td>
  <td> y-axis separator. Must be at most 2 characters in length.</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>xsep</code></td>
  <td><code>" \n"</code></td>  
  <td> x-axis separator. Must be at most 2 characters in length.</td>
</tr><tr>
  <td><code>str</code></td>
  <td><code>recordsep</code>
  <td><code>"\n\n"</code></td>  
  </td><td> Record separator. Must be at most 2 characters in length.</td>
</tr>
</table>
<h3>Typical Syntax</h3>
The typical syntax of <code>record</code> device is as follows.
<pre>
record when=often file=output_record_file_name.rec append=0 x0=1 x1=xmax-1 y0=1 y1=ymax-1 z0=1 z1=zmax-1 v0=ode_layer0 v1=ode_layer1;
</pre>
<h3>Instances of record in Example Scripts</h3>
All example scripts can be found in data/scripts of the package distribution. Examples of
<code>record</code> device can be found in the following:
<pre>
beatbox/data/scripts/sequential/fhn0.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">reduce</h2>

<h3>Overview</h3>

<p>
Reduce performs a reduction operation — sum, product, minimum or
maximum — over its space. The result of the operation is assigned to a
specified k-variable.
</p>

<h3>Parameters</h3>

<table border="1">
<tr>
<th>Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>k-variable</code></td><td><code>result</code></td><td>Name of the k-variable into which the result should be stored.</td>
</tr><tr>
<td><code>str</code></td><td><code>operation</code></td><td> Name of the operation to
perform. Accepted values are “sum”, “product”, “min” and “max”. </td>
</tr><tr>
<td><code>str</code></td><td><code>debug</code></td><td> Name of the
  file to print debugging information to, possibly "stdout". </td>
</tr>
</table>

<h3>Typical Syntax</h3>
The typical syntax of <code>reduce</code> device is as follows.
<pre>
reduce name=U_sample operation=max v0=[u] result=U;
</pre>
<h3>Instances of reduce in Example Scripts</h3>
All example scripts can be found in data/scripts of the package distribution. Examples of
<code>reduce</code> device can be found in the following:
<pre>
beatbox/data/scripts/sequential/fhn0.bbs
beatbox/data/scripts/sequential/fhn1.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">rk4</h2>

<h3>Overview</h3>
<p>
Runge-Kutta 4th order; general pointwise ODE stepper for the rhs modules.
</p>

<h3>Parameters</h3>

<table border="1">
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="left">Name</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>ht</code></td>
<td class="left">Timestep duration.</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>ode</code></td>
<td class="left">Name of the RHS module to use.</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>rest</code></td>
<td class="left">If nonzero, the device will make so many steps with the given model to find an approximation of the initial conditions, and then fill the whole device space with this initial condition.</td>
</tr>

<tr>
<td class="left"><code>codeblock</code></td>
<td class="left"><code>par</code></td>
<td class="left">The parameters of the RHS module; their list depends on the module. The codeblock contains k-assignments of the form <code>&lt;parameter&gt;=&lt;k-expression&gt;</code>, separated by blank spaces.</td>
</tr>
</tbody>
</table>

<p>
The list and meaning of parameters are exactly the same as for the
<a href=#euler><code>euler</code></a> device; we repeat it here for
user's convenience. 
</p>

<p>
The parameter <code>ht</code> defines a duration of one time step used
by the solver.
</p>

<p>
The parameter <code>ode</code> is a name of the rhs module that implements the
cellular kinetics. This module is used for the simulation. The <code>ode</code>
model has to follow the rhs format.
</p>

<p>
The parameter <code>rest</code> is used if the device determines the initial
conditions of the dynamical variables by a steady state
approximation. The device runs the simulation for the number of steps
specified in <code>rest</code> using the initial conditions as specified in the
code of <code>rhs</code> module. 
</p>

<p>
Model dependent parameters of rhs module are passed to rk4 device
through the <code>par</code> parameter in <code>BBScript</code>. The assignment has to
follow the format <code>{&lt;parameter&gt;=&lt;value&gt;}</code> (within curly brackets <code>{}</code>
as shown). When multiple parameters are assigned, their definition
must be all given within the same curly brackets and each assignment
must be separated by a blank space (such as space, or newline).
</p>

<h3>Typical Syntax</h3>

<p>
The typical syntax of <code>rk4</code> device is precisely the same as
that of <a href=#euler><code>euler</code></a> device. For instance, 
</p>

<pre class="example">
rk4 when=run v0=[u] v1=[v] ht=ht ode=cgle par={alp=0 Omg=-1 bet=0};
</pre>
<p> (this is from the example quoted below). </p>

<h3>Instances of rk4 in Example Scripts</h3>

<p> One example is provided in
<code>beatbox/data/scripts/sequential/RK4</code> of the package
distribution. This example solves an initial-value problem for a
system of two coupled nonlinear ODEs, with a known exact solutions,
and prints out the norm of the difference between the numerical
solution and the exact answer at the final moment of time. The example
is complete with a <code>Makefile</code> which allows to compute a
series of runs and produce the graph of the numerical convergence,
illustrating the fourth-order accuracy of the solver.  </p>

<!-- ========================= -->
<h2 class="numbered">rushlarsen</h2>

<h3>Overview</h3>
<p>
The rushlarsen device is an integration device for ionic models which
allows to exploit Rush-Larsen exponential integration scheme for the
gate variables and Matrix Rush-Larsen scheme for the Markov
chains. The device tabulates the transition rates that depend on the
voltage (and possibly on unchangeable physical constants) before the
simulation time for the reference at the run time in order to speed-up
the simulations.
</p>

<p>
Ionic models have to be defined in a different way from a generic RHS
model description, as this definition has to make distinction between
gate variables and non-gate variables.
</p>

<p>
They do implement the formulas for the time derivative of all
dynamical variables only for "other" variables. The equations for
gating and Markov chain are implied from their standard from a
standard form and transition rates definition.  The details about the
definition of ionic modules is found in <i>specification of ionic modules.</i>
</p>

<h3>Parameters</h3>

<table id="tab:rushlarsen-bbs" border="1">
<caption class="t-above"><span class="table-number">Table 1:</span> Parameters to set up rushlarsen device in <code>BBScript</code></caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">type</th>
<th scope="col" class="left">name</th>
<th scope="col" class="left">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>ht</code></td>
<td class="left">time step duration.</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>ionic</code></td>
<td class="left">name of the cellular model in ionic format.</td>
</tr>

<tr>
<td class="left"><code>int</code></td>
<td class="left"><code>rest</code></td>
<td class="left">number of steps to approximate initial conditions of the dynamical variables (resting state). When the value is set to zero (<code>0</code>), the default initial conditions from the module are used.</td>
</tr>

<tr>
<td class="left"><code>codeblock</code></td>
<td class="left"><code>par</code></td>
<td class="left">model-dependent parameters of ionic module. The parameter is set by a codeblock in a form <code>par={&lt;parameter&gt;=&lt;value&gt;}</code> separated by blank spaces if more than one parameter is specified.</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>order</code></td>
<td class="left">the order of execution of substeps: one of <code>tog</code>, <code>tgo</code>, <code>totg</code>, where the substeps are done consecutively: <code>t</code> stands for table look-up, <code>o</code> stands for "other" variables and computation non-tabulated gates, <code>g</code> stands for tabulated gating variables.</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>exp_ngate</code></td>
<td class="left">defines method of computation of non-tabulated gates: non-zero for exponential (Rush-Larsen); zero (<code>0</code> default) for forward Euler method.</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>Vmin, Vmax</code></td>
<td class="left">minimal and maximal value of voltage for tabulation. Default is <code>-200</code>, <code>200</code> respectivelly.</td>
</tr>

<tr>
<td class="left"><code>real</code></td>
<td class="left"><code>dV</code></td>
<td class="left">voltage-step for the tabulation of gating transition rates. Default is <code>0.01</code>. Value <code>0.0</code> disables tabulation.</td>
</tr>

<tr>
<td class="left"><code>str</code></td>
<td class="left"><code>exp_mc</code></td>
<td class="left">specifies method of integration of Markov chains: <code>mcfe</code> forward Euler, <code>tabmrl</code> MRL with tabulation, <code>ntabmrl</code> MRL without tabulation (MRL only if subchain has a control variable, otherwise uses forward Euler)</td>
</tr>
</tbody>
</table>

<p>
The parameter <code>ht</code> defines the duration of one time step used in
forward Euler and Rush-Larsen calculations.
</p>

<p>
The model of cellular kinetics is passed to rushlarsen device through
the string parameter <code>ionic</code>. The module has to follow the ionic
format.
</p>

<p>
Module dependent coefficients in the model equations of the ionic
model can be set using the <code>BBScript</code> parameter <code>par</code>. This assignment
is done through a block of code in a form <code>&lt;parameter&gt;=&lt;value&gt;</code>. The
<code>&lt;parameter&gt;</code> is a name of the coefficient specific to the on
particular ionic module (specified in <code>ionic</code>). If more than one
"parameter" is specified all specification must be within the same
curly brackets and each assignment must be separated by a blank space.
</p>

<p>
The rushlarsen device can the approximate resting state of the
variables to be used as initial conditions. This is done by simulation
for the number of steps specified in <code>rest</code> parameter.
</p>

<p>
The computation of the different groups of dynamical variables
(i.e. tabulated and non-tabulated gates, and "other" variables), is
done consecutively. The particular order in which the computations are
performed can be controlled by the <code>order</code> parameter. The <code>order</code> can
be set to the value of one of the following codes: <code>tog</code>, <code>tgo</code>, or
<code>totg</code>. The order of letters in the codes corresponds to the order in
which the particular group is computed. The letter <code>t</code> stands for
finding the reference to a particular entry in a look up table of the
tabulated voltage-dependent gates. The letter <code>g</code> stands for computing
of the tabulated gates. The letter <code>o</code> stands for computing of the
remaining variables i.e. non-gating variables followed by computing of
non-tabulated gating variables and Markov chain variables.
</p>

<p>
For example, when the code <code>totg</code> is specifies the computation will be
done in the following order:
</p>

<ol class="org-ol">
<li>tabulated gates, followed by the computation of
</li>
<li>non-gating, non-tabulated and Markov chain variables, and then
</li>
<li>tabulated gates again (now for updated values of dynamical
variables), and finally the computation of
</li>
<li>tabulated gating variables.
</li>
</ol>

<p>
This is repeated for each time step during the whole simulation.
</p>

<p>
The parameter <code>exp_ngate</code> is used to choose the integration algorithm
of the non-tabulated gating variables. The value <code>0</code> (default) stands
for computation by forward Euler. If the value is non-zero, the
non-tabulated gates are computed using Rush-Larsen technique. In
cases, when the non-tabulated gates are not the source of numerical
instability the forward Euler method is faster, because it avoids
computationally expensive calculation of exponentials.
</p>

<p>
Three parameters are used to define the tabulation of the transition
rates of the voltage-dependent gate variables. Namely those parameters
set up the lower and upper limits of the tabulation by <code>Vmin</code> (default
<code>-200</code>) and <code>Vmax</code> (default <code>200</code>) respectively, and the step in the
voltage grid by <code>dV</code> (default <code>0.01</code>).
</p>

<p>
If the value of <code>dV=0.0</code>, the tabulation is be disabled and all
transition rates are computed on-the-fly. If the value of membrane
voltage exceeds the limits of tabulation, the transition rates are
found on-the-fly, until the value of voltage is restored to within the
given limits of the table.
</p>

<p>
Parameters for the integration of Markov chains <code>exp_mc</code> can be
provided in a <code>BBScript</code>. The possible values are <code>mcfe</code> for forward
Euler, <code>tabmrl</code> for MRL with tabulation, and <code>ntabmrl</code> for MRL without
tabulation. However, the method which can be used used on a particular
subchain depends on other characteristics of the subchain such as a
dependency of multiple variables.
</p>

<h3>Typical Syntax</h3>

<p>
The typical syntax of rushlarsen device is as follows. Assuming that
the ionic model occupies layers from between <code>ionic_layer0</code> to
<code>ionic_layer1</code>, the code of the ionic model that you are using od
ionic\<sub>model</sub> and the user-defined (different from the default) model
parameters with names <code>par1,par2</code> are contained in k-variables <code>p1,p2</code>,
the syntax is:
</p>

<pre class="example">
rushlarsen name=name_to_device_call v0=ionic_layer0 v1=ionic_layer1 ht=ht ionic=ionic_model exp_mc=tabmrl par={par1=p1; par2=p2;};
</pre>

<h3>Instances of <code>rushlarsen</code> in Example Scripts</h3>

<p>
All example scripts can be found in <code>beatbox/data/scripts</code> of the
package distribution. Examples of scripts for simulation of ionic
modules with rushlarsen device can be found in the following:
</p>

<pre class="example">
beatbox/data/scripts/sequential/BR/tog.bbs
beatbox/data/scripts/sequential/BR/tgo.bbs
beatbox/data/scripts/sequential/BR/otg.bbs
beatbox/data/scripts/sequential/CRN/compare1D.bbs
</pre>

<p>
for models without Markov chains.
</p>

<p>
See more detailed discussion of these scripts below in the sections
dedicated to the <code>br77</code> and <code>crn98</code> ionic models.
</p>

<p>
A script for simulation with Markov chain can be found in:
</p>

<pre class="example">
beatbox/data/scripts/hh52/hh52m.bbs
</pre>


<!-- ========================= -->
<h2 class="numbered">sample</h2>

<h3>Overview</h3>

<p>
Assigns a dynamic variable value from a specified point in the mesh to
a k variable.
</p>

<h3>Parameters</h3>

<p>
The sample device must be run on a single point. Upper space
parameters, <code>x1</code>, <code>y1</code>, <code>z1</code>
and <code>v1</code> are unused by this device. The <code>v0</code>
space parameter is the dynamic variable to be sampled at
point <code>(x0, y0, z0)</code>.
</p>

<table border="1">
<tr>
<th>Type </th><th> Name </th><th> Description </th>
</tr><tr>

<td><code>k</code> variable</td><td>result</td><td>Name of the k
variable into which the sampled value should be stored.</td>
</tr>
</table>

<h3>Typical Syntax</h3>
The typical syntax of <code>sample</code> device is as follows.
<pre>
sample x0=x_loc y0=y_loc z0=z_loc v0=ode_layer result=name_of_place_holder;
</pre>

<h3>Instances of sample in Example Scripts</h3>
All example scripts can be found in data/scripts of the package distribution. Examples of
<code>sample</code> device can be found in the following:
<pre>
beatbox/data/scripts/sequential/fhn0.bbs
beatbox/data/scripts/sequential/fhn1.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">singz</h2>
<h3>Overview</h3>
<p>
Detects, plots, remembers in k-variables and/or outputs to file the "singular points",
defined as intersections of isolines of two selected dynamic
fields. Mostly will be used to detect spiral wave tips. It also
computes the "tip orientation", in two ways: as the azymuthal angle of
the gradient of the first field (angle phi, in radians), and the same
for the second field (angle psi), and the cosine of the angle between
the two gradients.  Device <code>singz</code> is essentially
two-dimensional; when called in a 3D simulation, it simply does the
same job in every <i>z</i>=const cross-section, hence the 'z' in the
name of the device. At present, true three-dimensional filaments can
be obtained by post-processing, say by
<a href="http://empslocal.ex.ac.uk/people/staff/vnb262/software/EZView/">
<code>ezview</code>.
</a>
</p>

<p>
The results of the device are available in three forms:
shown graphically in the VGA graphics window, 
written in an output file
and remembered in k-variables.
The graphical window for the device is defined in
the usual way; the tips are represented by pixel-size dots, and the
tips from the most recent call are shown in a different colour; this
is controlled through standard device parameters (details to
follow). The file output is defined by specific device parameters, as
described below. Since there are potentially more than one
<code>z</code>-section involved, and each section may contain more
than one singular point, k-variables store statistics of the found
points: their total number, centroid and standard deviations of the
coordinates. 
</p>

<h3>Parameters</h3>
<table border="1">
<tr>
<th>Type</th><th>Name</th><th>Default</th><th>Description</th>
</tr><tr>
  
  <td><code>int</code></td><td><code>v0</code></td><td>&nbsp;</td><td>
    The layer in which the first dynamic field is located. 
  </td>
</tr><tr>

    <td><code>int</code></td><td><code>v1</code></td><td>&nbsp;</td><td>
    The layer in which the second dynamic field is located. 
  </td>
</tr><tr>

    <td><code>real</code></td><td><code>c0</code></td><td>&nbsp;</td><td>
    The constant defining the first dynamic field's isoline.
  </td>
</tr><tr>

    <td><code>real</code></td><td><code>c1</code></td><td>&nbsp;</td><td>
    The constant defining the second dynamic field's isoline.
  </td>
</tr><tr>

    <td><code>str</code></td><td><code>file</code></td><td>&nbsp;</td><td>
    Relative path to the output file that will contain the coordinates
    of the found singular points.
  </td>
</tr><tr>
  
  <td><code>int</code></td><td><code>append</code></td><td>0</td><td>
    Should the file be appended to?
  </td>
</tr><tr>


    <td><code>str</code></td><td><code>pointsep</code></td><td>"&nbsp;"</td><td>
      In the file output, separator between records of individual points
  </td>
</tr><tr>

    <td><code>str</code></td><td><code>sectionsep</code></td><td> <code>"\t"</code> </td><td>
      In the file output, separator between outputs from different z-sections, if any
  </td>
</tr><tr>

    <td><code>str</code></td><td><code>recordsepsep</code></td><td> <code>"\n"</code> </td><td>
      In the file output, separator between outputs from different calls of the device,
      done at different times. 
  </td>
</tr><tr>

    <td><code>int</code></td><td><code>everypoint</code></td><td> <code>0</code> </td><td>
      In the file output, time <code>t</code> value will precede
      coordinates of every found singularity point. 
  </td>
</tr><tr>

    <td><code>int</code></td><td><code>everysection</code></td><td> <code>0</code> </td><td>
      In the file output, time <code>t</code> value will precede
      the output from every z-section.
  </td>
</tr><tr>

    <td><code>int</code></td><td><code>everyrecord</code></td><td> <code>1</code> </td><td>
      In the file output, time <code>t</code> value will precede
      the output from every call of the device.
      <br />
      <strong>NB</strong> Exactly one of
      <code>everypoint,everysection,everyrecord</code> must be 1, the
      others must be 0. 
  </td>
</tr><tr>

    <td><code>int</code></td><td><code>precise_orientation</code></td><td>0</td><td>
      If nonzero, the orientation of the tips is calculated using a
      higher-order scheme, involving a 4x4 template.
      <br />
      Not available in
      MPI because the thickness of the inter-domain "halo" slices is
      restricted to one grid point.
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>Npoints</code></td><td></td><td>
      Name of the k-variable for the number of singular points. 
    </td>
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>xmean</code></td><td></td><td>
      Name of the k-variable for the mean <code>x</code>-coordinates of
    the singular points. 
    </td>
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>ymean</code></td><td></td><td>
      Name of the k-variable for the mean <code>y</code>-coordinates of
    the singular points. 
    </td>
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>zmean</code></td><td></td><td>
      Name of the k-variable for the mean <code>z</code>-coordinates of
    the singular points. 
    </td>
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>xstddev</code></td><td></td><td>
      Name of the k-variable for the standard deviation of the <code>x</code>-coordinates of
    the singular points. 
    </td>
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>ystddev</code></td><td></td><td>
      Name of the k-variable for the standard deviation of the <code>y</code>-coordinates of
    the singular points. 
    </td>
  
</tr><tr>
    <td><code>k-variable</code></td><td><code>zstddev</code></td><td></td><td>
      Name of the k-variable for the standard deviation of the <code>z</code>-coordinates of
    the singular points. 
    </td>
  
</tr>
</table>

<p> All k-variables must be of real type, and are optional
parameters. If a k-variable is not specified, the corresponding
quantity is not stored anywhere. The mean and standard deviation are
assigned only if nonzero number of points are detected. </p>

<h3>Typical Syntax</h3>

<p>
We give three examples, two from two-dimensional simulations and one
from a three-dimensional simulation. </p>

<p> As in
<a href="../data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs">
<code>beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs</code>:
</a>


<pre>
// Detect the tip of the spiral
singz when=out
  v0=[u] c0=0         // trace intersection of
  v1=[v] c1=0         // u(x,y,t)=0 and v(x,y,t)=0
  col0=col2 col1=col3 // plot it 
  row0=row0 row1=row1 // in the right panel
  color=WHITE*16+LIGHTRED // red trace with white head
  file=[0].trj        // and write into file fhn2.trj
;
</pre>

This will, at all time steps when the k-variable <code>out</code> is
nonzero, find intersections of the lines <i>u(x,y)=0</i> and
<i>v(x,y)=0</i>. The results will be shown in the area of the
graphic window between columns <code>col2</code> and
<code>colr3</code> and between rows <code>row2</code> and
<code>row3</code>. The tips will be shown by pixel-size dots, light-red for
"previous" points and white for the most recent points. The results
will be also output into a disk file, eponymous with the script except the
extension <code>.trj</code>. This example uses default values of the
output customization parameters, which will generate output like

<pre>
         0  50.757942 50.763065 0.891785 -0.556892 0.121816 	
       100  51.842682 52.343216 0.983348 -0.491837 0.095465 	
       200  51.964546 53.362553 1.206323 -0.253890 0.110358 	
       300  51.616615 54.403961 1.372360 0.091922 0.286295 	
       400  50.858425 55.406269 1.458319 0.323225 0.422047 	
 ...
</pre>

where
the first column contains values of the time step counter
<code>t</code>;
the secondcolumn contains <code>x</code>-coordinates of the
singular points,
the third column contains <code>y</code>-coordinates of the
singular points,
the fourth and fifth columns contain the polar angles of the gradient
vectors of the first field <code>v0=[u]</code> and of the second field
<code>v1=[v]</code> used for the tip detection, estimated at the tip,
and the sixth column contains the cosine of the angle between the two
gradients. 
</p>


<p> As in
<a href="../data/scripts/sequential/FitzHughNagumo_model/singz.bbs">
<code>beatbox/data/scripts/sequential/FitzHughNagumo_model/singz.bbs</code>:
</a>

<pre>
// Detect the tip of the spiral
def real ntip; def real xtip; def real ytip; // k-variables to record the tip
singz when=out
  v0=[u] c0=0         // trace intersection of
  v1=[v] c1=0         // u(x,y,t)=0 and v(x,y,t)=0
  Npoints=ntip 	      // number of tips detected
  xmean=xtip          // ... their mean x coord 
  ymean=ytip          // ... their mean y coord
;
</pre>

This will work as in the previous example, except the found tips are
neither drawn on screen nor recorded into the file, but are just
remembered in k-variables <code>xmean</code> and
<code>ymean</code>. These variables can be used in other devices. In
this particular example, these are used by <code>k_draw</code> to
display on screen as a curve (rather than by dots), and by
<code>k_print</code> to output to a file. 
<br />
NB: <code>ntip</code> is a real variable, even though it is
intended to contain only integer values. Thanks to this, this variable
can be used as a control variable by other devices, which are intended
to work if and only if a nonzero number of tips are recorded. </p>

<p> As in
<a href="../data/scripts/parallel/Barkley/scroll.bbs">
<code>beatbox/data/scripts/parallel/Barkley/scroll.bbs</code>:
</a>

<pre>
singz when=often 
          file=[outdir]/singz.dat append=0 
          v0=[u] c0=umid 
          v1=[v] c1=vmid
          everypoint=1 
          everysection=0 
          everyrecord=0
          pointsep="\n" 
          sectionsep="" 
          recordsep="\n"
;
</pre>

This is a 3D simulation and parameters <code>every...</code> and
<code>...sep</code> are chosen non-default. This device will only do
file output, which looks like this:

<pre>
         0 40.917686 40.583931 1.000000 0.724878 1.409299 0.774785
         0 40.899208 40.603081 2.000000 0.705210 0.175109 0.862756
         0 40.879932 40.623329 3.000000 0.332309 0.257325 0.997190
         0 40.859558 40.645096 4.000000 2.811086 0.256183 -0.832778
         0 40.837597 40.669064 5.000000 0.618518 0.096927 0.867028
...


        14 40.991848 42.630165 15.000000 3.056580 -3.002670 0.975031
        14 40.968472 42.656673 16.000000 0.429959 -0.182781 0.818076
        14 40.943298 42.676113 17.000000 2.346203 -3.094432 0.665562
        14 40.914688 42.689327 18.000000 0.760891 -0.161832 0.603651
        14 40.878613 42.699989 19.000000 1.629990 -1.939269 -0.909936
...


        28 40.983856 43.442799 21.000000 1.105454 -2.485222 -0.900845
        28 40.935574 43.450146 22.000000 1.148618 -0.336345 0.085727
        28 40.887096 43.457321 23.000000 0.525845 -0.246125 0.716538
        28 40.834824 43.464394 24.000000 3.000749 -0.231454 -0.995898
        28 40.780441 43.471146 25.000000 0.581991 -0.102920 0.774476
...
</pre>

There is now more columns than in the 2D case: the added is the fourth
column, which contains the <code>z</code>-coordinates of the tip
points. The lines corresponding to different values of time counter
are separated by extra empty lines; however, if this is run in
parallel, there may be extra empty lines, which are to be eliminated
by postprocessing.
</p>
<p class="quest"> This may be considered as a "feature" that hopefully will be fixed a some stage. 
</p>

<h3>Instances of sample in Example Scripts</h3>

<p> Examples of
<code>singz</code> device can be found in the following:
</p>

<pre>
beatbox/data/scripts/BeatboxWorkshop/CRN_model/pd_crn2.bbs
beatbox/data/scripts/BeatboxWorkshop/FitzHughNagumo_model/fhn2.bbs
beatbox/data/scripts/parallel/Barkley/scroll.bbs
beatbox/data/scripts/parallel_Hector/phasedbn_parallel/pd_crn2.bbs
beatbox/data/scripts/sequential/Barkley_model/implicit.bbs
beatbox/data/scripts/sequential/CRN_model/pd_crn2.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn2.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn_crossFieldStim_ffr_slice.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn_spiral_ffr_slice.bbs
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn_spiral_ffr_slice_aniso.bbs
beatbox/data/tests/fhn2.bbs
beatbox/data/tests/fhn3.bbs
beatbox/data/tests/fhn3side.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">stop</h2>
<h3>Overview</h3>
<p>
Stops the simulation run.
</p>
<h3>Parameters</h3>
<p>
None.
</p>
<h3>Typical Syntax</h3>
The typical syntax of <code>stop</code> device is as follows. Assuming 
that the variable for end has been defined in the variable <code>end</code>, the syntax is
<pre>
stop when=end;
</pre>
<h3>Instances of stop in Example Scripts</h3>
All bbs scripts must have a call to the stop device. The stop devices occurs
in all the example bbs scripts.

<!-- ========================= -->
<h2 class="numbered">update</h2>

This device updates the VGA run time visualisation window.  Typically this is
expected to be called in the end of each lap in which any VGA graphics output
was done.

<h3>Parameters</h3>
<table border="1">

  <p>
  This device does not have any device-specific parameters. It only uses the
  standard <code>when</code> parameter.
  </p>

<h3>Typical Syntax</h3>

<pre>
update when=often; // run time graphics are updated when often is true.
</pre>

<h3>Instances in Example Scripts</h3>

<pre>
beatbox/data/sequential/pd/scripts_crn0.bbs
beatbox/data/sequential/pd/scripts_crn1.bbs
</pre>

<!-- ========================= -->
<h2 class="numbered">vtkout2</h2>
<h3>Overview</h3>
<p>
Outputs legacy VTK file for 2D model. The header is in ASCII, and the data
are in double binary format.
</p>
<h3>Parameters</h3>
<p>
<table border="1">
<tr>
<th> Type </th><th> Name </th><th> Description </th>
</tr><tr>
<td><code>int</code></td><td><code>r</code></td><td>Dynamical layer to output</td>
</tr><tr>
<td><code>int</code></td><td><code>r0, r1</code></td><td>minimum and maximum of the expected values in later r</td>
</table>
<h3>Typical Syntax</h3>
<pre>
/* Note: the g and b layers are there to allow vtkout2 syntax to be similar to the ppmout syntax */
vtkout2 when=often file="vtk/fk2%06d.bin.vtk" mode="w" r=[u] r0=umin r1=umax g=[v] g0=vmin g1=vmax b=[i] b0=0 b1=255;
</pre>
<h3>Instances in Example Scripts</h3>
data/scripts/sequential/FentonKarma_model/fk2_san.bbs

<!-- ========================= -->
<h1 class="numbered">Beatbox Cell Model Reference</h1>

<!-- ========================= -->
<h2 class="numbered">Generic ODE definitions</h2>

<p> We present here only a very brief outline of the most popular
models available in Beatbox. For the full list of available models,
see <code>beatbox/src/rhslist.h</code>. For the detailed description
of a model with code name e.g. "<code>rhsmodel</code>", employed
e.g. by <code>euler</code> device via <code>ode=rhsmodel</code>, see
<code>beatbox/src/rhsmodel.c</code>. You are welcome to contact the
developers for clarifications. </p>

<!-- ========================= -->
<h3 class="numbered">ap: Aliev-Panfilov cell model </h3>

<p>
This model was published in:
</p>

<blockquote>
R. R. Aliev and A. V. Panfilov, 
"A Simple Two-variable Model of Cardiac Exciation", 
<i>Chaos Solitons and Fractals</i>
  <b>7</b>(3):293-301, 1996.
</blockquote>

It aims to mimick the realistic shape of cardiac AP and APD
restitution curves. It involves 2 dynamic variables. The variable
representing the voltage is in layer 0. Both variables are
dimensionless.

<!-- ========================= -->
<h3 class="numbered">cgle: Complex Ginzburg-Landau equation</h3>

<p>
This RHS module is not a cellular model as such, but can be used to
run simulations of the important theoretical reaction-diffusion
system, known as Complex Ginzburg-Landau Equation, assumed in the
complex-valued form
</p>

<p class="math">
 &part;<i>w</i>/&part;<i>t</i>
  &nbsp;=&nbsp;
  (1+<i>i</i>&Omega;) <i>w</i>
  +
  (-1+<i>i</i>&alpha;) <i>w</i>|<i>w</i>|<sup>2</sup>
  +
  (1+<i>i</i>&beta;) &nabla;<sup>2</sup><i>w</i>
</p>

<p> (different but equivalent formulations can be found in literature). 
The RHS module consists of 2 dimensionless variables, layer 0 containing the
real part <i>u</i> and layer 1 containing the imaginary part <i>v</i> of the complex
field <i>w</i>. Apart from <code>Omg</code> for &Omega;,
<code>alp</code> for &alpha; and <code>bet</code> for &beta;, this
module accepts parameters <code>Iu</code> and <code>Iv</code>, which
are expected to contain the Laplacians of the fields <i>u</i> and
<i>v</i> respectively, perhaps computed by the <code>diff</code>
device.  This RHS module is used in one example in the distribution,
in <code>beatbox/data/scripts/sequential/RK4</code>. See the
description of the <a href=#rk4><code>rk4</code></a> device for detail
of this example. </p>

<!-- ========================= -->
<h3 class="numbered">crn: Courtemanche-Ramirez-Nattel 1998 cell model</h3>

<p>
This model was published in:
</p>

<blockquote>
"Ionic mechanisms underlying human atrial action potential properties:
insights from a mathematical model", by Courtemanche M, Ramirez RJ,
Nattel S<i>, Am J Physiol Heart Circ Physiol</i>
<b>275:H301-H321.</b>: pp. H301-H321, 1998,
</blockquote>

<p> and simulates the human atrial action potential. It consists of 21
variables. The voltage is in layer 0 and is in millivolts. This
implementation is based on code received from the M. Courtemanche. It
does not provide the true ODE right-hand sides, instead it performs
the timestep, using Rush-Larsen formula for all gating variables and
explicit Euler for all other variables.  Hence it requires the time
step as parameter <code>ht</code>.  The example of CRN cell model AP
is in: </p>

<pre>
beatbox/data/scripts/sequential/CRN_model/crn0_ap.bbs
</pre>

<p>
This script requires no input and outputs a vtg file with the AP
data. It can be run using:
</p>

<pre>
Beatbox_SEQ crn0_ap.bbs
</pre>

<p>
You can produce an AP profile as shown in the figure below.
</p>

<table>
<tr><td>
  <img
    src="imgs/crn0_ap.png"
    width="294" height="240"
    alt="CRN AP profile."
    style="margin:auto;display:block;"
    id="fig-8"/>
</td></tr>
</table>

<!-- ========================= -->
<h3 class="numbered">fk: Fenton Karma cell model</h3>

<p>
The Fenton Karma model (FK) consists of 3 variables. It aims to mimick
the realistic cardiac AP and APD shape as well as the most principal
features of the structure of the right-hand sides typical for realisic
ionic cardiac exciation models. The voltage is in layer 0. This model
was published in:
</p>
<blockquote>
"Vortex dynamics in three-dimensional continuous myocardium with fiber
rotation: Filament instability and fibrillation", by F Fenton and A
Karma, <i>Chaos</i>, <b>8(1):</b> pp. 20-47, 1998.
</blockquote>

<p>
The example of FK cell model AP is in:
</p>

<pre>
beatbox/data/scripts/sequential/FentonKarma_model/fk0_ap.bbs
</pre>

<p>
This bbs script has no inputs, and its output is a record file called
fk0_ap.vtg.  To run, use the command:
</p>

<pre>
Beatbox_SEQ fk0_ap.bbs
</pre>

<p>
After running this bbs script, you can produce an AP profile as shown
in the figure below.
</p>

<table>
<tr><td>
  <img
    src="imgs/fk0_ap.png"
    width="294" height="240"
    alt="FHN AP profile."
    style="margin:auto;display:block;"
    id="fig-4"/>
</td></tr>
</table>

<!-- ========================= -->
<h3 class="numbered">fkmod: Fenton-Karma Modified cell model</h3>

<p>
This is a variation of the FK model (previous subsection) was modified during the Beatbox
project (2011-2013) and developed to produce mouse sinoatrial node and
atrial action potentials. It has been accepted for publication as
a <i>IEEE Proceedings (EMBC 2013)</i>. The examples of the cell model are in:
</p>

<pre>
beatbox/data/scripts/sequential/FentonKarma_model/fk0_atrial.bbs
beatbox/data/scripts/sequential/FentonKarma_model/fk0_san.bbs
</pre>

<p>
where a <code>Makefile</code> detailing the SAN and atrial command
line inputs is give. To run the atrial cell, type:
</p>

<pre>
make atrial
</pre>

<p>
and to run the SAN cell, type:
</p>

<pre>
make san
</pre>

<p>
We get this figure for SAN AP:
</p>

<table>
<tr><td>
  <img
    src="imgs/fkmod_san.png"
    width="294" height="240"
    alt="FKMOD SAN AP profile."
    style="margin:auto;display:block;"
    id="fig-5"/>
</td></tr>
</table>

<p>
and atrial AP profile as shown below.
</p>

<table>
<tr><td>
  <img
    src="imgs/fkmod_atrial.png"
    width="294" height="240"
    alt="FKMOD SAN AP profile."
    style="margin:auto;display:block;"
    id="fig-6"/>
</td></tr>
</table>



<!-- ========================= -->
<h3 class="numbered">fhncub, fhncubpar: FitzHugh-Nagumo cell model</h3>

<p>
This model was published in:
</p>

<blockquote>
"Varieties of spiral wave behavior: An
experimentalist’s approach to the theory of excitable media", by
Arthur Winfree, <i>Chaos</i> <b>1(3):</b> pp. 303-334, 1991,
</blockquote>

<p> and simulates anc action potential in generic excitable system. It
consists of 2 variables. The voltage is in layer 0. Both variables are
dimensionless. The <code>fhncubpar</code> is different in that it
involves more parameters, not present in the original FitzHugh and
Winfree formulations. The example of FHN cell model AP is in: </p>

<pre>
beatbox/data/scripts/sequential/FitzHughNagumo_model/fhn0_ap.bbs
</pre>

<p>
This bbs script has no inputs, and its output is a record file called
<code>fhn_ap.vtg</code>.  To run, use the command:
</p>

<pre>
Beatbox_SEQ fhn0_ap.bbs
</pre>

<p>
After running this bbs script, you can produce an AP profile as shown
in the figure below.
</p>

<table>
<tr><td>
  <img
    src="imgs/fhn0_ap.png"
    width="294" height="240"
    alt="FHN AP profile."
    style="margin:auto;display:block;"
    id="fig-3b"/>
</td></tr>
</table>

<!-- ========================= -->
<h3 class="numbered">lrd: Luo-Rudy "dynamic" cell model</h3>

<p>
This model was published in:
</p>

<blockquote>
"A dynamic model of the cardiac ventricular action potential", by CH
Luo and Y Rudy, <i>Circ. Res.</i>, <b>74(6):</b> pp. 1071-1096, 1994,
</blockquote>

<p> and simulates the human ventricular action potential.  It consists
of 24 variables. The voltage is in layer 0 and is in millivolts. This
code is based on Darren Sandham's code, University of Liverpool,
2005. The time integration of gating variables is sneakily using Rush-Larsen
method, hence the list of required paramters includes the times step
<code>ht</code>; other variables are expected to be treated in the
usual way via explicit Euler or any other timestepping method. 
The example
of LRd cell model AP is in: </p>

<pre> beatbox/data/scripts/sequential/LRD_model/lrd0_ap.bbs </pre>

<p>
This script requires no input and outputs a vtg file with the AP
data. It can be run using:
</p>

<pre>
Beatbox_SEQ lrd0_ap.bbs
</pre>

<p>
You can produce an AP profile as shown in the figure below.
</p>

<table>
<tr><td>
  <img
    src="imgs/lrd0_ap.png"
    width="294" height="240"
    alt="LRD AP profile."
    style="margin:auto;display:block;"
    id="fig-7"/>
</td></tr>
</table>

<!-- ========================= -->
<h3 class="numbered">ms: Mitchell-Schaeffer  cell model</h3>

<p> This is a popular 2-variable variant of the Fenton-Karma model.
It was published in
<blockquote>
  C C Mitchell and D G Schaeffer, 
  "A Two-Current Model for the Dynamics of Cardiac Membrane"
  Bull Math Biol 65: 767-793 (2003). 
</blockquote>

<!-- ========================= -->
<h3 class="numbered">ttnnp04: Ten Tussscher et al. 2004 cell model</h3>
<p>
This model was published in:
</p>

<blockquote> "A model for human ventricular tissue", by
K. H. W. J. ten Tusscher, D. Noble, P. J. Noble and A. V. Panfilov,
<i>Am J Physiol Heart Circ Physiol</i> <b>286</b>: pp. H1573-H1589,
2004, </blockquote>

<p>
and simulates the human ventricular action potential. It consists of
17 variables. The voltage is in layer 0 and is in millivolts. 
This implementation is based on
<a href="http://www-binf.bio.uu.nl/khwjtuss/SourceCodes/HVM/Source/">
author's code</a> retrieved 2013/02/02. It does not provide the true
ODE right-hand sides, instead it performs the timestep, using
Rush-Larsen formula for all gating variables and explicit Euler for
all other variables.  Hence it requires the time step as
parameter <code>ht</code>.
</p>

<pre>
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttnnp04_ap.bbs
</pre>

<p>
Beatbox program to demonstrate the ten Tusscher et al. 2004 human
ventricle AP.  There are no inputs,and the output is ttnnp04_ap.vtg.
To run,
</p>

<pre>
Beatbox_SEQ ttnnp04_ap.bbs
</pre>

<p>
You can produce an AP profile as shown in the figure below.
</p>

<table>
<tr><td>
  <img
    src="imgs/ttnnp04.png"
    width="294" height="240"
    alt="TTNP AP profile."
    style="margin:auto;display:block;"
    id="fig-9"/>
</td></tr>
</table>

<!-- ========================= -->
<h3 class="numbered">ttnp, ttp06: Ten Tusscher-Panfilov 2006 cell model</h3>

<p>
This model was published in:
</p>

<blockquote>
"Alternans and spiral breakup in a human ventricular tissue model", by
K. H. W. J. ten Tusscher and A. V. Panfilov,
<i>J Physiol Heart Circ Physiol</i> <b>291</b>: pp. H1088–H1100, 2006, 
</blockquote>

<p> and simulates the human ventricular action potential. It consists
of 19 variables. The voltage is in layer 0 and is in millivolts. </p>

<p> The <code>ttnp</code> implementation is based on the
CELLML description of the model, and provides true ODE description of
right-hand sides. Note
that the resulting ODEs are very stiff and require very small time
steps.</p>

<p> The <code>ttp06</code> implementation is based on <a
href="http://www-binf.bio.uu.nl/khwjtuss/SourceCodes/HVM2/Source/">
author's code </a> retrieved 2013/02/08. This implementation does not
provide the true ODE right-hand sides, instead it performs the
timestep, using Rush-Larsen formula for all gating variables and
explicit Euler for all other variables.  Hence it requires the time
step as parameter <code>ht</code>.</p>

<p> An example using <code>ttnp</code> implementations given in </p>

<pre>
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttp06_ap.bbs
</pre>

<p> produces an AP. There are no inputs,and the output is
ttp06_ap.vtg.  To run, </p>

<pre>
Beatbox_SEQ ttp06_ap.bbs
</pre>

<p>
This should produce an AP profile as shown in the figure below.
</p>

<table>
<tr><td>
  <img
    src="imgs/ttp06_ap.png"
    width="294" height="240"
    alt="TTNP AP profile."
    style="margin:auto;display:block;"
    id="fig-10"/>
</td></tr>
</table>

<p> An example simulating an AP using the  <code>ttp06</code>
implementation is given in
</p>

<pre>
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttp06.bbs
</pre>

and should produce an AP profile like this: 

<table>
<tr><td>
  <img
    src="imgs/ttp06.png"
    width="294" height="240"
    alt="TTNP AP profile."
    style="margin:auto;display:block;"
    id="fig-11"/>
</td></tr>
</table>

<p>
A slightly more advanced example of this model can be found in the directory:
</p>
<pre>
beatbox/data/scripts/sequential/TenTusscherPanfilov_modelS/ttp06/
</pre>

<p>
The <code>benchmark.bbs</code> script there does the computational
job, <code>Makefile</code> describes the workflow leading to the final
report and <code>report.pdf</code> is the report itself.
</p>


<!-- ========================= -->
<h2 class="numbered">Ionic model definitions</h2>

<!-- ========================= -->
<h3 class="numbered">BR77</h3>

<p>
This model was published in:
</p>

<blockquote>
"Reconstruction of the action potential of ventricular myocardial
fibres",
by G. W. Beeler and H. Reuter, 
<i>J Physiol</i> <b>268</b>: pp. 177-210, 1977,
</blockquote>

<p>
and is an early model of the mammalian ventricular action
potential. It consists of two non-gating variables variables (<code>V,
ca</code>) and six gating variables (<code>x1,m,h,j,d,f</code>). The
tabulated functions are the 12 transition rates for the six gates,
plus the voltage-dependent functions <code>ik1</code> and
<code>gix1</code>. The voltage is in layer 0. The name of the ionic model
is <code>br77</code>. This implementation is based on the paper.
following scripts simulates the AP:
</p>

<pre>
beatbox/data/scripts/sequential/BeelerReuter_model/tgo.bbs
beatbox/data/scripts/sequential/BeelerReuter_model/tgo.bbs
beatbox/data/scripts/sequential/BeelerReuter_model/tog.bbs
</pre>

<p>
for different orders of execution of the substeps in the Rush-Larsen
scheme. These scripts simply calculate the action potentials for the
initial condition which is the voltage value of 50 mV above the
resting state and all other variables above the resting state. They
take two command-line parameters, one is the value of the time step,
and the other the name of the output file for the action
potential. The action potential is output in two columns, first for
the time, in milliseconds, and the second for the voltage in
millivolts. 
</p>

<!-- ========================= -->
<h3 class="numbered">CRN98</h3>

This model was published in:
</p>

<blockquote>
"Ionic mechanisms underlying human atrial action potential properties:
insights from a mathematical model", by Courtemanche M, Ramirez RJ,
Nattel S<i>, Am J Physiol Heart Circ Physiol</i>
<b>275:H301-H321.</b>: pp. H301-H321, 1998.
</blockquote>

<p>
This is the same model as implemented in the "generic" RHS module
<code>crn</code> with the following differences:
<ul>
  <li> Three of the "dynamic variables" of the <code>CRN</code> module are in
  fact not dynamic variables, i.e. there are no differential equations
  for them, but they are explicit functions of the true dynamic
  variables, so they have been removed from the list of dynamic
  variables, thus shortening the length of the state vector from 24 to
  21. The removed variables are <code>cmdn,trpn,csqn</code>, they
  describe the states of the Ca buffers and are taken in the
  quasi-stationary approximation.
  
  <li> As required by the "ionic cell" format, the description of
  dynamics of gating variables and non-gating variables are separated,
  which allows the <code>rushlarsen</code> device to update gates by
  Rush-Larsen scheme. In that case the choice <code>order=tog</code>
  gives the the closest results to the <code>CRN</code> module, which
  corresponds to the Courtemanche's author code; exact correspondence
  is not possible as Courtmanche's code intermingles updates of
  different classes of variables. The best accuracy is however
  achieved at <code>order=totg</code>.</li>
</ul>

<p>
The voltage is in layer 0. The name of the ionic model
is <code>crn98</code>. This implementation is based on the
Courtemanch's author code, with necessary transformations to bring it
to the require format. An example of using this model can be found in 
</p>

<pre>
beatbox/data/scripts/sequential/CRN/compare1D.bbs
</pre>

<p>
which calculates simultaneous propagation of pulses in the 1D cable in
the two implementations of the Courtemanche et al. 1998 model, one
with <code>euler</code> device and <code>crn</code> model, and the
other with <code>rushlarsen</code> device and <code>crn98</code>
model. The script does not take any command-line parameters and does
no output to disk files apart from the log file.  The state vector for
the <code>crn</code> model is allocated in layers from 0 to 23, and
for the <code>crn98</code> model in layers from 24 to 44, with layer
45 used as auxiliar layer for calculating the diffusion. Unlike many
other examples, this script uses <code>diffstep</code> instead of
<code>diff</code>, so it can use the same layer 45 for both diffusion
operators, and does not require passing the value of the diffusion
terms to the kinetic timesteppers <code>euler</code> and
<code>rushlarsen</code> via the usual layer-substitution trick such as
<code>IV=@[aux]</code>. Both solutions are plotted on screen so the
user can visually compare the correspondence between the two
implementations. At the chosen parameters, the two curves
would almost completely overlap hence they are plotted with a shift of
one pixel horizontally (notice the <code>col0</code> and
<code>col1</code> parameters of the two <code>k_plot</code>
devices. The user is invited to experiment with different
<code>order</code> choices and discretization steps.
</p>


<h3 class="numbered">TTP2006</h3>

<p>
This model is a reformulation of the authors code
<i><code>ttp06</code></i> published as:
</p>

<blockquote>
<p>
"Alternans and spiral breakup in a human ventricular tissue model", by
K. H. W. J. ten Tusscher and A. V. Panfilov, <i>J Physiol Heart Circ
Physiol</i> <b>291</b>: pp. H1088 &#x2013;H1100, 2006,
</p>
</blockquote>

<p>
The name of the module is <code>ttp2006</code>.
</p>

<p>
The total calcium concentration in each compartment (Sarcoplasmic
Reticulum, sub-space, and bulk intracellular space) are now given as
differential equations. The dissolved calcium concentration is then
obtained using a formula for quasi-stationary approximation.
</p>

<p>
This module is written in ionic format. This includes the following
differences with respect to <code>ttp2006</code>:
</p>

<ul class="org-ul">
<li>the variables were divided to: tabulated gates (dependent only on
voltage), non-tabulated gates (dependent on other variables (here on
calcium concentrations), and other variables (voltage, and ionic
concentrations; as required by the rushlarsen device.
</li>
<li>The RR gate of the RyR receptor on sarcoplasmic reticulum is now
calculated using rushlarsen formula.
</li>
</ul>

<h3 class="numbered"> HH52</h3>

<p>
The model converts the Hodgking-Huxley (1952) giant squid axon model
into ionic format. The implmentation is based on the RHS format in
<code>hh</code>. All the gates are tabulated and can be computed using
Rush-Larsen method.
</p>


<h3 class="numbered"> HH52M</h3>

<p>
Experimental module for testing and developement of matrix Rush-Larsen
method into rushlarsen device. The model is based on the
<i><code>hh52</code></i> model. The INa and IK current is  substituted by equivalent Markov
chain definition. 
</p>

<p>
An example of a script using rushlarsen module with <code>hh52m</code> cellular
model is in:
</p>

<pre class="example">
beatbox/data/scripts/sequential/hh52/hh52m.bbs
</pre>





</div><!-- End contents section -->
<hr/>
<p>
Copyright &copy; (2010-2018) Vadim Biktashev, 
Irina Biktasheva and others, see <a href="../AUTHORS">AUTHORS</a> for
full list of contributors.<br/> 
This file is part of the Beatbox distribution<br/>
</p>

</body>
</html>
